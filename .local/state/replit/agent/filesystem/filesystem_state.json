{"file_contents":{"daily_reminder.py":{"content":"\n#!/usr/bin/env python3\n\"\"\"\nDaily Payment Reminder Script\nRun this script daily to send payment reminders for 90-day payment plans.\n\"\"\"\n\nimport asyncio\nimport sys\nimport os\n\n# Add project root to path\nsys.path.append(os.path.dirname(os.path.abspath(__file__)))\n\nfrom bot.payment_reminder import run_daily_reminder_check\nfrom utils.logger import setup_logger\n\nlogger = setup_logger(__name__)\n\nasync def main():\n    \"\"\"Main function to run daily reminders\"\"\"\n    logger.info(\"Starting daily payment reminder check...\")\n    \n    try:\n        await run_daily_reminder_check()\n        logger.info(\"Daily payment reminder check completed successfully\")\n        \n    except Exception as e:\n        logger.error(f\"Error in daily reminder check: {e}\")\n        return 1\n    \n    return 0\n\nif __name__ == \"__main__\":\n    exit_code = asyncio.run(main())\n    sys.exit(exit_code)\n","size_bytes":866},"main.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nDecoTeen Telegram Bot - Main Entry Point\nربات تلگرام فروشگاه دکوتین\n\"\"\"\n\nimport logging\nfrom telegram.ext import ApplicationBuilder\nfrom bot.handlers import BotHandlers\nfrom bot.config import Config\nfrom utils.logger import setup_logger\nfrom reminder_scheduler import reminder_scheduler\n\n# تنظیم لاگر\nlogger = setup_logger(__name__)\n\n\ndef main():\n    \"\"\"تابع اصلی برای اجرای ربات\"\"\"\n    try:\n        # بارگذاری تنظیمات\n        config = Config()\n\n        if not config.bot_token:\n            logger.error(\"❌ BOT_TOKEN not found in environment variables\")\n            print(\"❌ توکن ربات یافت نشد\")\n            return\n\n        config.print_config_status()\n\n        # ایجاد Application\n        app = ApplicationBuilder().token(config.bot_token).build()\n\n        # ایجاد handlers\n        bot_handlers = BotHandlers()\n\n        # تنظیم handlers\n        bot_handlers.setup_handlers(app)\n\n        # شروع سیستم یادآوری\n        reminder_scheduler.start_scheduler()\n        \n        # شروع ربات\n        logger.info(\"🚀 Starting DecoTeen Bot...\")\n        print(\"✅ ربات شروع شد...\")\n        print(\"🔔 سیستم یادآوری فعال شد...\")\n\n        # Add error handling for multiple bot instances\n        try:\n            app.run_polling(\n                allowed_updates=[\"message\", \"callback_query\"],\n                drop_pending_updates=True,\n                timeout=30,\n                read_timeout=10,\n                write_timeout=10,\n                connect_timeout=10,\n                pool_timeout=10\n            )\n        except Exception as polling_error:\n            logger.error(f\"Polling error: {polling_error}\")\n            # Wait a bit before potentially restarting\n            import time\n            time.sleep(5)\n            raise\n\n    except Exception as e:\n        logger.error(f\"❌ Error starting bot: {e}\")\n        print(f\"❌ خطا در اجرای ربات: {e}\")\n        raise\n    finally:\n        logger.info(\"🛑 Bot stopped\")\n\n\nif __name__ == \"__main__\":\n    print(\"🤖 DecoTeen Telegram Bot\")\n    print(\"=\" * 40)\n\n    try:\n        # اجرای ربات\n        main()\n    except KeyboardInterrupt:\n        print(\"\\n👋 Bot stopped by user\")\n    except Exception as e:\n        print(f\"💥 Fatal error: {e}\")\n        exit(1)\n","size_bytes":2417},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"python-telegram-bot>=22.3\",\n    \"requests>=2.32.4\",\n    \"telegram>=0.0.1\",\n]\n","size_bytes":224},"reminder_scheduler.py":{"content":"\n#!/usr/bin/env python3\n\"\"\"\nAutomated Reminder Scheduler\nاجرای خودکار یادآوری‌های پرداخت\n\"\"\"\n\nimport asyncio\nimport schedule\nimport time\nimport threading\nfrom datetime import datetime\nfrom bot.payment_reminder import run_daily_reminder_check\nfrom utils.logger import setup_logger\n\nlogger = setup_logger(__name__)\n\nclass ReminderScheduler:\n    \"\"\"زمان‌بند خودکار یادآوری‌ها\"\"\"\n    \n    def __init__(self):\n        self.running = False\n        self.thread = None\n    \n    def start_scheduler(self):\n        \"\"\"شروع زمان‌بند\"\"\"\n        if self.running:\n            logger.warning(\"Scheduler is already running\")\n            return\n        \n        self.running = True\n        \n        # تنظیم زمان اجرا - هر روز ساعت 9 صبح\n        schedule.every().day.at(\"09:00\").do(self._run_daily_check)\n        \n        # تنظیم اجرای هر 4 ساعت برای پیگیری بیشتر\n        schedule.every(4).hours.do(self._run_hourly_check)\n        \n        logger.info(\"✅ Reminder scheduler started - Daily at 9:00 AM, Every 4 hours\")\n        \n        # اجرا در thread جداگانه\n        self.thread = threading.Thread(target=self._scheduler_loop, daemon=True)\n        self.thread.start()\n    \n    def stop_scheduler(self):\n        \"\"\"توقف زمان‌بند\"\"\"\n        self.running = False\n        schedule.clear()\n        logger.info(\"🛑 Reminder scheduler stopped\")\n    \n    def _scheduler_loop(self):\n        \"\"\"حلقه اصلی زمان‌بند\"\"\"\n        while self.running:\n            try:\n                schedule.run_pending()\n                time.sleep(60)  # چک هر دقیقه\n            except Exception as e:\n                logger.error(f\"Scheduler error: {e}\")\n                time.sleep(300)  # در صورت خطا، 5 دقیقه صبر کن\n    \n    def _run_daily_check(self):\n        \"\"\"اجرای چک روزانه\"\"\"\n        try:\n            logger.info(\"🔔 Running daily reminder check...\")\n            asyncio.run(run_daily_reminder_check())\n            logger.info(\"✅ Daily reminder check completed\")\n        except Exception as e:\n            logger.error(f\"Daily reminder error: {e}\")\n    \n    def _run_hourly_check(self):\n        \"\"\"اجرای چک 4 ساعته\"\"\"\n        try:\n            current_hour = datetime.now().hour\n            if 8 <= current_hour <= 20:  # فقط در ساعات کاری\n                logger.info(\"🔔 Running hourly reminder check...\")\n                asyncio.run(run_daily_reminder_check())\n                logger.info(\"✅ Hourly reminder check completed\")\n        except Exception as e:\n            logger.error(f\"Hourly reminder error: {e}\")\n\n# Instance برای استفاده در main\nreminder_scheduler = ReminderScheduler()\n\nif __name__ == \"__main__\":\n    reminder_scheduler.start_scheduler()\n    \n    try:\n        while True:\n            time.sleep(1)\n    except KeyboardInterrupt:\n        reminder_scheduler.stop_scheduler()\n        print(\"👋 Reminder scheduler stopped\")\n","size_bytes":3063},"replit.md":{"content":"# Persian E-commerce Telegram Bot\n\n## Overview\n\nThis is a comprehensive Persian e-commerce Telegram bot designed for selling bedding and home textile products. The bot provides a complete shopping experience with customer authentication, hierarchical product browsing, shopping cart management, and invoice generation. The system is built using the python-telegram-bot library and follows a modular architecture with clear separation of concerns.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\nThe application follows a modular architecture with clear separation of concerns:\n\n- **Bot Layer**: Handles Telegram API interactions using the python-telegram-bot library with handlers for commands, callbacks, and messages\n- **Data Layer**: Manages customer database and product catalog using static data structures stored in Python dictionaries\n- **Business Logic Layer**: Processes cart operations, pricing calculations, discount management, and invoice generation\n- **Utilities Layer**: Provides logging, Persian language support, text formatting, and number conversion utilities\n\nThe architecture is designed for maintainability and scalability, with each module having specific responsibilities. The system uses JSON file-based persistence for cart data and maintains user session state in memory.\n\n## Key Components\n\n### 1. Bot Management (`bot/`)\n- **handlers.py**: Main bot handlers for commands (/start, /help), callback queries, and message processing with session management\n- **keyboards.py**: All inline keyboard layouts including main menu, category selection, alphabetical search navigation, and product selection interfaces\n- **cart.py**: Shopping cart management with JSON file-based persistence in `cart_data/` directory, supporting add/remove/clear operations\n- **pricing.py**: Product pricing engine with fixed category prices, discount calculations (30% cash, 25% installment), 9% tax computation, and invoice generation\n- **config.py**: Configuration management using environment variables (BOT_TOKEN, ADMIN_IDS, LOG_LEVEL, CART_DATA_DIR, MAX_CART_ITEMS)\n\n### 2. Data Management (`data/`)\n- **product_data.py**: Complete product catalog with 6 main categories and fixed pricing:\n  - Baby bedding: 4,780,000 toman (19+ products)\n  - Teen bedding: 4,780,000 toman\n  - Adult bedding: 5,600,000 toman\n  - Curtains: 3,500,000 toman\n  - Cushions: 2,800,000 toman\n  - Tablecloth & runners: 2,200,000 toman\n- **customer_service.py**: Customer database with 30+ registered customers, each with unique 6-digit authentication codes, names, and cities\n\n### 3. Utilities (`utils/`)\n- **logger.py**: Centralized logging system with console output, configurable log levels, and timestamp formatting\n- **persian_utils.py**: Persian language utilities including bidirectional number conversion (Persian ↔ English digits), price formatting with thousand separators, and text processing functions\n\n## Recent Changes (August 11, 2025)\n\n### Migration and Bug Fixes Completed\n- **Environment Migration**: Successfully completed migration from Replit Agent to standard Replit environment\n- **Dependencies Verified**: All required packages (python-telegram-bot==20.7, requests, schedule) properly installed\n- **Bot Functionality**: Bot server running successfully with all handlers and schedulers active\n- **Database Integration**: Customer database initialized with 110 customers\n- **Size Selection Error Fixed**: Added error handling and session management improvements for size selection process\n- **Payment Flow Enhancement**: Standardized both 60-day and 90-day payment flows to show invoice with amounts → cash/check selection → process accordingly\n- **Payment System Standardization**: Both 60-day and 90-day payments now follow consistent two-stage flow with proper callback data routing\n\n### Enhanced Two-Stage Payment System Completed\n- **Payment Method Selection**: First stage now shows 60/90 day payment options with discount calculations\n- **Payment Type Selection**: Second stage offers Cash vs Check payment types for each method\n- **Check Payment Workflow**: Complete check payment system with photo upload functionality\n- **Admin Verification System**: Support group receives check photos with admin action buttons\n- **Customer Communication Flow**: Automated messaging system for check processing status updates\n- **Persian Instructions**: Check payment includes specific Persian delivery instructions (10-day requirement)\n\n### Check Payment Features (August 11, 2025)\n- **Photo Upload System**: Customers can upload check photos directly in bot\n- **Admin Processing**: Support group gets check photos with verification buttons\n- **Status Tracking**: Customers can track check processing status via \"در حال پیگیری\" button\n- **Delivery Requirements**: Clear 10-day delivery instruction to factory accounting\n- **Complete Integration**: Check orders fully integrated with existing order management system\n\n### Enhanced Check Payment System (August 11, 2025)\n- **Specific Admin Recipients**: Replaced generic admin buttons with specific recipient buttons:\n  - خانم فرانک غریبی (National ID: 0012311138)\n  - نیما کریمی (National ID: 0451640594) \n  - مجید ترابیان (National ID: 007335310)\n  - وحید ترابیان (National ID: 0077860357)\n- **Customer Confirmation System**: Added \"چک را ثبت کرده ام وتا 10 روز کاری ارسال خواهم کرد\" button in customer chat only\n- **Clean Admin Interface**: Admin support group shows only recipient selection buttons, no customer actions\n- **Automatic Re-submission**: Customer confirmation resends invoice and check photo to support group\n- **Personalized Messages**: Each recipient selection sends specific message with name and national ID\n- **Complete Integration**: All features work seamlessly with existing payment system\n\n### Bug Fixes and Maintenance (August 11, 2025)\n- **Fixed Category Navigation**: Resolved issue where clicking product categories showed default message\n- **Fixed Photo Upload Error**: Resolved KeyError when payment_info is missing during check photo upload\n- **Added Missing Methods**: Added public `generate_order_id()` and `save_order()` methods to OrderManagementServer\n- **Enhanced Error Logging**: Improved callback error reporting for better debugging\n- **Removed Check Confirmation Message**: Removed \"✅ عکس چک دریافت شد و برای تیم پشتیبانی ارسال شد\" message for cleaner user experience\n- **Clean Interface Updates**: Removed customer confirmation button from admin support group keyboards\n- **Preserved Existing Functionality**: All original bot features remain intact and functional\n\n## Previous Changes (August 10, 2025)\n\n### Migration Completed\n- **Replit Environment Migration**: Successfully migrated from Replit Agent to standard Replit environment\n- **Dependencies Updated**: Installed python-telegram-bot==20.7 and requests packages via package manager\n- **Security Enhancement**: Configured BOT_TOKEN as environment variable for secure token management\n- **Bot Activation**: DecoTeen Telegram Bot is now running successfully with proper configuration\n\n### Hesabfa Integration Status\n- **Integration Attempted**: Attempted comprehensive integration with Hesabfa accounting system\n- **Network Limitation Confirmed**: Replit environment cannot access Hesabfa API endpoints due to network restrictions\n- **Alternative Implementation**: Complete order data logging system implemented for manual invoice creation workflow\n- **Order Management**: Enhanced order tracking and status management with detailed logging for admin workflow\n\n### UI Improvements Completed (August 10, 2025)\n- **Pagination System**: Added pagination buttons (\"دکمه صفحه بعد\") for all product categories\n- **Button Layout**: Improved column alignment with 8 items per page (4 rows × 2 buttons) for better navigation\n- **Categories Enhanced**: Baby, Curtain, Cushion, Tablecloth, and alphabetical search now support pagination\n- **Navigation Flow**: Updated handlers to support pagination navigation with proper state management\n\n### Enhanced Order Cancellation System (August 10, 2025)\n- **Remaining Balance Display**: When admin cancels an order, customer sees detailed invoice breakdown with remaining balance amount\n- **Payment Recovery Flow**: Added \"واریز مانده حساب\" button for cancelled orders to allow balance payment\n- **Receipt Processing**: Customers can upload receipt photos for remaining balance payments\n- **Admin Re-approval**: System sends receipt to support group with admin buttons for order re-confirmation\n- **Streamlined Interface**: Cancelled orders show only \"Contact Support\" and \"Pay Remaining Balance\" buttons\n- **Complete Workflow**: Full cycle from cancellation → balance payment → receipt upload → admin approval → order reactivation\n\n## Previous Changes (July 27, 2025)\n\n- **Direct Catalog Access**: After authentication, customers now see the product catalog immediately instead of welcome page\n- **Updated Product Data**: Baby products now include authentic names like \"فارست\" and \"بو\" from original catalog\n- **Size Restrictions**: \n  - Baby category: Only 70×160 size available\n  - Teen/Adult categories: Removed 75×160 size option\n- **Enhanced Payment Options**: Added 90-day payment option (25% discount + 25% advance payment)\n- **Improved Invoice**: Includes discount calculations and detailed payment breakdown\n\n## Data Flow\n\n1. **User Authentication**: Customer enters unique 6-digit code → system validates against customer database → authenticated session created → direct catalog display\n2. **Product Browsing**: Category selection → subcategory (for curtains) → alphabetical search using Persian keyboard → product selection with category-specific size options\n3. **Cart Management**: Add products with size/quantity selection → view cart with itemized breakdown → modify quantities or remove items\n4. **Checkout Process**: Generate invoice with customer details → calculate discounts and taxes → display three payment options (cash 30%, installment 25%, 90-day 25% + 25% advance)\n\n## External Dependencies\n\n- **python-telegram-bot**: Core Telegram Bot API wrapper for handling updates, commands, and callbacks\n- **Python Standard Library**: json for cart persistence, os for file operations, logging for system monitoring, datetime for invoice timestamps\n- **No database dependencies**: Uses file-based JSON storage for cart data and in-memory dictionaries for product/customer data\n\n## Deployment Strategy\n\nThe application is configured for deployment on Replit with:\n\n- **Environment Variables**: BOT_TOKEN (required), ADMIN_IDS, LOG_LEVEL, CART_DATA_DIR, MAX_CART_ITEMS\n- **File Structure**: Modular package structure with clear separation between bot logic, data management, and utilities\n- **Persistence**: JSON files in `cart_data/` directory for shopping cart storage\n- **Error Handling**: Comprehensive logging and graceful error recovery throughout the application\n- **Session Management**: In-memory user session tracking for authentication state and navigation context\n\nThe bot is designed to be stateless regarding user authentication (relies on customer code validation) but maintains cart state through file persistence, making it suitable for cloud deployment environments.","size_bytes":11438},"run_monthly_reminders.py":{"content":"\n#!/usr/bin/env python3\n\"\"\"\nMonthly Payment Reminder Runner\nاجرای یادآوری‌های پرداخت ماهانه برای پرداخت‌های اقساطی\n\"\"\"\n\nimport asyncio\nimport sys\nimport os\nfrom datetime import datetime\n\n# Add project root to path\nsys.path.append(os.path.dirname(os.path.abspath(__file__)))\n\nfrom bot.payment_reminder import PaymentReminderBot\nfrom bot.config import Config\nfrom utils.logger import setup_logger\n\nlogger = setup_logger(__name__)\n\nasync def run_monthly_reminders():\n    \"\"\"اجرای یادآوری‌های ماهانه\"\"\"\n    try:\n        logger.info(\"🔄 شروع بررسی یادآوری‌های پرداخت ماهانه...\")\n        \n        config = Config()\n        reminder_bot = PaymentReminderBot(config)\n        \n        # ارسال یادآوری‌های روزانه (که شامل یادآوری‌های ماهانه هم می‌شود)\n        await reminder_bot.send_daily_reminders()\n        \n        logger.info(\"✅ بررسی یادآوری‌های ماهانه با موفقیت تکمیل شد\")\n        \n    except Exception as e:\n        logger.error(f\"❌ خطا در اجرای یادآوری‌های ماهانه: {e}\")\n        raise\n\nif __name__ == \"__main__\":\n    asyncio.run(run_monthly_reminders())\n","size_bytes":1287},"bot/__init__.py":{"content":"\"\"\"\nBot Package\nContains all bot-related functionality including handlers, keyboards, and cart management.\n\"\"\"\n","size_bytes":111},"bot/cart.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nShopping Cart Management\nHandles cart operations with JSON file-based persistence.\n\"\"\"\n\nimport json\nimport os\nfrom typing import List, Dict, Any, Optional\nfrom utils.logger import setup_logger\n\nlogger = setup_logger(__name__)\n\nclass CartManager:\n    \"\"\"Manages shopping cart operations with file-based persistence\"\"\"\n    \n    def __init__(self, cart_data_dir: str = \"cart_data\"):\n        self.cart_data_dir = cart_data_dir\n        # Ensure cart data directory exists\n        os.makedirs(self.cart_data_dir, exist_ok=True)\n    \n    def _get_cart_file_path(self, user_id: int) -> str:\n        \"\"\"Get the file path for a user's cart\"\"\"\n        return os.path.join(self.cart_data_dir, f\"cart_{user_id}.json\")\n    \n    def get_cart(self, user_id: int) -> List[Dict[str, Any]]:\n        \"\"\"Get cart items for a user\"\"\"\n        cart_file = self._get_cart_file_path(user_id)\n        \n        try:\n            if os.path.exists(cart_file):\n                with open(cart_file, 'r', encoding='utf-8') as f:\n                    return json.load(f)\n            return []\n        except Exception as e:\n            logger.error(f\"Error loading cart for user {user_id}: {e}\")\n            return []\n    \n    def save_cart(self, user_id: int, cart_items: List[Dict[str, Any]]) -> bool:\n        \"\"\"Save cart items for a user\"\"\"\n        cart_file = self._get_cart_file_path(user_id)\n        \n        try:\n            with open(cart_file, 'w', encoding='utf-8') as f:\n                json.dump(cart_items, f, ensure_ascii=False, indent=2)\n            logger.info(f\"Cart saved for user {user_id}: {len(cart_items)} items\")\n            return True\n        except Exception as e:\n            logger.error(f\"Error saving cart for user {user_id}: {e}\")\n            return False\n    \n    def add_to_cart(self, user_id: int, item: Dict[str, Any]) -> bool:\n        \"\"\"Add an item to user's cart\"\"\"\n        cart_items = self.get_cart(user_id)\n        \n        # Check if item already exists in cart\n        existing_item = None\n        for cart_item in cart_items:\n            if (cart_item['product_id'] == item['product_id'] and \n                cart_item['size'] == item['size']):\n                existing_item = cart_item\n                break\n        \n        if existing_item:\n            # Update quantity\n            existing_item['quantity'] += item['quantity']\n            logger.info(f\"Updated quantity for product {item['product_id']} in cart of user {user_id}\")\n        else:\n            # Add new item\n            cart_items.append(item)\n            logger.info(f\"Added new product {item['product_id']} to cart of user {user_id}\")\n        \n        return self.save_cart(user_id, cart_items)\n    \n    def remove_from_cart(self, user_id: int, product_id: str, size: str) -> bool:\n        \"\"\"Remove an item from user's cart\"\"\"\n        cart_items = self.get_cart(user_id)\n        \n        # Find and remove the item\n        cart_items = [\n            item for item in cart_items \n            if not (item['product_id'] == product_id and item['size'] == size)\n        ]\n        \n        logger.info(f\"Removed product {product_id} (size {size}) from cart of user {user_id}\")\n        return self.save_cart(user_id, cart_items)\n    \n    def update_quantity(self, user_id: int, product_id: str, size: str, new_quantity: int) -> bool:\n        \"\"\"Update quantity of an item in user's cart\"\"\"\n        cart_items = self.get_cart(user_id)\n        \n        for item in cart_items:\n            if item['product_id'] == product_id and item['size'] == size:\n                if new_quantity <= 0:\n                    # Remove item if quantity is 0 or negative\n                    return self.remove_from_cart(user_id, product_id, size)\n                else:\n                    item['quantity'] = new_quantity\n                    logger.info(f\"Updated quantity of product {product_id} to {new_quantity} for user {user_id}\")\n                    return self.save_cart(user_id, cart_items)\n        \n        logger.warning(f\"Product {product_id} (size {size}) not found in cart of user {user_id}\")\n        return False\n    \n    def clear_cart(self, user_id: int) -> bool:\n        \"\"\"Clear all items from user's cart\"\"\"\n        return self.save_cart(user_id, [])\n    \n    def get_cart_total(self, user_id: int) -> float:\n        \"\"\"Calculate total price of items in user's cart\"\"\"\n        cart_items = self.get_cart(user_id)\n        total = sum(item['price'] * item['quantity'] for item in cart_items)\n        return total\n    \n    def get_cart_item_count(self, user_id: int) -> int:\n        \"\"\"Get total number of items in user's cart\"\"\"\n        cart_items = self.get_cart(user_id)\n        return sum(item['quantity'] for item in cart_items)\n    \n    def is_cart_empty(self, user_id: int) -> bool:\n        \"\"\"Check if user's cart is empty\"\"\"\n        cart_items = self.get_cart(user_id)\n        return len(cart_items) == 0\n    \n    def get_cart_summary(self, user_id: int) -> Dict[str, Any]:\n        \"\"\"Get a summary of user's cart\"\"\"\n        cart_items = self.get_cart(user_id)\n        \n        return {\n            'items': cart_items,\n            'item_count': sum(item['quantity'] for item in cart_items),\n            'total_price': sum(item['price'] * item['quantity'] for item in cart_items),\n            'unique_products': len(cart_items)\n        }\n","size_bytes":5344},"bot/config.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nBot Configuration - Fixed Version\nManages environment variables and configuration settings.\n\"\"\"\n\nimport os\nimport logging\nfrom typing import List, Optional\n\n\nclass Config:\n    \"\"\"Configuration class for the Telegram bot\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize configuration from environment variables\"\"\"\n        # Get bot token from environment or use provided token\n        self.bot_token: str = os.getenv(\"BOT_TOKEN\", \"482872229:AAEG0hySlWspi-KOF5lbR2fMZGJ1qWUPLn0\")\n\n        if not self.bot_token:\n            raise ValueError(\"BOT_TOKEN not found in environment variables\")\n\n        # ZarinPal configuration - using your provided merchant ID\n        self.zarinpal_merchant_id: str = os.getenv(\n            \"ZARINPAL_MERCHANT_ID\", \"fd4166f9-78e2-4228-ac7d-077a5168f064\")\n        self.zarinpal_sandbox: bool = os.getenv(\"ZARINPAL_SANDBOX\",\n                                                \"True\").lower() == \"true\"\n\n        # Order group settings\n        self.order_group_chat_id = os.getenv('ORDER_GROUP_CHAT_ID')\n\n        # اگر تنظیم نشده، از Chat ID گروه DecoTeen Bot Orders استفاده کن\n        if not self.order_group_chat_id:\n            # Chat ID از عکس: -4804296164 (گروه DecoTeen Bot Orders)\n            self.order_group_chat_id = -4804296164\n            logging.info(\n                f\"✅ استفاده از گروه پیش‌فرض: {self.order_group_chat_id}\")\n        else:\n            # تبدیل به int\n            try:\n                self.order_group_chat_id = int(self.order_group_chat_id)\n                logging.info(\n                    f\"✅ استفاده از گروه تنظیم شده: {self.order_group_chat_id}\")\n            except ValueError:\n                logging.error(\n                    f\"❌ ORDER_GROUP_CHAT_ID نامعتبر: {self.order_group_chat_id}\"\n                )\n                # استفاده از گروه پیش‌فرض\n                self.order_group_chat_id = -4804296164\n                logging.info(\n                    f\"✅ استفاده از گروه پیش‌فرض به جای نامعتبر: {self.order_group_chat_id}\"\n                )\n\n        # Optional configurations with safe defaults\n        self.admin_ids: List[int] = self._parse_admin_ids()\n        self.log_level: str = os.getenv(\"LOG_LEVEL\", \"INFO\")\n        self.cart_data_dir: str = os.getenv(\"CART_DATA_DIR\", \"cart_data\")\n        self.max_cart_items: int = int(os.getenv(\"MAX_CART_ITEMS\", \"50\"))\n\n        # Bot domain for payment callbacks\n        self.bot_domain: str = os.getenv(\"BOT_DOMAIN\", \"example.com\")\n\n    def _parse_admin_ids(self) -> List[int]:\n        \"\"\"Parse admin IDs from environment variable\"\"\"\n        admin_ids_str = os.getenv(\"ADMIN_IDS\", \"\")\n        if not admin_ids_str:\n            return []\n\n        try:\n            return [\n                int(id_str.strip()) for id_str in admin_ids_str.split(\",\")\n                if id_str.strip()\n            ]\n        except ValueError:\n            logging.warning(\"Invalid ADMIN_IDS format. Using empty list.\")\n            return []\n\n    def get_callback_url(self) -> str:\n        \"\"\"Get payment callback URL\"\"\"\n        return f\"https://{self.bot_domain}/payment/callback\"\n\n    def validate_setup(self) -> List[str]:\n        \"\"\"Validate configuration and return list of issues\"\"\"\n        issues = []\n\n        if not self.bot_token or self.bot_token == \"YOUR_BOT_TOKEN_HERE\":\n            issues.append(\"BOT_TOKEN is not set or using placeholder value\")\n\n        if not self.zarinpal_merchant_id or self.zarinpal_merchant_id == \"YOUR_MERCHANT_ID\":\n            issues.append(\n                \"ZARINPAL_MERCHANT_ID is not set or using placeholder value\")\n\n        if self.bot_domain == \"example.com\":\n            issues.append(\n                \"BOT_DOMAIN should be set to your actual domain (required for payment callbacks)\"\n            )\n\n        if not self.admin_ids:\n            issues.append(\"Consider setting ADMIN_IDS for bot administration\")\n\n        return issues\n\n    def print_config_status(self):\n        \"\"\"Print configuration status for debugging\"\"\"\n        print(\"=== Bot Configuration Status ===\")\n        print(f\"Bot Token: ✅ Set and Ready\")\n        print(\n            f\"ZarinPal Merchant ID: ✓ Set ({self.zarinpal_merchant_id[:8]}...{self.zarinpal_merchant_id[-8:]})\"\n        )\n        print(f\"Bot Domain: ✓ Set ({self.bot_domain})\")\n        print(f\"Callback URL: {self.get_callback_url()}\")\n        print(f\"Admin IDs: {len(self.admin_ids)} configured\")\n        print(f\"Order Group ID: ✓ Set ({self.order_group_chat_id})\")\n        print(\n            f\"ZarinPal Sandbox: {'Enabled' if self.zarinpal_sandbox else 'Disabled'}\"\n        )\n        print(f\"Max Cart Items: {self.max_cart_items}\")\n        print(\"================================\")\n\n        issues = self.validate_setup()\n        if issues:\n            print(\"⚠️ Configuration Notes:\")\n            for issue in issues:\n                print(f\"  - {issue}\")\n        else:\n            print(\"✅ Configuration is complete!\")\n\n    async def test_group_connection(self, bot):\n        \"\"\"Test connection to order group\"\"\"\n        if not self.order_group_chat_id:\n            print(\"❌ Order group ID not configured\")\n            return False\n\n        try:\n            # Try to get chat info\n            chat = await bot.get_chat(self.order_group_chat_id)\n            print(f\"✅ Group connection successful!\")\n            print(f\"   Title: {chat.title}\")\n            print(f\"   Type: {chat.type}\")\n            print(\n                f\"   Member count: {await bot.get_chat_member_count(self.order_group_chat_id)}\"\n            )\n            return True\n        except Exception as e:\n            print(f\"❌ Group connection failed: {e}\")\n            print(f\"   Group ID: {self.order_group_chat_id}\")\n            print(\"   Possible issues:\")\n            print(\"   - Bot is not a member of the group\")\n            print(\"   - Group ID is incorrect\")\n            print(\"   - Bot doesn't have permission to send messages\")\n            return False\n\n\n# Example usage and testing\nif __name__ == \"__main__\":\n    config = Config()\n    config.print_config_status()\n\n    print(\"\\n✅ Setup Complete! Your bot is ready to run!\")\n","size_bytes":6271},"bot/handlers.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nBot Handlers\nMain bot handlers for commands, callbacks, and message processing.\n\"\"\"\n\nfrom telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup\nfrom telegram.ext import ContextTypes, CommandHandler, CallbackQueryHandler, MessageHandler, filters\nfrom bot.keyboards import BotKeyboards\nfrom bot.cart import CartManager\nfrom bot.pricing import PricingManager\nfrom bot.zarinpal import ZarinPalGateway\nfrom bot.payment_scheduler import PaymentScheduler\nfrom bot.order_server import OrderManagementServer, OrderStatus\nfrom bot.config import Config\nfrom data.customer_service import CustomerService\nfrom data.product_data import (get_products_by_category, get_product_by_id,\n                               search_products_by_name,\n                               search_products_by_icon, get_category_info,\n                               get_product_price, PERSIAN_ALPHABET,\n                               PRODUCT_PRICES)\nfrom utils.logger import setup_logger\nfrom utils.persian_utils import format_price, persian_numbers\nfrom datetime import datetime\nfrom typing import Dict, List\nimport json\n\nlogger = setup_logger(__name__)\n\n\nclass BotHandlers:\n    \"\"\"Main class handling all bot interactions\"\"\"\n\n    def __init__(self):\n        self.keyboards = BotKeyboards()\n        self.cart_manager = CartManager()\n        self.pricing_manager = PricingManager()\n        self.customer_service = CustomerService()\n        self.config = Config()\n        self.zarinpal = ZarinPalGateway(\n            merchant_id=self.config.zarinpal_merchant_id,\n            sandbox=self.config.zarinpal_sandbox)\n        self.payment_scheduler = PaymentScheduler()\n        self.order_server = OrderManagementServer()\n        self.user_sessions = {}  # Store user session data\n        self.bot = None  # Bot instance برای اطلاع‌رسانی\n        logger.info(\n            \"🔄 PricingManager initialized with updated payment display configurations\"\n        )\n\n    def setup_handlers(self, application):\n        \"\"\"Setup all bot handlers\"\"\"\n        # تنظیم bot instance در سرور سفارشات و handlers\n        self.order_server.set_bot(application.bot)\n        self.bot = application.bot  # تنظیم bot instance در handlers\n\n        # Command handlers\n        application.add_handler(CommandHandler(\"start\", self.start_command))\n        application.add_handler(CommandHandler(\"help\", self.help_command))\n        application.add_handler(CommandHandler(\"debug\", self.debug_command))\n        application.add_handler(\n            CommandHandler(\"pricing\", self.pricing_test_command))\n\n        # Callback query handlers\n        application.add_handler(CallbackQueryHandler(self.button_callback))\n\n        # Message handlers\n        application.add_handler(\n            MessageHandler(filters.TEXT & ~filters.COMMAND,\n                           self.handle_text_message))\n\n        # Photo handler for receipt uploads\n        application.add_handler(\n            MessageHandler(filters.PHOTO, self.handle_photo_message))\n\n        # Group message handler for support\n        application.add_handler(\n            MessageHandler(filters.TEXT & filters.ChatType.GROUPS,\n                           self.handle_group_message))\n\n        logger.info(\"✅ All handlers registered successfully\")\n\n    async def start_command(self, update: Update,\n                            context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Handle /start command\"\"\"\n        user_id = update.effective_user.id\n        logger.info(f\"User {user_id} started the bot\")\n\n        # Set user state to awaiting customer code directly\n        if user_id not in self.user_sessions:\n            self.user_sessions[user_id] = {}\n        self.user_sessions[user_id]['awaiting_customer_code'] = True\n\n        welcome_text = (\"🔐 خوش آمدید به فروشگاه دکوتین\\n\\n\"\n                        \"لطفاً کد شش رقمی نمایندگی خود را وارد کنید:\")\n\n        await update.message.reply_text(welcome_text)\n\n    async def help_command(self, update: Update,\n                           context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Handle /help command\"\"\"\n        help_text = (\"📋 راهنمای استفاده از ربات:\\n\\n\"\n                     \"🔹 /start - شروع کار با ربات\\n\"\n                     \"🔹 احراز هویت با کد نمایندگی\\n\"\n                     \"🔹 مرور محصولات بر اساس دسته‌بندی\\n\"\n                     \"🔹 جستجوی حروف الفبایی\\n\"\n                     \"🔹 انتخاب سایز و تعداد\\n\"\n                     \"🔹 افزودن به سبد خرید\\n\"\n                     \"🔹 مشاهده فاکتور و پرداخت\\n\\n\"\n                     \"💡 برای شروع دکمه «احراز هویت نماینده» را بزنید.\")\n        await update.message.reply_text(help_text)\n\n    async def debug_command(self, update: Update,\n                            context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Handle /debug command - for troubleshooting\"\"\"\n        chat_id = update.effective_chat.id\n        chat_type = update.effective_chat.type\n        user_id = update.effective_user.id\n\n        debug_info = (\n            f\"🔍 اطلاعات دیباگ:\\n\\n\"\n            f\"💬 Chat ID: {chat_id}\\n\"\n            f\"📝 Chat Type: {chat_type}\\n\"\n            f\"👤 User ID: {user_id}\\n\"\n            f\"⚙️ Configured Group ID: {self.config.order_group_chat_id}\\n\"\n            f\"✅ Match: {'YES' if str(chat_id) == str(self.config.order_group_chat_id) else 'NO'}\\n\\n\"\n            f\"📋 Test Commands:\\n\"\n            f\"• سفارش\\n\"\n            f\"• راهنما\\n\"\n            f\"• آمار\")\n\n        await update.message.reply_text(debug_info)\n\n        # ذخیره Chat ID برای استفاده آینده\n        logger.info(\n            f\"🔧 DEBUG: Chat ID {chat_id} can be used as ORDER_GROUP_CHAT_ID\")\n\n    async def pricing_test_command(self, update: Update,\n                                   context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Handle /pricing command - test pricing functionality\"\"\"\n        test_items = [{\n            'product_name': 'تشک بچه تست',\n            'size': '120x60',\n            'quantity': 1,\n            'price': 4780000\n        }]\n        test_customer = {\n            'name': 'تست کاربر',\n            'city': 'تهران',\n            'customer_id': '123456'\n        }\n\n        # Test different pricing methods\n        cash_invoice = self.pricing_manager.generate_final_invoice(\n            test_items, test_customer, \"پرداخت نقدی\", 0.30)\n\n        pricing_info = (\n            f\"💰 تست سیستم قیمت‌گذاری:\\n\\n\"\n            f\"🔧 نرخ تخفیف نقدی: {self.pricing_manager.discount_rates.get('cash', 0) * 100}%\\n\"\n            f\"🔧 نرخ تخفیف اقساطی: {self.pricing_manager.discount_rates.get('installment', 0) * 100}%\\n\"\n            f\"🔧 نرخ تخفیف 90 روزه: {self.pricing_manager.discount_rates.get('90day', 0) * 100}%\\n\\n\"\n            f\"📄 نمونه فاکتور:\\n\"\n            f\"{cash_invoice[:200]}...\")\n\n        await update.message.reply_text(pricing_info)\n        logger.info(\n            f\"💰 Pricing test executed for user {update.effective_user.id}\")\n\n    async def button_callback(self, update: Update,\n                              context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Handle all button callbacks - Optimized version\"\"\"\n        query = update.callback_query\n        user_id = query.from_user.id\n        data = query.data\n\n        # Fast answer to prevent timeout\n        await query.answer()\n\n        logger.debug(f\"User {user_id} pressed: {data}\")\n\n        # Quick routing dictionary for better performance\n        handlers = {\n            \"authenticate\": self._handle_authentication_request,\n            \"main_menu\": self._handle_main_menu,\n            \"start_shopping\": self._handle_start_shopping,\n            \"view_cart\": self._handle_view_cart,\n            \"view_invoice\": self._handle_view_invoice,\n            \"upload_receipt\": self._handle_upload_receipt_request,\n            \"confirm_payment_receipt\":\n            self._handle_payment_receipt_confirmation,\n            \"confirm_payment_terms\": self._handle_payment_terms_confirmation,\n            \"confirm_order\": self._handle_order_confirmation,\n            \"cart_clear\": self._handle_cart_clear,\n            \"verify_payment\": self._handle_payment_verification,\n            \"payment_completed\": self._handle_payment_completed,\n            \"back_to_categories\": self._handle_back_to_categories,\n            \"back_to_alphabet\": self._handle_back_to_alphabet,\n            \"back_to_curtain_subcategories\":\n            self._handle_back_to_curtain_subcategories,\n            \"back_to_products\": self._handle_back_to_products,\n            \"daily_stats\": self._handle_daily_stats_request,\n            \"refresh_daily_orders\": self._handle_refresh_daily_orders,\n            \"back_to_daily_orders\": self._handle_back_to_daily_orders,\n            \"contact_support\": self._handle_contact_support_request,\n            \"faq\": self._handle_faq_request,\n            \"confirm_60day_order\": self._handle_60day_order_confirmation,\n            \"upload_check_photo\": self._handle_upload_check_photo_request,\n            \"check_follow_up\": self._handle_check_follow_up,\n            \"confirm_check_submission\": self._handle_confirm_check_submission,\n        }\n\n        try:\n            # Direct handler for exact matches\n            if data in handlers:\n                await handlers[data](query)\n                return\n\n            # Prefix-based routing for better performance\n            if data.startswith(\"category_\"):\n                await self._handle_category_selection(query, data)\n            elif data.startswith(\"subcategory_\"):\n                await self._handle_subcategory_selection(query, data)\n            elif data.startswith(\"alpha_\"):\n                await self._handle_alphabet_selection(query, data)\n            elif data.startswith(\"product_\"):\n                await self._handle_product_selection(query, data)\n            elif data.startswith(\"size_selection_\"):\n                await self._handle_size_selection_from_category(query, data)\n            elif data.startswith(\"size_\"):\n                await self._handle_size_selection(query, data)\n            # Pagination handlers\n            elif data.startswith(\"baby_page_\"):\n                await self._handle_baby_page(query, data)\n            elif data.startswith(\"curtain_page_\"):\n                await self._handle_curtain_page(query, data)\n            elif data.startswith(\"cushion_page_\"):\n                await self._handle_cushion_page(query, data)\n            elif data.startswith(\"tablecloth_page_\"):\n                await self._handle_tablecloth_page(query, data)\n            elif data.startswith(\"alpha_page_\"):\n                await self._handle_alpha_page(query, data)\n            elif data.startswith(\"qty_\"):\n                await self._handle_quantity_selection(query, data)\n            elif data.startswith(\"payment_type_\"):\n                await self._handle_payment_type_selection(query, data)\n            elif data.startswith(\"payment_\"):\n                await self._handle_payment_selection(query, data)\n            elif data.startswith(\"order_status_\"):\n                await self._handle_order_status_update(query, data)\n            elif data.startswith(\"order_details_\"):\n                await self._handle_order_details_request(query, data)\n            elif data.startswith(\"order_\"):\n                await self._handle_order_actions(query, data)\n            elif data.startswith(\"alphabet_search_\"):\n                await self._handle_alphabet_search(query, data)\n\n            elif data.startswith(\"sewing_\"):\n                await self._handle_sewing_type_selection(query, data)\n            elif data.startswith(\"fabric_\"):\n                await self._handle_fabric_selection(query, data)\n            elif data == \"back_to_fabric_selection\":\n                await self._handle_back_to_fabric_selection(query)\n            elif data == \"back_to_sewing_type\":\n                await self._handle_back_to_sewing_type(query)\n            elif data.startswith(\"payment_confirmed_\"):\n                await self._handle_payment_confirmation_from_group(query, data)\n            elif data.startswith(\"contact_made_\"):\n                await self._handle_contact_made_from_group(query, data)\n            elif data.startswith(\"remind_tomorrow_\"):\n                await self._handle_remind_tomorrow_from_group(query, data)\n            elif data.startswith(\"pay_remaining_\"):\n                await self._handle_pay_remaining_balance(query, data)\n            elif data.startswith(\"confirm_remaining_payment_\"):\n                await self._handle_confirm_remaining_payment(query, data)\n            elif data == \"confirm_remaining_payment_receipt\":\n                await self._handle_confirm_remaining_payment(query, \"confirm_remaining_payment_receipt\")\n            elif data == \"upload_remaining_receipt\":\n                await self._handle_upload_remaining_receipt(query)\n            elif data.startswith(\"check_info_sent_\"):\n                await self._handle_check_info_sent(query, data)\n            elif data.startswith(\"check_contacted_\"):\n                await self._handle_check_contacted(query, data)\n            elif data.startswith(\"check_recipient_\"):\n                await self._handle_check_recipient_selection(query, data)\n            elif data.startswith(\"check_customer_confirm_\"):\n                await self._handle_check_customer_confirmation(query, data)\n            else:\n                logger.warning(f\"Unhandled callback data: {data}\")\n                await query.edit_message_text(\" سفارش درحال پیگیری است .\")\n\n        except Exception as e:\n            logger.error(f\"Callback error for {data}: {e}\")\n            logger.error(f\"Exception type: {type(e)}\")\n            logger.error(f\"Exception traceback:\", exc_info=True)\n            try:\n                await query.edit_message_text(\n                    \"❌ خطایی رخ داد. لطفاً دوباره تلاش کنید.\")\n            except:\n                pass  # Prevent secondary errors\n\n    async def handle_text_message(self, update: Update,\n                                  context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Handle text messages\"\"\"\n        user_id = update.effective_user.id\n        text = update.message.text.strip()\n\n        # Check if user is in authentication process\n        if user_id in self.user_sessions and self.user_sessions[user_id].get(\n                'awaiting_customer_code'):\n            await self._handle_customer_code_input(update, text)\n        # Check if user is inputting curtain height\n        elif user_id in self.user_sessions and self.user_sessions[user_id].get(\n                'awaiting_curtain_height'):\n            await self._handle_curtain_height_input(update, text)\n        else:\n            await update.message.reply_text(\n                \"لطفاً از دکمه‌های موجود استفاده کنید.\",\n                reply_markup=self.keyboards.get_main_menu(\n                    self._is_authenticated(user_id)))\n\n    async def handle_photo_message(self, update: Update,\n                                   context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Handle photo messages (for receipt uploads)\"\"\"\n        user_id = update.effective_user.id\n\n        # Check if user is waiting for receipt upload (for orders)\n        if (user_id in self.user_sessions and self.user_sessions[user_id].get(\n                'payment_info', {}).get('awaiting_receipt')):\n            await self._handle_order_receipt_upload(update, user_id)\n        # Check if user is waiting for remaining balance receipt upload\n        elif (user_id in self.user_sessions and self.user_sessions[user_id].get(\n                'remaining_payment', {}).get('awaiting_receipt')):\n            await self._handle_remaining_receipt_upload(update, user_id)\n        # Check if user is waiting for check photo upload\n        elif (user_id in self.user_sessions and self.user_sessions[user_id].get(\n                'awaiting_check_photo')):\n            await self._handle_check_photo_upload(update, user_id)\n\n            # Store photo info\n            photo = update.message.photo[-1]  # Get highest resolution photo\n            self.user_sessions[user_id]['receipt_photo'] = {\n                'file_id': photo.file_id,\n                'file_unique_id': photo.file_unique_id\n            }\n\n            # Get payment info for final invoice display - handle missing payment_info\n            payment_info = self.user_sessions[user_id].get('payment_info')\n            if not payment_info:\n                # If payment_info is missing, skip to main menu without any confirmation message\n                await update.message.reply_text(\n                    \"لطفاً دوباره روش پرداخت را انتخاب کنید.\",\n                    reply_markup=self.keyboards.get_main_menu(self._is_authenticated(user_id)))\n                return\n            customer = self.user_sessions[user_id]['customer']\n            cart_items = self.cart_manager.get_cart(user_id)\n\n            # Generate final invoice text\n            final_invoice = (\n                f\"✅ فاکتور نهایی\\n\"\n                f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n                f\"👤 مشتری: {customer['name']}\\n\"\n                f\"🏙️ شهر: {customer['city']}\\n\"\n                f\"💳 روش پرداخت: {payment_info['payment_method']}\\n\\n\"\n                f\"💰 مبلغ کل: {format_price(payment_info['subtotal'])} تومان\\n\"\n                f\"🎁 تخفیف ({persian_numbers(str(int(payment_info['discount_rate'] * 100)))}٪): {format_price(payment_info['discount'])} تومان\\n\"\n                f\"💰 مبلغ پرداختی: {format_price(payment_info['amount'])} تومان\\n\\n\"\n                f\"📸 فیش واریزی دریافت شد\\n\"\n                f\"✅ آماده تایید نهایی سفارش\")\n\n            # Show confirmation button with final invoice\n            keyboard = [[\n                InlineKeyboardButton(\"✅ سفارش را تایید می‌کنم\",\n                                     callback_data=\"confirm_payment_receipt\")\n            ],\n                        [\n                            InlineKeyboardButton(\n                                \"🔄 ارسال عکس جدید\",\n                                callback_data=\"upload_receipt\")\n                        ]]\n\n            await update.message.reply_text(\n                final_invoice, reply_markup=InlineKeyboardMarkup(keyboard))\n        else:\n            await update.message.reply_text(\n                \"لطفاً ابتدا روش پرداخت را انتخاب کنید.\",\n                reply_markup=self.keyboards.get_main_menu(\n                    self._is_authenticated(user_id)))\n\n    async def _handle_order_receipt_upload(self, update, user_id):\n        \"\"\"Handle receipt upload for regular orders\"\"\"\n        # Store photo info\n        photo = update.message.photo[-1]  # Get highest resolution photo\n        self.user_sessions[user_id]['receipt_photo'] = {\n            'file_id': photo.file_id,\n            'file_unique_id': photo.file_unique_id\n        }\n\n        # Get payment info for final invoice display\n        payment_info = self.user_sessions[user_id]['payment_info']\n        customer = self.user_sessions[user_id]['customer']\n        cart_items = self.cart_manager.get_cart(user_id)\n\n        # Generate final invoice text\n        final_invoice = (\n            f\"✅ فاکتور نهایی\\n\"\n            f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n            f\"👤 مشتری: {customer['name']}\\n\"\n            f\"🏙️ شهر: {customer['city']}\\n\"\n            f\"💳 روش پرداخت: {payment_info['payment_method']}\\n\\n\"\n            f\"💰 مبلغ کل: {format_price(payment_info['subtotal'])} تومان\\n\"\n            f\"🎁 تخفیف ({persian_numbers(str(int(payment_info['discount_rate'] * 100)))}٪): {format_price(payment_info['discount'])} تومان\\n\"\n            f\"💰 مبلغ پرداختی: {format_price(payment_info['amount'])} تومان\\n\\n\"\n            f\"📸 فیش واریزی دریافت شد\\n\"\n            f\"✅ آماده تایید نهایی سفارش\")\n\n        # Show confirmation button with final invoice\n        keyboard = [[\n            InlineKeyboardButton(\"✅ سفارش را تایید می‌کنم\",\n                                 callback_data=\"confirm_payment_receipt\")\n        ],\n                    [\n                        InlineKeyboardButton(\n                            \"🔄 ارسال عکس جدید\",\n                            callback_data=\"upload_receipt\")\n                    ]]\n\n        await update.message.reply_text(\n            final_invoice, reply_markup=InlineKeyboardMarkup(keyboard))\n\n    async def _handle_remaining_receipt_upload(self, update, user_id):\n        \"\"\"Handle receipt upload for remaining balance payment\"\"\"\n        # Store photo info\n        photo = update.message.photo[-1]  # Get highest resolution photo\n        self.user_sessions[user_id]['receipt_photo'] = {\n            'file_id': photo.file_id,\n            'file_unique_id': photo.file_unique_id\n        }\n\n        # Get remaining payment info\n        remaining_payment = self.user_sessions[user_id]['remaining_payment']\n        order_id = remaining_payment['order_id']\n        amount = remaining_payment['amount']\n\n        # Show confirmation message\n        confirmation_text = (\n            f\"✅ فیش واریز مانده حساب دریافت شد\\n\"\n            f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n            f\"📋 سفارش: {order_id}\\n\"\n            f\"💰 مبلغ واریزی: {format_price(amount)} تومان\\n\\n\"\n            f\"📸 فیش واریزی آماده ارسال به پشتیبانی\\n\"\n            f\"✅ آماده تایید نهایی\"\n        )\n\n        keyboard = [[\n            InlineKeyboardButton(\"✅ تایید و ارسال به پشتیبانی\",\n                                 callback_data=\"confirm_remaining_payment_receipt\")\n        ], [\n            InlineKeyboardButton(\"🔄 ارسال عکس جدید\",\n                                 callback_data=\"upload_remaining_receipt\")\n        ]]\n\n        await update.message.reply_text(\n            confirmation_text, reply_markup=InlineKeyboardMarkup(keyboard))\n\n    async def handle_group_message(self, update: Update,\n                                   context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Handle messages in group chats (support group)\"\"\"\n        chat_id = update.effective_chat.id\n        message_text = update.message.text.strip(\n        ) if update.message.text else \"\"\n        user_name = update.effective_user.first_name or \"کاربر\"\n\n        # Log group info for debugging\n        logger.info(f\"📩 Group message received:\")\n        logger.info(f\"   Chat ID: {chat_id} (type: {type(chat_id)})\")\n        logger.info(\n            f\"   Chat Title: {getattr(update.effective_chat, 'title', 'N/A')}\")\n        logger.info(f\"   Message: '{message_text}'\")\n        logger.info(f\"   User: {user_name}\")\n        logger.info(\n            f\"   Configured group ID: {self.config.order_group_chat_id} (type: {type(self.config.order_group_chat_id)})\"\n        )\n\n        # تبدیل chat_id به int برای مقایسه\n        try:\n            current_group_id = int(chat_id)\n            config_group_id = int(\n                self.config.order_group_chat_id\n            ) if self.config.order_group_chat_id else None\n        except (ValueError, TypeError) as e:\n            logger.error(f\"Error converting chat IDs to int: {e}\")\n            return\n\n        # بررسی اینکه آیا این گروه، گروه مناسب هست یا نه\n        if config_group_id and current_group_id != config_group_id:\n            logger.info(\n                f\"❌ پیام از گروه مختلف: {current_group_id} != {config_group_id}\"\n            )\n            return\n\n        # اگر هیچ group ID تنظیم نشده، این گروه را به عنوان گروه اصلی در نظر بگیر\n        if not config_group_id:\n            logger.warning(\n                f\"⚠️ GROUP_CHAT_ID تنظیم نشده - استفاده از گروه فعلی: {current_group_id}\"\n            )\n            self.config.order_group_chat_id = current_group_id\n\n        logger.info(f\"✅ Processing group message: '{message_text}'\")\n\n        # اگر پیام خالی باشد، نادیده بگیر\n        if not message_text:\n            return\n\n        # فقط پردازش دستورات مشخص - جلوگیری از پردازش پیام‌های عادی\n        message_lower = message_text.lower().strip()\n\n        # لیست دقیق دستورات مجاز\n        valid_commands = [\n            'سفارش', 'سفارشات', 'order', 'orders', 'فاکتور', 'فاکتورها',\n            'invoice', 'invoices', 'آمار', 'stat', 'statistics', 'راهنما',\n            'help', 'کمک', 'دستور', 'ربات', 'bot', '@decoteen_bot'\n        ]\n\n        # بررسی آیا پیام شامل دستور معتبر است یا خیر\n        is_valid_command = False\n        for cmd in valid_commands:\n            if cmd in message_lower:\n                is_valid_command = True\n                break\n\n        # بررسی دستور وضعیت\n        if message_text.startswith('وضعیت ') or message_text.startswith(\n                'status '):\n            is_valid_command = True\n\n        # اگر پیام دستور معتبری نیست، آن را نادیده بگیر\n        if not is_valid_command:\n            logger.debug(f\"🔍 پیام عادی نادیده گرفته شد: '{message_text}'\")\n            return\n\n        try:\n            # پردازش دستورات معتبر\n            if any(word in message_lower\n                   for word in ['سفارش', 'سفارشات', 'order', 'orders']):\n                logger.info(\"🎯 دستور سفارش شناسایی شد\")\n                await self._show_daily_orders(update)\n                return\n            elif any(\n                    word in message_lower\n                    for word in ['فاکتور', 'فاکتورها', 'invoice', 'invoices']):\n                logger.info(\"🎯 دستور فاکتور شناسایی شد\")\n                await self._show_daily_invoices(update)\n                return\n            elif message_text.startswith('وضعیت ') or message_text.startswith(\n                    'status '):\n                order_id = message_text.replace('وضعیت ',\n                                                '').replace('status ',\n                                                            '').strip()\n                logger.info(f\"🎯 درخواست وضعیت سفارش: {order_id}\")\n                await self._show_order_status(update, order_id)\n                return\n            elif any(word in message_lower\n                     for word in ['آمار', 'stat', 'statistics']):\n                logger.info(\"🎯 دستور آمار شناسایی شد\")\n                await self._show_orders_statistics(update)\n                return\n            elif any(word in message_lower\n                     for word in ['راهنما', 'help', 'کمک', 'دستور']):\n                logger.info(\"🎯 دستور راهنما شناسایی شد\")\n                await self._show_group_help(update)\n                return\n            elif message_lower in ['ربات', 'bot', '@decoteen_bot']:\n                logger.info(\"🎯 دستور تست ربات شناسایی شد\")\n                await update.message.reply_text(\n                    \"🤖 ربات DecoTeen آماده خدمات‌رسانی است!\\n\\n\"\n                    \"📋 دستورات موجود:\\n\"\n                    \"• سفارش - نمایش سفارشات امروز\\n\"\n                    \"• فاکتور - نمایش فاکتورهای امروز\\n\"\n                    \"• آمار - نمایش آمار کلی\\n\"\n                    \"• راهنما - نمایش راهنمای کامل\\n\\n\"\n                    f\"🔧 Chat ID این گروه: {current_group_id}\")\n                return\n\n        except Exception as e:\n            logger.error(f\"❌ خطا در پردازش پیام گروه: {e}\")\n            logger.error(\n                f\"Message: '{message_text}', Chat ID: {current_group_id}\")\n\n            # ارسال پیام خطا به گروه\n            try:\n                await update.message.reply_text(\n                    f\"❌ خطا در پردازش دستور: {str(e)[:100]}\\n\"\n                    \"لطفاً دوباره تلاش کنید یا با پشتیبانی تماس بگیرید.\")\n            except Exception as reply_error:\n                logger.error(f\"خطا در ارسال پیام خطا: {reply_error}\")\n\n        return\n\n    async def _show_daily_orders(self, update: Update):\n        \"\"\"Show today's orders as clickable summary with icons\"\"\"\n        try:\n            logger.info(\"🔍 درخواست نمایش سفارشات امروز\")\n\n            # Get today's orders\n            today_orders = await self.order_server.get_todays_orders()\n            logger.info(f\"📊 تعداد سفارشات امروز: {len(today_orders)}\")\n\n            if not today_orders:\n                await update.message.reply_text(\n                    f\"📊 سفارشات امروز ({persian_numbers(datetime.now().strftime('%Y/%m/%d'))})\\n\\n\"\n                    \"هیچ سفارش جدیدی امروز ثبت نشده است. 📋\\n\\n\"\n                    \"💡 برای تست می‌توانید یک سفارش جدید ثبت کنید.\")\n                return\n\n            # Create summary message with clickable icons\n            summary_text = (\n                f\"📊 سفارشات امروز ({persian_numbers(datetime.now().strftime('%Y/%m/%d'))})\\n\"\n                f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n                f\"📦 تعداد کل: {persian_numbers(str(len(today_orders)))}\\n\\n\"\n                f\"🔽 روی هر آیکون کلیک کنید تا فاکتور کامل را ببینید:\\n\\n\")\n\n            # Create inline keyboard with clickable order icons\n            keyboard = []\n            for i, order in enumerate(today_orders, 1):\n                customer = order.get('customer', {})\n                status_icon = \"🆕\" if order.get('status') == 'pending' else \"✅\"\n\n                button_text = f\"{status_icon} {persian_numbers(str(i))} - {customer.get('name', 'نامشخص')[:10]}\"\n                callback_data = f\"order_details_{order['order_id']}\"\n\n                keyboard.append([\n                    InlineKeyboardButton(button_text,\n                                         callback_data=callback_data)\n                ])\n\n            # Add summary row at the bottom\n            keyboard.append([\n                InlineKeyboardButton(\"📈 آمار کلی\",\n                                     callback_data=\"daily_stats\"),\n                InlineKeyboardButton(\"🔄 بروزرسانی\",\n                                     callback_data=\"refresh_daily_orders\")\n            ])\n\n            await update.message.reply_text(\n                summary_text, reply_markup=InlineKeyboardMarkup(keyboard))\n\n            logger.info(\"✅ لیست سفارشات امروز با موفقیت ارسال شد\")\n\n        except Exception as e:\n            logger.error(f\"❌ خطا در نمایش سفارشات روزانه: {e}\")\n            await update.message.reply_text(\n                f\"❌ خطا در نمایش سفارشات روزانه.\\n\"\n                f\"جزئیات: {str(e)[:100]}\\n\"\n                \"لطفاً دوباره تلاش کنید یا با پشتیبانی تماس بگیرید.\")\n\n    async def _show_daily_invoices(self, update: Update):\n        \"\"\"Show today's invoices in the group\"\"\"\n        try:\n            today_orders = await self.order_server.get_todays_orders()\n\n            if not today_orders:\n                await update.message.reply_text(\n                    \"📄 گزارش فاکتورهای امروز\\n\\n\"\n                    \"هیچ فاکتوری امروز صادر نشده است. 📋\")\n                return\n\n            invoice_text = (\n                f\"📄 فاکتورهای امروز ({persian_numbers(datetime.now().strftime('%Y/%m/%d'))})\\n\"\n                f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\\n\")\n\n            for i, order in enumerate(today_orders, 1):\n                customer = order.get('customer', {})\n                pricing = order.get('pricing', {})\n\n                invoice_text += (\n                    f\"{persian_numbers(str(i))}. 📋 {order['order_id']}\\n\"\n                    f\"   👤 {customer.get('name', 'نامشخص')}\\n\"\n                    f\"   🏙️ {customer.get('city', 'نامشخص')}\\n\"\n                    f\"   💰 {format_price(pricing.get('total', 0))} تومان\\n\"\n                    f\"   📊 {self.order_server._get_status_text(order.get('status', 'pending'))}\\n\\n\"\n                )\n\n            # Create action keyboard\n            keyboard = [[\n                InlineKeyboardButton(\"💾 ذخیره گزارش\",\n                                     callback_data=\"save_daily_invoices\"),\n                InlineKeyboardButton(\"📧 ارسال ایمیل\",\n                                     callback_data=\"email_daily_invoices\")\n            ],\n                        [\n                            InlineKeyboardButton(\n                                \"🔄 بروزرسانی\",\n                                callback_data=\"refresh_daily_invoices\")\n                        ]]\n\n            await update.message.reply_text(\n                invoice_text, reply_markup=InlineKeyboardMarkup(keyboard))\n\n        except Exception as e:\n            logger.error(f\"Error showing daily invoices: {e}\")\n            await update.message.reply_text(\n                \"❌ خطا در نمایش فاکتورهای روزانه. لطفاً دوباره تلاش کنید.\")\n\n    async def _show_order_status(self, update: Update, order_id: str):\n        \"\"\"Show specific order status\"\"\"\n        try:\n            order_data = await self.order_server.get_order_details(order_id)\n\n            if not order_data:\n                await update.message.reply_text(\n                    f\"❌ سفارش {order_id} یافت نشد.\\n\"\n                    \"لطفاً شماره سفارش را بررسی کنید.\")\n                return\n\n            status_text = self.order_server._get_status_text(\n                order_data['status'])\n            customer = order_data.get('customer', {})\n            pricing = order_data.get('pricing', {})\n\n            order_info = (\n                f\"📋 وضعیت سفارش: {order_id}\\n\"\n                f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n                f\"👤 مشتری: {customer.get('name', 'نامشخص')}\\n\"\n                f\"🏙️ شهر: {customer.get('city', 'نامشخص')}\\n\"\n                f\"📊 وضعیت فعلی: {status_text}\\n\"\n                f\"💰 مبلغ کل: {format_price(pricing.get('total', 0))} تومان\\n\"\n                f\"⏰ تاریخ ثبت: {persian_numbers(order_data.get('created_at', '')[:10])}\\n\"\n            )\n\n            # Create management keyboard\n            keyboard = self.order_server._create_admin_buttons(\n                order_id, order_data['user_id'])\n\n            await update.message.reply_text(\n                order_info, reply_markup=InlineKeyboardMarkup(keyboard))\n\n        except Exception as e:\n            logger.error(f\"Error showing order status: {e}\")\n            await update.message.reply_text(\n                \"❌ خطا در نمایش وضعیت سفارش. لطفاً دوباره تلاش کنید.\")\n\n    async def _show_orders_statistics(self, update: Update):\n        \"\"\"Show orders statistics in the group\"\"\"\n        try:\n            stats = await self.order_server.get_orders_statistics()\n\n            if not stats:\n                await update.message.reply_text(\"📊 آمار سفارشات در دسترس نیست.\"\n                                                )\n                return\n\n            stats_text = (\n                f\"📊 آمار کلی سفارشات\\n\"\n                f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n                f\"📦 کل سفارشات: {persian_numbers(str(stats.get('total_orders', 0)))}\\n\"\n                f\"🆕 سفارشات امروز: {persian_numbers(str(stats.get('today_orders', 0)))}\\n\"\n                f\"💰 درآمد کل: {format_price(stats.get('total_revenue', 0))} تومان\\n\"\n                f\"💳 درآمد امروز: {format_price(stats.get('today_revenue', 0))} تومان\\n\\n\"\n                f\"📈 توزیع وضعیت:\\n\")\n\n            for status, count in stats.get('status_distribution', {}).items():\n                stats_text += f\"• {status}: {persian_numbers(str(count))}\\n\"\n\n            await update.message.reply_text(stats_text)\n\n        except Exception as e:\n            logger.error(f\"Error showing statistics: {e}\")\n            await update.message.reply_text(\n                \"❌ خطا در نمایش آمار. لطفاً دوباره تلاش کنید.\")\n\n    async def _show_group_help(self, update: Update):\n        \"\"\"Show help commands for group\"\"\"\n        help_text = (\"🤖 راهنمای دستورات گروه\\n\"\n                     \"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n                     \"📋 سفارش / سفارشات - نمایش سفارشات امروز\\n\"\n                     \"📄 فاکتور / فاکتورها - نمایش فاکتورهای امروز\\n\"\n                     \"📊 آمار - نمایش آمار کلی\\n\"\n                     \"🔍 وضعیت [شماره سفارش] - بررسی وضعیت سفارش\\n\"\n                     \"❓ راهنما / کمک - نمایش این راهنما\\n\\n\"\n                     \"💡 نکته: فقط در گروه پشتیبانی فعال است\")\n\n        await update.message.reply_text(help_text)\n\n    async def _send_order_invoice_card(self, update: Update, order: Dict):\n        \"\"\"Send order as invoice card with management buttons\"\"\"\n        try:\n            customer = order.get('customer', {})\n            pricing = order.get('pricing', {})\n            cart_items = order.get('cart_items', [])\n\n            # Create invoice card\n            invoice_card = (\n                f\"🧾 فاکتور - {order['order_id']}\\n\"\n                f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n                f\"👤 {customer.get('name', 'نامشخص')}\\n\"\n                f\"🏙️ {customer.get('city', 'نامشخص')}\\n\"\n                f\"🆔 کد نمایندگی: {customer.get('customer_id', 'نامشخص')}\\n\"\n                f\"📱 شناسه کاربر: {order.get('user_id', 'نامشخص')}\\n\"\n                f\"⏰ {persian_numbers(order.get('created_at', '')[:16].replace('T', ' - '))}\\n\\n\"\n                f\"📦 آیتم‌ها:\\n\")\n\n            # Add cart items\n            for i, item in enumerate(cart_items, 1):\n                item_total = item.get('price', 0) * item.get('quantity', 0)\n                invoice_card += (\n                    f\"{persian_numbers(str(i))}. {item.get('product_name', 'محصول')}\\n\"\n                    f\"   📏 {item.get('size', 'نامشخص')} | \"\n                    f\"📦 {persian_numbers(str(item.get('quantity', 0)))} عدد | \"\n                    f\"💰 {format_price(item_total)}\\n\")\n\n            # Add pricing\n            invoice_card += (\n                f\"\\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n                f\"💳 {order.get('payment_method', 'نقدی')}\\n\"\n                f\"💰 مبلغ کل: {format_price(pricing.get('total', 0))} تومان\\n\"\n                f\"📊 {self.order_server._get_status_text(order.get('status', 'pending'))}\"\n            )\n\n            # Create management keyboard\n            keyboard = [[\n                InlineKeyboardButton(\n                    \"📞 تماس\",\n                    callback_data=f\"order_status_{order['order_id']}_contacted\"\n                ),\n                InlineKeyboardButton(\n                    \"✅ تایید\",\n                    callback_data=f\"order_status_{order['order_id']}_confirmed\"\n                ),\n                InlineKeyboardButton(\n                    \"📦 آماده\",\n                    callback_data=f\"order_status_{order['order_id']}_ready\")\n            ],\n                        [\n                            InlineKeyboardButton(\n                                \"🚚 ارسال\",\n                                callback_data=\n                                f\"order_status_{order['order_id']}_shipped\"),\n                            InlineKeyboardButton(\n                                \"🎉 تکمیل\",\n                                callback_data=\n                                f\"order_status_{order['order_id']}_completed\"),\n                            InlineKeyboardButton(\n                                \"❌ لغو\",\n                                callback_data=\n                                f\"order_status_{order['order_id']}_cancelled\")\n                        ]]\n\n            await update.message.reply_text(\n                invoice_card, reply_markup=InlineKeyboardMarkup(keyboard))\n\n        except Exception as e:\n            logger.error(f\"Error sending order invoice card: {e}\")\n\n    async def _send_order_summary_with_buttons(self, update: Update,\n                                               order: Dict):\n        \"\"\"Send order summary with management buttons (kept for compatibility)\"\"\"\n        await self._send_order_invoice_card(update, order)\n\n    async def _handle_authentication_request(self, query):\n        \"\"\"Handle authentication request\"\"\"\n        user_id = query.from_user.id\n\n        # Set user state to awaiting customer code\n        if user_id not in self.user_sessions:\n            self.user_sessions[user_id] = {}\n        self.user_sessions[user_id]['awaiting_customer_code'] = True\n\n        text = (\"🔐 احراز هویت \\n\\n\"\n                \" لطفاً کد نمایندگی خود را وارد کنید:\")\n        await query.edit_message_text(text)\n\n    async def _handle_customer_code_input(self, update, customer_code):\n        \"\"\"Handle customer code input\"\"\"\n        user_id = update.effective_user.id\n\n        # Validate customer code\n        customer = self.customer_service.authenticate_customer(customer_code)\n\n        if customer:\n            # Authentication successful\n            self.user_sessions[user_id] = {\n                'authenticated': True,\n                'customer': customer,\n                'awaiting_customer_code': False\n            }\n\n            welcome_text = (f\"✅ خوش آمدید {customer['name']} عزیز!\\n\"\n                            f\"🏙️ شهر: {customer['city']}\\n\"\n                            f\"🆔 کد نمایندگی: {customer['customer_id']}\\n\\n\"\n                            \"\\n\"\n                            \"جهت سفارش محصول مورد نظر خودرا انتخاب نمایید:\")\n\n            keyboard = self.keyboards.get_categories_keyboard()\n            await update.message.reply_text(welcome_text,\n                                            reply_markup=keyboard)\n        else:\n            # Authentication failed\n            error_text = (\"❌ کد نمایندگی نامعتبر است.\\n\"\n                          \"لطفاً کد نمایندگی صحیح خود را وارد کنید:\")\n            await update.message.reply_text(error_text)\n\n    async def _handle_main_menu(self, query):\n        \"\"\"Handle main menu\"\"\"\n        user_id = query.from_user.id\n        authenticated = self._is_authenticated(user_id)\n\n        if authenticated:\n            customer = self.user_sessions[user_id]['customer']\n            text = (f\"🏠 منوی اصلی\\n\\n\"\n                    f\"👤 {customer['name']}\\n\"\n                    f\"🏙️ {customer['city']}\\n\\n\"\n                    \"یکی از گزینه‌های زیر را انتخاب کنید:\")\n        else:\n            text = \"🏠 منوی اصلی\\n\\nبرای شروع خرید، ابتدا احراز هویت کنید.\"\n\n        keyboard = self.keyboards.get_main_menu(authenticated)\n        await query.edit_message_text(text, reply_markup=keyboard)\n\n    async def _handle_start_shopping(self, query):\n        \"\"\"Handle start shopping\"\"\"\n        user_id = query.from_user.id\n\n        if not self._is_authenticated(user_id):\n            await query.edit_message_text(\"ابتدا باید احراز هویت کنید.\")\n            return\n\n        text = (\"عالیه \\n\\n\"\n                \"جهت سفارش محصول موردنطر خودرا انتخاب کنین:\")\n\n        keyboard = self.keyboards.get_categories_keyboard()\n        await query.edit_message_text(text, reply_markup=keyboard)\n\n    async def _handle_view_cart(self, query):\n        \"\"\"Handle view cart\"\"\"\n        user_id = query.from_user.id\n\n        if not self._is_authenticated(user_id):\n            await query.edit_message_text(\"ابتدا باید احراز هویت کنید.\")\n            return\n\n        cart_items = self.cart_manager.get_cart(user_id)\n\n        if not cart_items:\n            text = \"🛍️ سبد خرید شما خالی است.\"\n            keyboard = self.keyboards.get_main_menu(authenticated=True)\n        else:\n            text = \"🛍️ سبد خرید شما:\\n\\n\"\n            total = 0\n\n            for i, item in enumerate(cart_items, 1):\n                item_total = item['price'] * item['quantity']\n                total += item_total\n                text += (\n                    f\"{persian_numbers(str(i))}. {item['product_name']}\\n\"\n                    f\"   📏 سایز: {item['size']}\\n\"\n                    f\"   📦 تعداد: {persian_numbers(str(item['quantity']))}\\n\"\n                    f\"   💰 قیمت: {format_price(item_total)} تومان\\n\\n\")\n\n            text += f\"💰 مجموع: {format_price(total)} تومان\"\n            keyboard = self.keyboards.get_cart_management_keyboard()\n\n        await query.edit_message_text(text, reply_markup=keyboard)\n\n    async def _handle_view_invoice(self, query):\n        \"\"\"Handle view invoice\"\"\"\n        user_id = query.from_user.id\n\n        if not self._is_authenticated(user_id):\n            await query.edit_message_text(\"ابتدا باید احراز هویت کنید.\")\n            return\n\n        cart_items = self.cart_manager.get_cart(user_id)\n        customer = self.user_sessions[user_id]['customer']\n\n        invoice_text = self.pricing_manager.generate_invoice(\n            cart_items, customer)\n        keyboard = self.keyboards.get_payment_keyboard()\n\n        await query.edit_message_text(invoice_text, reply_markup=keyboard)\n\n    async def _handle_category_selection(self, query, data):\n        \"\"\"Handle category selection\"\"\"\n        category = data.replace(\"category_\", \"\")\n        user_id = query.from_user.id\n\n        # Store selected category in session\n        if user_id not in self.user_sessions:\n            self.user_sessions[user_id] = {}\n        self.user_sessions[user_id]['selected_category'] = category\n\n        category_info = get_category_info(category)\n        category_name = category_info.get('name', category)\n\n        if category == \"curtain_only\":\n            # For curtain_only, show products directly with icon-based keyboard\n            text = f\"{category_name}\\n\\nعالیه! حالا بگو کدوم طرح؟\"\n            keyboard = self.keyboards.get_curtain_subcategories()\n        elif category == \"tablecloth\":\n            # For tablecloth, show subcategories first\n            keyboard = self.keyboards.get_tablecloth_subcategories()\n            await query.edit_message_text(\"انتخاب فرشینه:\",\n                                          reply_markup=keyboard)\n            return\n        elif category == \"baby\":\n            # Baby category with pagination\n            text = f\"{category_name}\\n\\nعالیه! حالا بگو کدوم طرح؟\"\n            keyboard = self.keyboards.get_baby_subcategories()\n        elif category == \"cushion\":\n            # Cushion category with pagination\n            text = f\"{category_name}\\n\\nعالیه! حالا بگو کدوم طرح؟\"\n            keyboard = self.keyboards.get_cushion_subcategories()\n        else:\n            # For other categories, show products directly with icon-based keyboard\n            text = f\"{category_name}\\n\\nعالیه! حالا بگو کدوم طرح؟\"\n            keyboard = self.keyboards.get_category_products_keyboard(category)\n\n        await query.edit_message_text(text, reply_markup=keyboard)\n\n    async def _handle_subcategory_selection(self, query, data):\n        \"\"\"Handle subcategory selection\"\"\"\n        subcategory = data.replace(\"subcategory_\", \"\")\n        user_id = query.from_user.id\n\n        # Store selected subcategory in session\n        if user_id not in self.user_sessions:\n            self.user_sessions[user_id] = {}\n        self.user_sessions[user_id]['selected_subcategory'] = subcategory\n\n        text = f\"🔤 جستجوی حروف الفبایی\\n\\nحرف اول نام محصول مورد نظر را انتخاب کنید:\"\n        keyboard = self.keyboards.get_alphabetical_keyboard(subcategory)\n        await query.edit_message_text(text, reply_markup=keyboard)\n\n    async def _handle_alphabet_selection(self, query, data):\n        \"\"\"Handle alphabet selection\"\"\"\n        parts = data.split(\"_\")\n        if len(parts) < 3:\n            await query.edit_message_text(\"❌ داده نامعتبر.\")\n            return\n        category = parts[1]\n        letter = parts[2]\n        user_id = query.from_user.id\n\n        # Get products starting with selected letter\n        subcategory = self.user_sessions[user_id].get('selected_subcategory')\n        actual_category = subcategory if subcategory else category\n\n        products = search_products_by_name(category, letter, subcategory)\n\n        if not products:\n            text = f\"❌ محصولی با حرف «{letter}» یافت نشد.\\n\\nحرف دیگری را انتخاب کنید:\"\n            keyboard = self.keyboards.get_alphabetical_keyboard(\n                actual_category)\n        else:\n            text = f\"📦 محصولات با حرف «{letter}»:\\n\\nیکی را انتخاب کنید:\"\n            keyboard = self.keyboards.get_products_keyboard(products, category)\n\n            # Store filtered products in session\n            self.user_sessions[user_id]['filtered_products'] = products\n\n        await query.edit_message_text(text, reply_markup=keyboard)\n\n    async def _handle_product_selection(self, query, data):\n        \"\"\"Handle product selection\"\"\"\n        product_id = data.replace(\"product_\", \"\")\n        user_id = query.from_user.id\n\n        # Find product by ID\n        product = get_product_by_id(product_id)\n\n        if not product:\n            await query.edit_message_text(\"❌ محصول یافت نشد.\")\n            return\n\n        # Store selected product in session\n        self.user_sessions[user_id]['selected_product'] = product\n\n        # Get price based on product (check for special pricing first)\n        category = product.get('category_id', 'baby')\n\n        # For curtains, show sewing type selection first\n        if category == 'curtain_only':\n            # Check if it's the special bedside curtain\n            if product_id == 'curtain_15':  # پرده حریر سرتخت (جفت)\n                price = get_product_price(product['id'], category)\n                text = (f\"📦 {product['name']}\\n\"\n                        f\"💰 قیمت: {format_price(price)} تومان\\n\\n\"\n                        \"عالیه! انتخابت\\n\"\n                        \"ارتفاع: 240 و عرض 2×290 هست که قابل تغییر نیست\")\n                self.user_sessions[user_id]['selected_fabric'] = 'special'\n                self.user_sessions[user_id]['selected_category'] = category\n                self.user_sessions[user_id][\n                    'selected_size'] = 'ارتفاع: 240 - عرض: 2×290'\n\n                keyboard = [[\n                    InlineKeyboardButton(\"بله همین محصول رو میخوام\",\n                                         callback_data=\"qty_1\")\n                ]]\n                keyboard.append([\n                    InlineKeyboardButton(\"🔙 بازگشت\",\n                                         callback_data=\"back_to_categories\")\n                ])\n                keyboard = InlineKeyboardMarkup(keyboard)\n            else:\n                text = (f\"📦 {product['name']}\\n\\n\"\n                        \"عالیه چه نوع دوختی مد نظرته؟\")\n                keyboard = self.keyboards.get_sewing_type_keyboard()\n        # For tablecloth, show base price initially\n        elif category == 'tablecloth':\n            price = PRODUCT_PRICES[category]  # Show base price\n            text = (f\"📦 {product['name']}\\n\"\n                    f\"💰 قیمت: از {format_price(price)} تومان\\n\\n\"\n                    \"سایز مورد نظر را انتخاب کنید:\")\n            # Store category for size selection\n            self.user_sessions[user_id]['selected_category'] = category\n            keyboard = self.keyboards.get_size_selection_keyboard(category)\n        # For cushions, skip size selection and go directly to quantity\n        elif category == 'cushion':\n            price = get_product_price(product['id'], category)\n            # Store default size for cushions\n            self.user_sessions[user_id]['selected_size'] = 'استاندارد'\n            self.user_sessions[user_id]['selected_category'] = category\n\n            text = (f\" {product['name']}\\n\"\n                    f\" قیمت: {format_price(price)} تومان\\n\\n\"\n                    \"تعداد مورد نظر را انتخاب کنید:\")\n            keyboard = self.keyboards.get_quantity_keyboard()\n        else:\n            price = get_product_price(product['id'], category)\n            text = (f\"📦 {product['name']}\\n\"\n                    f\" قیمت: {format_price(price)} تومان\\n\\n\"\n                    \"سایز مورد نظر را انتخاب کنید:\")\n            keyboard = self.keyboards.get_size_selection_keyboard(category)\n\n        await query.edit_message_text(text, reply_markup=keyboard)\n\n    async def _handle_size_selection_from_category(self, query, data):\n        \"\"\"Handle size selection directly from category\"\"\"\n        category = data.replace(\"size_selection_\", \"\")\n        user_id = query.from_user.id\n\n        # Store selected category in session\n        if user_id not in self.user_sessions:\n            self.user_sessions[user_id] = {}\n        self.user_sessions[user_id]['selected_category'] = category\n\n        category_info = get_category_info(category)\n        category_name = category_info.get('name', category)\n        price = category_info.get('price', 4780000)\n\n        if category == 'tablecloth':\n            text = (f\"{category_name}\\n\\n\"\n                    f\" قیمت: از {format_price(price)} تومان\\n\\n\"\n                    \"چه انتخاب خوبی! حالا سایز تشک چقدر باشه؟\")\n        else:\n            text = (f\"{category_name}\\n\\n\"\n                    f\" قیمت: {format_price(price)} تومان\\n\\n\"\n                    \"چه انتخاب خوبی! حالا سایز تشک چقدر باشه؟\")\n\n        # Use the keyboard's size selection method instead of hardcoded sizes\n        keyboard = self.keyboards.get_size_selection_keyboard(category)\n        await query.edit_message_text(text, reply_markup=keyboard)\n\n    async def _handle_size_selection(self, query, data):\n        \"\"\"Handle size selection\"\"\"\n        try:\n            parts = data.split(\"_\")\n            if len(parts) >= 3:\n                size = \"_\".join(parts[1:-1])  # All parts except first and last\n                category = parts[-1]  # Last part is category\n            else:\n                size = data.replace(\"size_\", \"\")\n                category = self.user_sessions.get(query.from_user.id,\n                                                  {}).get('selected_category',\n                                                          'baby')\n\n            user_id = query.from_user.id\n\n            # Ensure user session exists\n            if user_id not in self.user_sessions:\n                self.user_sessions[user_id] = {}\n\n            # Store selected size and category in session\n            self.user_sessions[user_id]['selected_size'] = size\n            self.user_sessions[user_id]['selected_category'] = category\n\n            # Get category info for price\n            category_info = get_category_info(category)\n\n            # For tablecloth, get size-based price\n            if category == 'tablecloth':\n                price = get_product_price('', category, size)\n            else:\n                price = category_info.get('price', 4780000)\n\n            text = (f\"📏 سایز انتخابی: {size}\\n\"\n                    f\"💰 قیمت: {format_price(price)} تومان\\n\\n\"\n                    \"طرح قشنگی انتخاب کردی! حالا تعداد چقدر باشه؟\")\n            keyboard = self.keyboards.get_quantity_keyboard()\n\n            await query.edit_message_text(text, reply_markup=keyboard)\n            logger.info(f\"Size selected: {size} for category {category} by user {user_id}\")\n            \n        except Exception as e:\n            logger.error(f\"Error in size selection: {e}\")\n            await query.edit_message_text(\n                \"❌ خطا در انتخاب سایز. لطفاً دوباره تلاش کنید.\",\n                reply_markup=self.keyboards.get_main_menu(self._is_authenticated(user_id))\n            )\n\n    async def _handle_quantity_selection(self, query, data):\n        \"\"\"Handle quantity selection\"\"\"\n        quantity = int(data.replace(\"qty_\", \"\"))\n        user_id = query.from_user.id\n\n        # Get session data\n        session = self.user_sessions[user_id]\n        size = session.get('selected_size')\n        category = session.get('selected_category', 'baby')\n        fabric = session.get('selected_fabric')\n\n        # Check if we have a specific product or just category\n        if 'selected_product' in session:\n            # Product-based ordering\n            product = session['selected_product']\n            category = product.get('category_id', category)\n            product_name = product['name']\n            product_id = product['id']\n        else:\n            # Category-based ordering (for teen and adult)\n            category_info = get_category_info(category)\n            product_name = category_info.get('name', category)\n            product_id = f\"{category}_generic\"\n\n        # Get price based on product and fabric\n        if category == 'tablecloth':\n            price = get_product_price(product_id, category, size)\n        elif category == 'curtain_only' and fabric:\n            if fabric == 'special':  # For bedside curtain\n                price = get_product_price(product['id'], category)\n            else:\n                price = get_product_price(product_id, category, fabric=fabric)\n        else:\n            price = get_product_price(product['id'], category)\n\n        # Add fabric and sewing type info to product name if applicable\n        if fabric and fabric != 'special':\n            fabric_name = \"حریر کتان\" if fabric == \"silk_cotton\" else \"مخمل\"\n            product_name = f\"{product_name} - {fabric_name}\"\n\n            # Add sewing type if available\n            sewing_type = session.get('selected_sewing_type')\n            if sewing_type:\n                sewing_type_name = \"پانچ\" if sewing_type == \"panch\" else \"نواردوزی\"\n                product_name = f\"{product_name} - {sewing_type_name}\"\n\n        # Add to cart\n        cart_item = {\n            'product_id': product_id,\n            'product_name': product_name,\n            'size': size,\n            'quantity': quantity,\n            'price': price\n        }\n\n        self.cart_manager.add_to_cart(user_id, cart_item)\n\n        total_price = price * quantity\n        text = (f\"✅ محصول به سبد خرید اضافه شد!\\n\\n\"\n                f\" {product_name}\\n\"\n                f\" سایز: {size}\\n\"\n                f\" تعداد: {persian_numbers(str(quantity))}\\n\"\n                f\" قیمت کل: {format_price(total_price)} تومان\\n\\n\"\n                \"می‌خواهید چه کار کنید؟\")\n\n        keyboard = self.keyboards.get_cart_management_keyboard()\n        await query.edit_message_text(text, reply_markup=keyboard)\n\n    async def _handle_payment_selection(self, query, data):\n        \"\"\"Handle payment selection - now shows payment type selection\"\"\"\n        user_id = query.from_user.id\n\n        # Check authentication\n        if not self._is_authenticated(user_id):\n            await query.edit_message_text(\n                \"❌ ابتدا باید احراز هویت کنید.\",\n                reply_markup=self.keyboards.get_main_menu(authenticated=False))\n            return\n\n        cart_items = self.cart_manager.get_cart(user_id)\n        if not cart_items:\n            await query.edit_message_text(\n                \"❌ سبد خرید شما خالی است.\",\n                reply_markup=self.keyboards.get_main_menu(authenticated=True))\n            return\n\n        customer = self.user_sessions[user_id]['customer']\n\n        # Extract payment method from callback data\n        payment_method = data.replace(\"payment_\", \"\").replace(\"_card\", \"\")\n        \n        # Store payment method in session\n        self.user_sessions[user_id]['selected_payment_method'] = payment_method\n        \n        # Calculate amounts for display\n        subtotal = self.pricing_manager.calculate_subtotal(cart_items)\n        if payment_method == \"cash\":\n            discount_rate = 0.30\n            payment_text = \"پرداخت نقدی (۳۰٪ تخفیف)\"\n        elif payment_method == \"60day\":\n            discount_rate = 0.25\n            payment_text = \"پرداخت ۶۰ روز (۲۵٪ تخفیف)\"\n        elif payment_method == \"90day\":\n            discount_rate = 0.25\n            payment_text = \"پرداخت ۹۰ روز (۲۵٪ تخفیف + ۲۵٪ پیش‌پرداخت)\"\n        else:\n            discount_rate = 0\n            payment_text = \"پرداخت\"\n\n        discount = self.pricing_manager.calculate_discount(subtotal, discount_rate)\n        final_amount = subtotal - discount\n        \n        if payment_method == \"90day\":\n            advance_amount = final_amount * 0.25\n            amount_text = f\" مبلغ پیش‌پرداخت (۲۵٪): {format_price(advance_amount)} تومان\\n مبلغ نهایی: {format_price(final_amount)} تومان\"\n        else:\n            amount_text = f\" مبلغ نهایی: {format_price(final_amount)} تومان\"\n\n        text = (f\"✅ {payment_text}\\n\\n\"\n                f\"{amount_text}\\n\\n\"\n                \"نوع پرداخت خود را انتخاب کنید:\")\n\n        keyboard = self.keyboards.get_payment_type_keyboard(payment_method)\n        await query.edit_message_text(text, reply_markup=keyboard)\n\n    async def _handle_payment_type_selection(self, query, data):\n        \"\"\"Handle payment type selection (Cash vs Check)\"\"\"\n        user_id = query.from_user.id\n        \n        # Parse callback data: payment_type_cash_method or payment_type_check_method\n        parts = data.split(\"_\")\n        if len(parts) < 4:\n            await query.edit_message_text(\"❌ داده نامعتبر.\")\n            return\n            \n        payment_type = parts[2]  # cash or check\n        payment_method = parts[3]  # cash, 60day, 90day\n        \n        # Store payment details in session\n        self.user_sessions[user_id]['payment_type'] = payment_type\n        self.user_sessions[user_id]['selected_payment_method'] = payment_method\n        \n        cart_items = self.cart_manager.get_cart(user_id)\n        customer = self.user_sessions[user_id]['customer']\n        \n        # Calculate amounts\n        subtotal = self.pricing_manager.calculate_subtotal(cart_items)\n        if payment_method == \"cash\":\n            discount_rate = 0.30\n        elif payment_method in [\"60day\", \"90day\"]:\n            discount_rate = 0.25\n        else:\n            discount_rate = 0\n            \n        discount = self.pricing_manager.calculate_discount(subtotal, discount_rate)\n        final_amount = subtotal - discount\n        \n        if payment_type == \"cash\":\n            await self._handle_cash_payment_flow(query, payment_method, final_amount)\n        elif payment_type == \"check\":\n            await self._handle_check_payment_flow(query, payment_method, final_amount)\n\n    async def _handle_cash_payment_flow(self, query, payment_method, final_amount):\n        \"\"\"Handle cash payment flow\"\"\"\n        user_id = query.from_user.id\n        \n        if payment_method == \"90day\":\n            advance_amount = final_amount * 0.25\n            amount_text = f\" مبلغ پیش‌پرداخت (۲۵٪): {format_price(advance_amount)} تومان\"\n            payment_amount = advance_amount\n        else:\n            amount_text = f\" مبلغ نهایی: {format_price(final_amount)} تومان\"\n            payment_amount = final_amount\n            \n        # Store payment info for receipt processing\n        self.user_sessions[user_id]['payment_info'] = {\n            'payment_method': f\"پرداخت نقدی - {payment_method}\",\n            'amount': payment_amount,\n            'subtotal': self.pricing_manager.calculate_subtotal(self.cart_manager.get_cart(user_id)),\n            'discount_rate': 0.30 if payment_method == \"cash\" else 0.25,\n            'discount': self.pricing_manager.calculate_subtotal(self.cart_manager.get_cart(user_id)) - final_amount,\n            'awaiting_receipt': True\n        }\n        \n        # Show bank information and request receipt\n        bank_info = self.pricing_manager.bank_info\n        text = (f\" پرداخت نقدی\\n\\n\"\n                f\"{amount_text}\\n\\n\"\n                f\"💳 اطلاعات حساب:\\n\"\n                f\"🏦 کارت: {bank_info['card_number']}\\n\"\n                f\"🏦 شبا: {bank_info['sheba_number']}\\n\"\n                f\"👤 {bank_info['account_holder']}\\n\\n\"\n                f\"لطفاً پس از واریز، فیش واریزی خود را ارسال کنید:\")\n        \n        keyboard = self.keyboards.get_cash_payment_keyboard()\n        await query.edit_message_text(text, reply_markup=keyboard)\n\n    async def _handle_check_payment_flow(self, query, payment_method, final_amount):\n        \"\"\"Handle check payment flow with admin recipient selection system\"\"\"\n        user_id = query.from_user.id\n        \n        if payment_method == \"90day\":\n            advance_amount = final_amount * 0.25\n            amount_text = f\" مبلغ پیش‌پرداخت چک (۲۵٪): {format_price(advance_amount)} تومان\\n مبلغ نهایی: {format_price(final_amount)} تومان\"\n            payment_amount = advance_amount\n        else:\n            amount_text = f\" مبلغ نهایی چک: {format_price(final_amount)} تومان\"\n            payment_amount = final_amount\n            \n        # Store check payment info\n        self.user_sessions[user_id]['check_payment_info'] = {\n            'payment_method': f\"پرداخت چکی - {payment_method}\",\n            'amount': payment_amount,\n            'final_amount': final_amount,\n            'awaiting_check_photo': True\n        }\n        \n        text = (f\"📄 پرداخت چکی\\n\\n\"\n                f\"{amount_text}\\n\\n\"\n                f\"📝 راهنمای پرداخت چکی:\\n\"\n                f\"لطفا عکس چک را ارسال کنین تا تیم پشتیبانی جهت ثبت چک به اسم و کد ملی مد نظر مجموعه بهتون پیام بدن\")\n        \n        keyboard = self.keyboards.get_check_payment_keyboard()\n        await query.edit_message_text(text, reply_markup=keyboard)\n\n    async def _handle_upload_check_photo_request(self, query):\n        \"\"\"Handle request to upload check photo\"\"\"\n        user_id = query.from_user.id\n        \n        # Set awaiting check photo flag\n        if user_id not in self.user_sessions:\n            self.user_sessions[user_id] = {}\n        self.user_sessions[user_id]['awaiting_check_photo'] = True\n        \n        text = \"📸 لطفاً عکس چک خود را ارسال کنید:\"\n        await query.edit_message_text(text)\n\n    async def _handle_check_follow_up(self, query):\n        \"\"\"Handle check follow up status\"\"\"\n        user_id = query.from_user.id\n        \n        # This button will be used when admin sends status updates\n        text = (\"📞 در حال پیگیری\\n\\n\"\n                \"سفارش شما در حال پیگیری است. به زودی پاسخ دریافت خواهید کرد.\")\n        \n        keyboard = self.keyboards.get_check_payment_keyboard()\n        await query.edit_message_text(text, reply_markup=keyboard)\n\n    async def _handle_confirm_check_submission(self, query):\n        \"\"\"Handle check submission confirmation\"\"\"\n        user_id = query.from_user.id\n        \n        # Get check payment info and send final invoice to support group\n        check_info = self.user_sessions[user_id].get('check_payment_info', {})\n        customer = self.user_sessions[user_id]['customer']\n        cart_items = self.cart_manager.get_cart(user_id)\n        check_photo = self.user_sessions[user_id].get('check_photo')\n        \n        if not check_photo:\n            await query.edit_message_text(\"❌ لطفاً ابتدا عکس چک را ارسال کنید.\")\n            return\n            \n        # Generate final order with check information\n        await self._submit_check_order_to_support(user_id, check_info, customer, cart_items, check_photo)\n        \n        # Clear cart and session data\n        self.cart_manager.clear_cart(user_id)\n        if user_id in self.user_sessions:\n            self.user_sessions[user_id].pop('check_payment_info', None)\n            self.user_sessions[user_id].pop('check_photo', None)\n            self.user_sessions[user_id].pop('awaiting_check_photo', None)\n        \n        text = (\"✅ سفارش شما با موفقیت ثبت شد!\\n\\n\"\n                \"📄 چک شما به همراه فاکتور نهایی برای تیم پشتیبانی ارسال شد.\\n\"\n                \"🕐 چک باید طی ۱۰ روز کاری به کارخانه ارسال شود.\\n\\n\"\n                \"🙏 از اعتماد شما متشکریم!\")\n                \n        keyboard = self.keyboards.get_main_menu(authenticated=True)\n        await query.edit_message_text(text, reply_markup=keyboard)\n\n    async def _handle_check_photo_upload(self, update, user_id):\n        \"\"\"Handle check photo upload\"\"\"\n        # Store photo info\n        photo = update.message.photo[-1]  # Get highest resolution photo\n        self.user_sessions[user_id]['check_photo'] = {\n            'file_id': photo.file_id,\n            'file_unique_id': photo.file_unique_id\n        }\n        \n        # Clear the awaiting flag\n        self.user_sessions[user_id]['awaiting_check_photo'] = False\n        \n        # Send to support group for admin review\n        await self._send_check_to_support_for_review(user_id, photo)\n        \n        text = (\"✅ عکس چک دریافت شد!\\n\\n\"\n                \"📤 عکس چک شما برای تیم پشتیبانی ارسال شد.\\n\"\n                \"📞 به زودی تیم پشتیبانی با شما تماس گرفته و اطلاعات کد ملی مورد نیاز را پیام خواهند داد.\\n\\n\"\n                \"از دکمه «در حال پیگیری» برای دریافت وضعیت استفاده کنید:\")\n        \n        keyboard = self.keyboards.get_check_payment_keyboard()\n        await update.message.reply_text(text, reply_markup=keyboard)\n\n    async def _send_check_to_support_for_review(self, user_id, photo):\n        \"\"\"Send check photo to support group for admin review\"\"\"\n        try:\n            customer = self.user_sessions[user_id]['customer']\n            check_info = self.user_sessions[user_id].get('check_payment_info', {})\n            \n            # Create message for support group\n            support_text = (f\"📄 چک جدید دریافت شد\\n\"\n                           f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n                           f\"👤 مشتری: {customer['name']}\\n\"\n                           f\"🏙️ شهر: {customer['city']}\\n\"\n                           f\"🆔 کد نمایندگی: {customer['customer_id']}\\n\"\n                           f\"📱 شناسه کاربر: {user_id}\\n\"\n                           f\"💰 مبلغ: {format_price(check_info.get('amount', 0))} تومان\\n\"\n                           f\"💳 روش: {check_info.get('payment_method', 'نامشخص')}\\n\\n\"\n                           f\"📝 لطفاً کد ملی مورد نیاز را برای مشتری ارسال کنید\")\n            \n            # Create admin buttons with specific recipients (no customer confirmation button)\n            keyboard = [\n                [InlineKeyboardButton(\" خانم فرانک غریبی\", \n                                   callback_data=f\"check_recipient_farank_{user_id}\")],\n                [InlineKeyboardButton(\" نیما کریمی\", \n                                   callback_data=f\"check_recipient_nima_{user_id}\")],\n                [InlineKeyboardButton(\" مجید ترابیان\", \n                                   callback_data=f\"check_recipient_majid_{user_id}\")],\n                [InlineKeyboardButton(\" وحید ترابیان\", \n                                   callback_data=f\"check_recipient_vahid_{user_id}\")]\n            ]\n            \n            # Send to support group\n            if self.config.order_group_chat_id:\n                await self.bot.send_photo(\n                    chat_id=self.config.order_group_chat_id,\n                    photo=photo.file_id,\n                    caption=support_text,\n                    reply_markup=InlineKeyboardMarkup(keyboard)\n                )\n                logger.info(f\"Check photo sent to support group for user {user_id}\")\n            \n        except Exception as e:\n            logger.error(f\"Error sending check to support group: {e}\")\n\n    async def _submit_check_order_to_support(self, user_id, check_info, customer, cart_items, check_photo):\n        \"\"\"Submit final check order to support group\"\"\"\n        try:\n            # Generate order ID\n            order_id = await self.order_server.generate_order_id()\n            \n            # Create final invoice text\n            invoice_text = (f\"📋 سفارش نهایی - چک\\n\"\n                           f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n                           f\"📋 شماره سفارش: {order_id}\\n\"\n                           f\"👤 مشتری: {customer['name']}\\n\"\n                           f\"🏙️ شهر: {customer['city']}\\n\"\n                           f\"🆔 کد نمایندگی: {customer['customer_id']}\\n\"\n                           f\"📱 شناسه کاربر: {user_id}\\n\"\n                           f\"💳 نوع پرداخت: {check_info.get('payment_method', 'چکی')}\\n\"\n                           f\"💰 مبلغ چک: {format_price(check_info.get('amount', 0))} تومان\\n\\n\"\n                           f\"📦 آیتم‌ها:\\n\")\n            \n            # Add cart items\n            for i, item in enumerate(cart_items, 1):\n                item_total = item.get('price', 0) * item.get('quantity', 0)\n                invoice_text += (f\"{persian_numbers(str(i))}. {item.get('product_name', 'محصول')}\\n\"\n                               f\"   📏 {item.get('size', 'نامشخص')} | \"\n                               f\"📦 {persian_numbers(str(item.get('quantity', 0)))} عدد | \"\n                               f\"💰 {format_price(item_total)}\\n\")\n            \n            invoice_text += (f\"\\n🕐 چک باید طی ۱۰ روز کاری به کارخانه ارسال شود\\n\"\n                           f\"✅ آماده تایید و پردازش\")\n            \n            # Create admin management buttons\n            keyboard = [[\n                InlineKeyboardButton(\"✅ تایید سفارش\", \n                                   callback_data=f\"order_status_{order_id}_confirmed\"),\n                InlineKeyboardButton(\"📞 تماس با مشتری\", \n                                   callback_data=f\"order_status_{order_id}_contacted\")\n            ], [\n                InlineKeyboardButton(\"📦 آماده ارسال\", \n                                   callback_data=f\"order_status_{order_id}_ready\"),\n                InlineKeyboardButton(\"🚚 ارسال شد\", \n                                   callback_data=f\"order_status_{order_id}_shipped\")\n            ], [\n                InlineKeyboardButton(\"✅ تکمیل\", \n                                   callback_data=f\"order_status_{order_id}_completed\"),\n                InlineKeyboardButton(\"❌ لغو\", \n                                   callback_data=f\"order_status_{order_id}_cancelled\")\n            ]]\n            \n            # Send final invoice with check photo to support group\n            if self.config.order_group_chat_id and check_photo:\n                await self.bot.send_photo(\n                    chat_id=self.config.order_group_chat_id,\n                    photo=check_photo['file_id'],\n                    caption=invoice_text,\n                    reply_markup=InlineKeyboardMarkup(keyboard)\n                )\n                \n                # Also save order data to server\n                await self.order_server.save_order(\n                    order_id=order_id,\n                    user_id=user_id,\n                    customer=customer,\n                    cart_items=cart_items,\n                    payment_info={\n                        'payment_method': check_info.get('payment_method', 'چکی'),\n                        'amount': check_info.get('amount', 0),\n                        'type': 'check'\n                    }\n                )\n                \n                logger.info(f\"Check order {order_id} submitted to support group\")\n            \n        except Exception as e:\n            logger.error(f\"Error submitting check order to support: {e}\")\n\n    async def _handle_check_info_sent(self, query, data):\n        \"\"\"Handle admin confirmation that check info was sent to customer\"\"\"\n        try:\n            user_id = int(data.split(\"_\")[-1])\n            admin_name = query.from_user.first_name or \"ادمین\"\n            \n            # Update support group message\n            updated_text = f\"✅ {admin_name}: اطلاعات کد ملی ارسال شد\\n\" + query.message.caption\n            \n            # Keep same admin buttons after selection (no customer confirmation button)\n            keyboard = [\n                [InlineKeyboardButton(\"👩 خانم فرانک غریبی\", \n                                   callback_data=f\"check_recipient_farank_{user_id}\")],\n                [InlineKeyboardButton(\"👨 نیما کریمی\", \n                                   callback_data=f\"check_recipient_nima_{user_id}\")],\n                [InlineKeyboardButton(\"👨 مجید ترابیان\", \n                                   callback_data=f\"check_recipient_majid_{user_id}\")],\n                [InlineKeyboardButton(\"👨 وحید ترابیان\", \n                                   callback_data=f\"check_recipient_vahid_{user_id}\")]\n            ]\n            \n            await query.edit_message_caption(\n                caption=updated_text,\n                reply_markup=InlineKeyboardMarkup(keyboard)\n            )\n            \n            # Send message to customer with new options\n            customer_text = (\"📝 تیم پشتیبانی اطلاعات کد ملی مورد نیاز را برای ثبت چک ارسال کرد.\\n\\n\"\n                           \"لطفا چک را طی ده روز کاری به کارخانه بخش حسابداری ارسال کنین\\n\\n\"\n                           \"پس از ارسال چک، دکمه زیر را فشار دهید:\")\n            \n            check_keyboard = self.keyboards.get_check_confirmation_keyboard()\n            \n            try:\n                await query.bot.send_message(\n                    chat_id=user_id,\n                    text=customer_text,\n                    reply_markup=check_keyboard\n                )\n            except Exception as customer_error:\n                logger.error(f\"Error sending check info to customer {user_id}: {customer_error}\")\n                \n        except Exception as e:\n            logger.error(f\"Error handling check info sent: {e}\")\n\n    async def _handle_check_contacted(self, query, data):\n        \"\"\"Handle admin confirmation that customer was contacted\"\"\"\n        try:\n            user_id = int(data.split(\"_\")[-1])\n            admin_name = query.from_user.first_name or \"ادمین\"\n            \n            # Update support group message\n            updated_text = f\"📞 {admin_name}: با مشتری تماس گرفته شد\\n\" + query.message.caption\n            \n            await query.edit_message_caption(caption=updated_text)\n            \n            # Notify customer of contact\n            try:\n                await query.bot.send_message(\n                    chat_id=user_id,\n                    text=\"📞 تیم پشتیبانی با شما تماس گرفت و اطلاعات لازم ارائه شد.\"\n                )\n            except Exception as customer_error:\n                logger.error(f\"Error notifying customer {user_id}: {customer_error}\")\n                \n        except Exception as e:\n            logger.error(f\"Error handling check contacted: {e}\")\n\n    async def _handle_zarinpal_payment(self, query, payment_type: str,\n                                       payment_method: str):\n        \"\"\"Handle ZarinPal payment\"\"\"\n        user_id = query.from_user.id\n        cart_items = self.cart_manager.get_cart(user_id)\n        customer = self.user_sessions[user_id]['customer']\n\n        if not cart_items:\n            await query.edit_message_text(\n                \"❌ سبد خرید شما خالی است.\",\n                reply_markup=self.keyboards.get_main_menu(authenticated=True))\n            return\n\n        # Calculate payment amount based on type\n        subtotal = self.pricing_manager.calculate_subtotal(cart_items)\n        discount_rate = self.pricing_manager.discount_rates.get(\n            payment_type, 0)\n        discount = self.pricing_manager.calculate_discount(\n            subtotal, discount_rate)\n\n        if payment_type == \"90day\":\n            # For 90-day payment, only 25% advance payment required\n            amount = int((subtotal - discount) * 0.25)  # 25% advance\n            description = f\"پیش‌پرداخت ۲۵٪ سفارش - {customer['name']}\"\n        else:\n            # For cash payment, full amount\n            amount = int(subtotal - discount)\n            description = f\"پرداخت نقدی سفارش - {customer['name']}\"\n\n        # Create payment request with proper callback URL\n        callback_url = \"https://www.zarinpal.com/pg/services/WebGate/wsdl\"  # Temporary callback\n\n        payment_result = self.zarinpal.create_payment_request(\n            amount=amount,\n            description=description,\n            callback_url=callback_url,\n            customer_mobile=customer.get('phone', ''),\n            customer_email=customer.get('email', ''))\n\n        if payment_result['success']:\n            # Store payment info in session\n            self.user_sessions[user_id]['payment_info'] = {\n                'authority': payment_result['authority'],\n                'amount': amount,\n                'payment_type': payment_type,\n                'payment_method': payment_method\n            }\n\n            text = (f\"💳 {payment_method}\\n\\n\"\n                    f\"💰 مبلغ قابل پرداخت: {format_price(amount)} تومان\\n\\n\"\n                    \"🔗 برای پرداخت روی دکمه زیر کلیک کنید:\")\n\n            keyboard = [[\n                InlineKeyboardButton(\"💳 پرداخت آنلاین\",\n                                     url=payment_result['payment_url'])\n            ],\n                        [\n                            InlineKeyboardButton(\n                                \"✅ پرداخت انجام شد\",\n                                callback_data=\"payment_completed\")\n                        ],\n                        [\n                            InlineKeyboardButton(\"🔙 بازگشت\",\n                                                 callback_data=\"view_invoice\")\n                        ],\n                        [\n                            InlineKeyboardButton(\"🏠 منوی اصلی\",\n                                                 callback_data=\"main_menu\")\n                        ]]\n\n            await query.edit_message_text(\n                text, reply_markup=InlineKeyboardMarkup(keyboard))\n        else:\n            text = (f\"❌ خطا در ایجاد درخواست پرداخت:\\n\"\n                    f\"{payment_result['error']}\\n\\n\"\n                    \"لطفاً دوباره تلاش کنید یا با پشتیبانی تماس بگیرید.\")\n\n            keyboard = [[\n                InlineKeyboardButton(\n                    \"🔄 تلاش مجدد\",\n                    callback_data=f\"payment_{payment_type}_zarinpal\")\n            ], [\n                InlineKeyboardButton(\"🏠 منوی اصلی\", callback_data=\"main_menu\")\n            ]]\n\n            await query.edit_message_text(\n                text, reply_markup=InlineKeyboardMarkup(keyboard))\n\n    async def _handle_card_to_card_payment(self, query, payment_type: str,\n                                           payment_method: str,\n                                           discount_rate: float):\n        \"\"\"Handle card-to-card payment\"\"\"\n        user_id = query.from_user.id\n        cart_items = self.cart_manager.get_cart(user_id)\n        customer = self.user_sessions[user_id]['customer']\n\n        if not cart_items:\n            await query.edit_message_text(\n                \"❌ سبد خرید شما خالی است.\",\n                reply_markup=self.keyboards.get_main_menu(authenticated=True))\n            return\n\n        # Calculate payment amount\n        subtotal = self.pricing_manager.calculate_subtotal(cart_items)\n        discount = self.pricing_manager.calculate_discount(\n            subtotal, discount_rate)\n        final_amount = subtotal - discount\n\n        # Store payment info in session\n        self.user_sessions[user_id]['payment_info'] = {\n            'payment_type':\n            payment_type,\n            'payment_method':\n            payment_method,\n            'amount':\n            final_amount if payment_type not in [\"90day\", \"60day\"] else int(\n                final_amount * 0.25),\n            'discount_rate':\n            discount_rate,\n            'awaiting_receipt':\n            payment_type != \"60day\",  # 60-day doesn't need receipt\n            'full_amount':\n            final_amount,\n            'subtotal':\n            subtotal,\n            'discount':\n            discount\n        }\n\n        # Generate payment details based on payment type\n        if payment_type == \"cash\":\n            payment_details = (\n                f\"💳 پرداخت نقدی (30% تخفیف)\\n\"\n                f\"از اعتماد شما ممنونیم\\n\\n\"\n                f\"💰 مبلغ کل: {format_price(subtotal)} تومان\\n\"\n                f\"🎁 تخفیف (30%): {format_price(discount)} تومان\\n\"\n                f\"💰 مبلغ نهایی پس از تخفیف: {format_price(final_amount)} تومان\\n\\n\"\n                f\"🏦 اطلاعات حساب:\\n\"\n                f\"💳 شماره کارت: 6219861915854102\\n\"\n                f\"🏦 شماره شبا: IR110560611828005185959401\\n\"\n                f\"👤 به نام:نیما کریمی\\n\\n\"\n                f\"📸 پس از واریز، لطفاً عکس فیش واریزی را ارسال کنید:\")\n            # Create keyboard for cash payment\n            keyboard = [[\n                InlineKeyboardButton(\"📸 ارسال فیش واریزی\",\n                                     callback_data=\"upload_receipt\")\n            ], [\n                InlineKeyboardButton(\"🔙 بازگشت\", callback_data=\"view_invoice\")\n            ]]\n\n        elif payment_type == \"60day\":\n            payment_details = (\n                f\"💳 پرداخت 60 روزه (25% تخفیف)\\n\"\n                f\"از اعتماد شما ممنونیم\\n\\n\"\n                f\"💰 مبلغ کل: {format_price(subtotal)} تومان\\n\"\n                f\"🎁 تخفیف (25%): {format_price(discount)} تومان\\n\"\n                f\"💰 مبلغ نهایی: {format_price(final_amount)} تومان\\n\\n\"\n                f\"هر 15 روز یک بار ربات،جهت یاداوری مانده حساب بهتون پیام میده\\n\"\n                f\"درصورت پرداخت به صورت چکی، تاریخ سر رسید چک در همین دوماه باشد\\n\\n\"\n                f\"نوع پرداخت خود را انتخاب کنید:\")\n            # Create keyboard for 60-day payment with cash/check options\n            keyboard = [[\n                InlineKeyboardButton(\"💰 پرداخت نقدی\",\n                                     callback_data=\"payment_type_cash_60day\")\n            ], [\n                InlineKeyboardButton(\"📋 پرداخت چکی\",\n                                     callback_data=\"payment_type_check_60day\")\n            ], [\n                InlineKeyboardButton(\"🔙 بازگشت\",\n                                     callback_data=\"view_invoice\")\n            ]]\n\n        elif payment_type == \"90day\":\n            advance_payment = int(final_amount * 0.25)\n            payment_details = (\n                f\"💳 پرداخت 90 روزه (25% تخفیف + 25% پیش‌پرداخت)\\n\"\n                f\"از اعتماد شما ممنونیم\\n\\n\"\n                f\"💰 مبلغ کل: {format_price(subtotal)} تومان\\n\"\n                f\"🎁 مبلغ تخفیف (25%): {format_price(discount)} تومان\\n\"\n                f\"💰 مبلغ نهایی: {format_price(final_amount)} تومان\\n\"\n                f\"💳 پیش‌پرداخت (25%): {format_price(advance_payment)} تومان\\n\\n\"\n                f\"نوع پرداخت خود را انتخاب کنید:\"\n            )\n            # Create keyboard for 90-day payment with cash/check options\n            keyboard = [[\n                InlineKeyboardButton(\"💰 پرداخت نقدی\",\n                                     callback_data=\"payment_type_cash_90day\")\n            ], [\n                InlineKeyboardButton(\"📋 پرداخت چکی\",\n                                     callback_data=\"payment_type_check_90day\")\n            ], [\n                InlineKeyboardButton(\"🔙 بازگشت\", callback_data=\"view_invoice\")\n            ]]\n\n        await query.edit_message_text(\n            payment_details, reply_markup=InlineKeyboardMarkup(keyboard))\n\n    async def _handle_check_payment(self, query, payment_type: str,\n                                    payment_method: str, discount_rate: float):\n        \"\"\"Handle check payment method\"\"\"\n        user_id = query.from_user.id\n        cart_items = self.cart_manager.get_cart(user_id)\n        customer = self.user_sessions[user_id]['customer']\n\n        if not cart_items:\n            await query.edit_message_text(\n                \"❌ سبد خرید شما خالی است.\",\n                reply_markup=self.keyboards.get_main_menu(authenticated=True))\n            return\n\n        # Calculate payment amount\n        subtotal = self.pricing_manager.calculate_subtotal(cart_items)\n        discount = self.pricing_manager.calculate_discount(\n            subtotal, discount_rate)\n        final_amount = subtotal - discount\n\n        # Store payment info in session\n        self.user_sessions[user_id]['payment_info'] = {\n            'payment_type': payment_type,\n            'payment_method': payment_method,\n            'amount': final_amount,\n            'discount_rate': discount_rate,\n            'awaiting_receipt': True,\n            'full_amount': final_amount,\n            'subtotal': subtotal,\n            'discount': discount,\n            'is_check_payment': True\n        }\n\n        payment_details = (\n            f\"📋 {payment_method} (25% تخفیف)\\n\"\n            f\"از اعتماد شما ممنونیم\\n\\n\"\n            f\"💰 مبلغ کل: {format_price(subtotal)} تومان\\n\"\n            f\"🎁 تخفیف (25%): {format_price(discount)} تومان\\n\"\n            f\"💰 مبلغ نهایی: {format_price(final_amount)} تومان\\n\\n\"\n            f\"📸. لطفاً عکس چک ثبت شده را ارسال کنید\\n\\n\"\n            f\"📝 نکته: درصورت خرید به صورت چکی لطفاً چک را به کارخانه ارسال کنید\"\n        )\n\n        keyboard = [[\n            InlineKeyboardButton(\"📸  ارسال چک ثبت شده \",\n                                 callback_data=\"upload_receipt\")\n        ], [InlineKeyboardButton(\"🔙 بازگشت\", callback_data=\"view_invoice\")]]\n\n        await query.edit_message_text(\n            payment_details, reply_markup=InlineKeyboardMarkup(keyboard))\n\n    async def _handle_payment_terms_confirmation(self, query):\n        \"\"\"Handle payment terms confirmation for 60-day and 90-day payments\"\"\"\n        user_id = query.from_user.id\n\n        if not self._is_authenticated(user_id):\n            await query.edit_message_text(\"❌ ابتدا باید احراز هویت کنید.\")\n            return\n\n        payment_info = self.user_sessions[user_id].get('payment_info')\n        if not payment_info:\n            await query.edit_message_text(\n                \"❌ اطلاعات پرداخت یافت نشد.\",\n                reply_markup=self.keyboards.get_main_menu(authenticated=True))\n            return\n\n        customer = self.user_sessions[user_id]['customer']\n        cart_items = self.cart_manager.get_cart(user_id)\n\n        # Send invoice to support group\n        invoice_text = self.pricing_manager.generate_final_invoice(\n            cart_items, customer, payment_info['payment_method'],\n            payment_info['discount_rate'])\n\n        # ارسال به گروه پشتیبانی\n        if self.config.order_group_chat_id:\n            try:\n                group_message = (\n                    f\"📋 تایید پرداخت اقساطی\\n\"\n                    f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n                    f\"👤 نام مشتری: {customer['name']}\\n\"\n                    f\"🏙️ شهر: {customer['city']}\\n\"\n                    f\"🆔 کد نمایندگی: {customer['customer_id']}\\n\"\n                    f\"📱 شناسه کاربر: {user_id}\\n\"\n                    f\"💳 روش پرداخت: {payment_info['payment_method']}\\n\"\n                    f\"💰 پیش‌پرداخت: {format_price(payment_info['amount'])} تومان\\n\"\n                    f\"💰 مبلغ باقی‌مانده: {format_price(payment_info['full_amount'] - payment_info['amount'])} تومان\\n\"\n                    f\"⏰ زمان تایید: {persian_numbers(datetime.now().strftime('%Y/%m/%d - %H:%M'))}\\n\\n\"\n                    f\"📋 جزئیات سفارش:\\n\"\n                    f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n                    f\"{invoice_text}\")\n\n                await query.bot.send_message(\n                    chat_id=self.config.order_group_chat_id,\n                    text=group_message)\n                logger.info(f\"✅ اطلاعات پرداخت اقساطی ارسال شد به گروه\")\n\n            except Exception as e:\n                logger.error(f\"❌ خطا در ارسال اطلاعات به گروه: {e}\")\n\n        # Schedule payment reminder for both 60-day and 90-day payments\n        if payment_info['payment_type'] in ['60day', '90day']:\n            total_amount = payment_info['full_amount']\n            advance_paid = payment_info['amount']\n            remaining_amount = total_amount - advance_paid\n\n            # Create order ID for tracking\n            order_id = f\"ORDER_{user_id}_{int(datetime.now().timestamp())}\"\n\n            if payment_info['payment_type'] == '60day':\n                # For 60-day payment: single reminder after 60 days\n                self.payment_scheduler.add_60day_payment_schedule(\n                    user_id=user_id,\n                    customer_info=customer,\n                    total_amount=total_amount,\n                    advance_paid=advance_paid,\n                    remaining_amount=remaining_amount,\n                    order_id=order_id)\n                logger.info(\n                    f\"✅ برنامه پرداخت 60 روزه برای کاربر {user_id} تنظیم شد\")\n            else:\n                # For 90-day payment: monthly reminders\n                self.payment_scheduler.add_90day_payment_schedule(\n                    user_id=user_id,\n                    customer_info=customer,\n                    total_amount=total_amount,\n                    advance_paid=advance_paid,\n                    remaining_amount=remaining_amount,\n                    order_id=order_id)\n                logger.info(\n                    f\"✅ برنامه پرداخت 90 روزه برای کاربر {user_id} تنظیم شد\")\n\n        # Show upload receipt interface\n        await query.edit_message_text(\n            f\"✅ شرایط پرداخت تایید شد!\\n\\n\"\n            f\"💰 مبلغ پیش‌پرداخت: {format_price(payment_info['amount'])} تومان\\n\"\n            f\"📅 یادآوری ماهانه برای مابقی پرداخت تنظیم شد\\n\\n\"\n            f\"📸 لطفاً عکس فیش واریز پیش‌پرداخت را ارسال کنید:\",\n            reply_markup=InlineKeyboardMarkup([[\n                InlineKeyboardButton(\"📸 ارسال فیش واریزی\",\n                                     callback_data=\"upload_receipt\")\n            ], [\n                InlineKeyboardButton(\"🔙 بازگشت\", callback_data=\"view_invoice\")\n            ]]))\n\n        if payment_type in [\"60day\", \"90day\"]:\n            keyboard = [[\n                InlineKeyboardButton(button_text,\n                                     callback_data=\"confirm_payment_terms\")\n            ], [\n                InlineKeyboardButton(\"🔙 بازگشت\", callback_data=\"view_invoice\")\n            ]]\n        else:\n            keyboard = [[\n                InlineKeyboardButton(\"📸 ارسال فیش واریزی\",\n                                     callback_data=\"upload_receipt\")\n            ], [\n                InlineKeyboardButton(\"🔙 بازگشت\", callback_data=\"view_invoice\")\n            ]]\n\n        await query.edit_message_text(\n            bank_info, reply_markup=InlineKeyboardMarkup(keyboard))\n\n    async def _handle_upload_receipt_request(self, query):\n        \"\"\"Handle receipt upload request\"\"\"\n        user_id = query.from_user.id\n        payment_info = self.user_sessions[user_id].get('payment_info', {})\n\n        if payment_info.get('is_check_payment'):\n            message_text = (\n                \"📸 لطفاً عکس فیش واریزی/چک ثبت شده را ارسال کنید\\n\\n\"\n                \"⚠️ فقط تصاویر با فرمت JPG, PNG قابل قبول هستند\\n\\n\"\n                \"📝 نکته: درصورت خرید به صورت چکی لطفاً چک را به کارخانه ارسال کنید\\n\\n\"\n                \"پس از ارسال عکس، دکمه تایید نمایش داده خواهد شد\")\n        else:\n            message_text = (\n                \"📸 لطفاً عکس فیش واریزی خود را در این چت ارسال کنید\\n\\n\"\n                \"⚠️ فقط تصاویر با فرمت JPG, PNG قابل قبول هستند\\n\\n\"\n                \"پس از ارسال عکس، دکمه تایید نمایش داده خواهد شد\")\n\n        await query.edit_message_text(message_text,\n                                      reply_markup=InlineKeyboardMarkup([[\n                                          InlineKeyboardButton(\n                                              \"🔙 بازگشت\",\n                                              callback_data=\"view_invoice\")\n                                      ]]))\n\n    async def _handle_payment_receipt_confirmation(self, query):\n        \"\"\"Handle payment receipt confirmation\"\"\"\n        user_id = query.from_user.id\n\n        if not self._is_authenticated(user_id):\n            await query.edit_message_text(\"❌ ابتدا باید احراز هویت کنید.\")\n            return\n\n        # Check if user is authenticated\n        if not self._is_authenticated(user_id):\n            await query.edit_message_text(\n                \"❌ ابتدا باید احراز هویت کنید.\",\n                reply_markup=self.keyboards.get_main_menu(authenticated=False))\n            return\n\n        customer = self.user_sessions[user_id]['customer']\n        cart_items = self.cart_manager.get_cart(user_id)\n        payment_info = self.user_sessions[user_id].get('payment_info')\n\n        if not payment_info:\n            await query.edit_message_text(\n                \"❌ اطلاعات پرداخت یافت نشد.\",\n                reply_markup=self.keyboards.get_main_menu(authenticated=True))\n            return\n\n        if not cart_items:\n            await query.edit_message_text(\n                \"❌ سبد خرید شما خالی است.\",\n                reply_markup=self.keyboards.get_main_menu(authenticated=True))\n            return\n\n        try:\n            # Get receipt photo if available\n            receipt_photo_id = None\n            if 'receipt_photo' in self.user_sessions[user_id]:\n                receipt_photo_id = self.user_sessions[user_id][\n                    'receipt_photo']['file_id']\n\n            # Send receipt/check photo to support group before creating order\n            if receipt_photo_id and self.config.order_group_chat_id:\n                try:\n                    payment_type_text = \"چک\" if payment_info.get(\n                        'is_check_payment') else \"فیش /چک ثبت شده \"\n                    photo_caption = (\n                        f\"📸 {payment_type_text} دریافت شده\\n\"\n                        f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n                        f\"👤 مشتری: {customer['name']}\\n\"\n                        f\"🏙️ شهر: {customer['city']}\\n\"\n                        f\"🆔 کد نمایندگی: {customer['customer_id']}\\n\"\n                        f\"📱 شناسه کاربر: {user_id}\\n\"\n                        f\"💳 روش پرداخت: {payment_info['payment_method']}\\n\"\n                        f\"💰 مبلغ کل: {format_price(payment_info['amount'])} تومان\\n\"\n                        f\"⏰ زمان ارسال: {persian_numbers(datetime.now().strftime('%Y/%m/%d - %H:%M'))}\"\n                    )\n\n                    await query.bot.send_photo(\n                        chat_id=self.config.order_group_chat_id,\n                        photo=receipt_photo_id,\n                        caption=photo_caption)\n                    logger.info(f\"✅ عکس {payment_type_text} ارسال شد به گروه\")\n\n                except Exception as e:\n                    logger.error(f\"❌ خطا در ارسال عکس به گروه: {e}\")\n\n            # Create order using order management server\n            order_id = await self.order_server.create_order(\n                user_id=user_id,\n                customer=customer,\n                cart_items=cart_items,\n                payment_method=payment_info['payment_method'],\n                discount_rate=payment_info['discount_rate'],\n                receipt_photo_id=receipt_photo_id)\n\n            # Clear cart and payment info\n            self.cart_manager.clear_cart(user_id)\n            if 'payment_info' in self.user_sessions[user_id]:\n                del self.user_sessions[user_id]['payment_info']\n            if 'receipt_photo' in self.user_sessions[user_id]:\n                del self.user_sessions[user_id]['receipt_photo']\n\n            # Confirm to customer\n            await query.edit_message_text(\n                f\"✅ عالیه! سفارش شما با موفقیت ثبت شد!\\n\"\n                f\"📋 شماره سفارش: {order_id}\\n\"\n                f\"🔄 بعد از تایید تیم پشتیبانی دکوتین شما را در جریان سفارش قرار خواهیم داد.\\n\"\n                f\"🙏 از اعتماد شما ممنونیم.\",\n                reply_markup=self.keyboards.get_main_menu(authenticated=True))\n\n            logger.info(\n                f\"✅ سفارش {order_id} با موفقیت ثبت شد برای کاربر {user_id}\")\n\n        except Exception as e:\n            logger.error(f\"Error in payment receipt confirmation: {e}\")\n            logger.error(\n                f\"User ID: {user_id}, Customer: {customer if customer else 'None'}, Cart items: {len(cart_items) if cart_items else 0}\"\n            )\n\n            # More detailed error handling\n            try:\n                await query.edit_message_text(\n                    f\"❌ خطایی در ثبت سفارش رخ داد.\\n\"\n                    f\"لطفاً دوباره تلاش کنید یا با پشتیبانی تماس بگیرید.\\n\\n\"\n                    f\"کد خطا: {type(e).__name__}\",\n                    reply_markup=self.keyboards.get_main_menu(\n                        authenticated=True))\n            except Exception as edit_error:\n                logger.error(f\"Error editing message: {edit_error}\")\n                # Send new message if editing fails\n                try:\n                    await query.message.reply_text(\n                        f\"❌ خطایی در ثبت سفارش رخ داد.\\n\"\n                        f\"لطفاً دوباره تلاش کنید یا با پشتیبانی تماس بگیرید.\",\n                        reply_markup=self.keyboards.get_main_menu(\n                            authenticated=True))\n                except Exception as reply_error:\n                    logger.error(f\"Error sending reply: {reply_error}\")\n\n    async def _handle_group_payment(self, query, payment_type: str,\n                                    payment_method: str):\n        \"\"\"Handle group payment (installment)\"\"\"\n        user_id = query.from_user.id\n        cart_items = self.cart_manager.get_cart(user_id)\n        customer = self.user_sessions[user_id]['customer']\n\n        # Check if cart is not empty\n        if not cart_items:\n            await query.edit_message_text(\n                \"❌ سبد خرید شما خالی است.\",\n                reply_markup=self.keyboards.get_main_menu(authenticated=True))\n            return\n\n        # Check if group chat ID is configured\n        if not self.config.order_group_chat_id:\n            await query.edit_message_text(\n                \"❌ گروه پیگیری سفارش تنظیم نشده است. لطفاً با پشتیبانی تماس بگیرید.\",\n                reply_markup=self.keyboards.get_main_menu(authenticated=True))\n            return\n\n        try:\n            # Generate final invoice\n            discount_rate = self.pricing_manager.discount_rates.get(\n                payment_type, 0.25)\n            invoice_text = self.pricing_manager.generate_final_invoice(\n                cart_items, customer, payment_method, discount_rate)\n\n            # Send to customer with confirmation\n            confirmation_text = (\n                f\"{invoice_text}\\n\\n\"\n                \"✅ سفارش شما ثبت شد و به گروه پشتیبانی دکوتین ارسال می‌شود.\\n\"\n                \"کارشناسان ما به زودی شما را درجریان سفارش قرار خواهند داد    .\")\n\n            keyboard = [[\n                InlineKeyboardButton(\"✅ تایید سفارش\",\n                                     callback_data=\"confirm_order\")\n            ], [\n                InlineKeyboardButton(\"🏠 منوی اصلی\", callback_data=\"main_menu\")\n            ]]\n\n            # Store order info for confirmation```python\n            self.user_sessions[user_id]['pending_order'] = {\n                'payment_method': payment_method,\n                'discount_rate': discount_rate,\n                'invoice_text': invoice_text\n            }\n\n            await query.edit_message_text(\n                confirmation_text, reply_markup=InlineKeyboardMarkup(keyboard))\n\n            logger.info(\n                \"Group payment processed successfully for user {user_id}\")\n\n        except Exception as e:\n            logger.error(f\"Error in group payment handling: {e}\")\n            await query.edit_message_text(\n                \"❌ خطایی در پردازش سفارش رخ داد. لطفاً دوباره تلاش کنید.\",\n                reply_markup=self.keyboards.get_main_menu(authenticated=True))\n\n    async def _handle_order_confirmation(self, query):\n        \"\"\"Handle order confirmation using order management server\"\"\"\n        user_id = query.from_user.id\n\n        # Check if user is authenticated\n        if not self._is_authenticated(user_id):\n            await query.edit_message_text(\n                \"❌ ابتدا باید احراز هویت کنید.\",\n                reply_markup=self.keyboards.get_main_menu(authenticated=False))\n            return\n\n        customer = self.user_sessions[user_id]['customer']\n        cart_items = self.cart_manager.get_cart(user_id)\n        pending_order = self.user_sessions[user_id].get('pending_order')\n\n        if not pending_order:\n            await query.edit_message_text(\n                \"❌ اطلاعات سفارش یافت نشد.\",\n                reply_markup=self.keyboards.get_main_menu(authenticated=True))\n            return\n\n        if not cart_items:\n            await query.edit_message_text(\n                \"❌ سبد خرید شما خالی است.\",\n                reply_markup=self.keyboards.get_main_menu(authenticated=True))\n            return\n\n        try:\n            # استفاده از سرور مدیریت سفارشات\n            order_id = await self.order_server.create_order(\n                user_id=user_id,\n                customer=customer,\n                cart_items=cart_items,\n                payment_method=pending_order['payment_method'],\n                discount_rate=pending_order['discount_rate'])\n\n            # Clear cart and session\n            self.cart_manager.clear_cart(user_id)\n            if 'pending_order' in self.user_sessions[user_id]:\n                del self.user_sessions[user_id]['pending_order']\n\n            # Store order ID in session\n            self.user_sessions[user_id]['last_order_id'] = order_id\n\n            # Confirm to customer\n            await query.edit_message_text(\n                f\"✅ عالیه! سفارش شما با موفقیت ثبت شد!\\n\"\n                f\"📋 شماره سفارش: {order_id}\\n\"\n                f\"🔄 بعد از تایید تیم پشتیبانی دکوتین شما را در جریان سفارش قرار خواهیم داد.\\n\"\n                f\"🙏 از اعتماد شما ممنونیم.\",\n                reply_markup=self.keyboards.get_main_menu(authenticated=True))\n\n        except Exception as e:\n            logger.error(f\"Error in order confirmation: {e}\")\n            await query.edit_message_text(\n                \"❌ خطایی در ثبت سفارش رخ داد. لطفاً دوباره تلاش کنید.\",\n                reply_markup=self.keyboards.get_main_menu(authenticated=True))\n\n    async def _handle_payment_completed(self, query):\n        \"\"\"Handle payment completed confirmation\"\"\"\n        user_id = query.from_user.id\n\n        if not self._is_authenticated(user_id):\n            await query.edit_message_text(\"❌ ابتدا باید احراز هویت کنید.\")\n            return\n\n        payment_info = self.user_sessions[user_id].get('payment_info')\n        if not payment_info:\n            await query.edit_message_text(\n                \"❌ اطلاعات پرداخت یافت نشد.\\n\"\n                \"لطفاً مجدداً تلاش کنید.\",\n                reply_markup=self.keyboards.get_main_menu(authenticated=True))\n            return\n\n        customer = self.user_sessions[user_id]['customer']\n        cart_items = self.cart_manager.get_cart(user_id)\n\n        # Generate final invoice\n        discount_rate = self.pricing_manager.discount_rates.get(\n            payment_info['payment_type'], 0)\n        invoice_text = self.pricing_manager.generate_final_invoice(\n            cart_items, customer, payment_info['payment_method'],\n            discount_rate)\n\n        # Send to group if configured\n        if self.config.order_group_chat_id:\n            group_message = (\n                f\"💳 پرداخت آنلاین تکمیل شده\\n\"\n                f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n                f\"👤 نام مشتری: {customer['name']}\\n\"\n                f\"🏙️ شهر: {customer['city']}\\n\"\n                f\"🆔 کد نمایندگی: {customer['customer_id']}\\n\"\n                f\"📱 یوزرنیم تلگرام: @{query.from_user.username or 'ندارد'}\\n\"\n                f\"🆔 شناسه کاربر: {user_id}\\n\"\n                f\"💳 روش پرداخت: {payment_info['payment_method']}\\n\"\n                f\"💰 مبلغ پرداختی: {format_price(payment_info['amount'])} تومان\\n\"\n                f\"⏰ زمان پرداخت: {persian_numbers(datetime.now().strftime('%Y/%m/%d - %H:%M'))}\\n\\n\"\n                f\"📋 جزئیات سفارش:\\n\"\n                f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n                f\"{invoice_text}\\n\\n\"\n                f\"✅ پرداخت تایید شده - نیاز به پیگیری ارسال\")\n\n            # Create admin action buttons for paid orders\n            keyboard = [[\n                InlineKeyboardButton(\n                    \"✅ تماس گرفته شد\",\n                    callback_data=f\"order_contacted_{user_id}\"),\n                InlineKeyboardButton(\"📦 آماده ارسال\",\n                                     callback_data=f\"order_ready_{user_id}\")\n            ],\n                        [\n                            InlineKeyboardButton(\n                                \"🚚 ارسال شد\",\n                                callback_data=f\"order_shipped_{user_id}\"),\n                            InlineKeyboardButton(\n                                \"✅ تکمیل شد\",\n                                callback_data=f\"order_completed_{user_id}\")\n                        ]]\n\n            try:\n                sent_message = await query.bot.send_message(\n                    chat_id=self.config.order_group_chat_id,\n                    text=group_message,\n                    reply_markup=InlineKeyboardMarkup(keyboard))\n                logger.info(\n                    f\"✅ Payment info sent to group {self.config.order_group_chat_id}\"\n                )\n                logger.info(f\"Message ID: {sent_message.message_id}\")\n\n                # Store order info for tracking\n                order_info = {\n                    'user_id': user_id,\n                    'customer': customer,\n                    'message_id': sent_message.message_id,\n                    'status': 'paid',\n                    'created_at': datetime.now().isoformat()\n                }\n                self.user_sessions[user_id]['order_info'] = order_info\n\n            except Exception as e:\n                logger.error(\n                    f\"❌ Error sending payment info to group {self.config.order_group_chat_id}: {e}\"\n                )\n                logger.error(f\"Error type: {type(e).__name__}\")\n                # Send error info to customer for debugging\n                await query.bot.send_message(\n                    chat_id=user_id,\n                    text=\n                    f\"⚠️ پرداخت ثبت شد اما ارسال به گروه با خطا مواجه شد:\\n{str(e)[:200]}\"\n                )\n        else:\n            logger.warning(\n                \"❌ Order group chat ID is not configured for payment notification\"\n            )\n\n        # Clear cart and payment info\n        self.cart_manager.clear_cart(user_id)\n        if 'payment_info' in self.user_sessions[user_id]:\n            del self.user_sessions[user_id]['payment_info']\n\n        text = (\n            f\"✅ سفارش شما ثبت شد!\\n\\n\"\n            f\"💳 روش پرداخت: {payment_info['payment_method']}\\n\"\n            f\"💰 مبلغ: {format_price(payment_info['amount'])} تومان\\n\\n\"\n            f\" سفارش شما به تیم پشتیبانی دکوتین ارسال شد در همین صفحه شمارا درجریان سفارش قرار خواهیم داد .\\n\"\n            f\"🙏 از اعتماد شما متشکریم.\")\n\n        await query.edit_message_text(\n            text,\n            reply_markup=self.keyboards.get_main_menu(authenticated=True))\n\n    async def _handle_payment_verification(self, query):\n        \"\"\"Handle payment verification\"\"\"\n        user_id = query.from_user.id\n        payment_info = self.user_sessions[user_id].get('payment_info')\n\n        if not payment_info:\n            await query.edit_message_text(\n                \"❌ اطلاعات پرداخت یافت نشد.\",\n                reply_markup=self.keyboards.get_main_menu(authenticated=True))\n            return\n\n        # Verify payment with ZarinPal\n        verify_result = self.zarinpal.verify_payment(\n            authority=payment_info['authority'], amount=payment_info['amount'])\n\n        if verify_result['success']:\n            # Payment successful\n            customer = self.user_sessions[user_id]['customer']\n            cart_items = self.cart_manager.get_cart(user_id)\n\n            # Generate final invoice\n            discount_rate = self.pricing_manager.discount_rates[\n                payment_info['payment_type']]\n            invoice_text = self.pricing_manager.generate_final_invoice(\n                cart_items, customer, payment_info['payment_method'],\n                discount_rate)\n\n            # Send to group if configured\n            if self.config.order_group_chat_id:\n                group_message = (\n                    f\"💳 پرداخت موفق - {payment_info['payment_method']}\\n\"\n                    f\"━━━━━━━━━━━━━━━━\\n\"\n                    f\"👤 مشتری: {customer['name']}\\n\"\n                    f\"🏙️ شهر: {customer['city']}\\n\"\n                    f\"🆔کد نمایندگی : {customer['customer_id']}\\n\"\n                    f\"📱 آیدی تلگرام: @{query.from_user.username or 'ندارد'}\\n\"\n                    f\"💳 شماره پیگیری: {verify_result['ref_id']}\\n\\n\"\n                    f\"{invoice_text}\")\n\n                try:\n                    await query.bot.send_message(\n                        chat_id=self.config.order_group_chat_id,\n                        text=group_message)\n                except Exception as e:\n                    logger.error(\n                        f\"Error sending payment confirmation to group: {e}\")\n\n            # Clear cart and payment info\n            self.cart_manager.clear_cart(user_id)\n            if 'payment_info' in self.user_sessions[user_id]:\n                del self.user_sessions[user_id]['payment_info']\n\n            text = (f\"✅ پرداخت با موفقیت انجام شد!\\n\\n\"\n                    f\"💳 شماره پیگیری: {verify_result['ref_id']}\\n\\n\"\n                    f\"📞 سفارش شما ثبت شد و به زودی با شما تماس خواهیم گرفت.\\n\"\n                    f\"🙏 از اعتماد شما متشکریم.\")\n\n            await query.edit_message_text(\n                text,\n                reply_markup=self.keyboards.get_main_menu(authenticated=True))\n        else:\n            # Payment failed\n            text = (f\"❌ پرداخت ناموفق بود:\\n\"\n                    f\"{verify_result['error']}\\n\\n\"\n                    \"می‌توانید دوباره تلاش کنید.\")\n\n            keyboard = [[\n                InlineKeyboardButton(\n                    \"🔄 تلاش مجدد\",\n                    callback_data=\n                    f\"payment_{payment_info['payment_type']}_zarinpal\")\n            ], [\n                InlineKeyboardButton(\"🏠 منوی اصلی\", callback_data=\"main_menu\")\n            ]]\n\n            await query.edit_message_text(\n                text, reply_markup=InlineKeyboardMarkup(keyboard))\n\n    async def _handle_cart_clear(self, query):\n        \"\"\"Handle cart clear\"\"\"\n        user_id = query.from_user.id\n        self.cart_manager.clear_cart(user_id)\n\n        text = \"🗑️ سبد خرید پاک شد.\"\n        keyboard = self.keyboards.get_main_menu(authenticated=True)\n\n        await query.edit_message_text(text, reply_markup=keyboard)\n\n    async def _handle_back_to_categories(self, query):\n        \"\"\"Handle back to categories\"\"\"\n        await self._handle_start_shopping(query)\n\n    async def _handle_back_to_alphabet(self, query):\n        \"\"\"Handle back to alphabet\"\"\"\n        user_id = query.from_user.id\n        category = self.user_sessions[user_id].get('selected_category', 'baby')\n\n        text = f\"🔤 جستجوی حروف الفبایی\\n\\nحرف اول نام محصول مورد نظر را انتخاب کنید:\"\n        keyboard = self.keyboards.get_alphabetical_keyboard(category)\n\n        await query.edit_message_text(text, reply_markup=keyboard)\n\n    async def _handle_back_to_curtain_subcategories(self, query):\n        \"\"\"Handle back to curtain subcategories\"\"\"\n        text = \"🏠 پرده و کوسن\\n\\nمحصول مورد نظر خود را انتخاب کنید:\"\n        keyboard = self.keyboards.get_curtain_subcategories()\n        await query.edit_message_text(text, reply_markup=keyboard)\n\n    async def _handle_back_to_products(self, query):\n        \"\"\"Handle back to products\"\"\"\n        user_id = query.from_user.id\n        session = self.user_sessions[user_id]\n\n        if 'selected_product' in session:\n            product = session['selected_product']\n\n            # Get price based on category\n            category = product.get('category_id', 'baby')\n            category_info = get_category_info(category)\n            price = category_info.get('price', 4780000)\n\n            text = (f\"📦 {product['name']}\\n\\n\"\n                    f\"💰 قیمت: {format_price(price)} تومان\\n\\n\"\n                    \"📏 سایز مورد نظر را انتخاب کنید:\")\n\n            keyboard = self.keyboards.get_size_selection_keyboard(category)\n            await query.edit_message_text(text, reply_markup=keyboard)\n\n    async def _handle_alphabet_search(self, query, data):\n        \"\"\"Handle alphabet search button\"\"\"\n        category = data.replace(\"alphabet_search_\", \"\")\n        user_id = query.from_user.id\n\n        # Store selected category in session\n        if user_id not in self.user_sessions:\n            self.user_sessions[user_id] = {}\n        self.user_sessions[user_id]['selected_category'] = category\n\n        category_info = get_category_info(category)\n        category_name = category_info.get('name', category)\n\n        text = f\"{category_name}\\n\\n🔤 جستجوی حروف الفبایی\\n\\nحرف اول نام محصول مورد نظر را انتخاب کنید:\"\n\n        keyboard = self.keyboards.get_alphabetical_keyboard(category)\n        await query.edit_message_text(text, reply_markup=keyboard)\n\n    async def _handle_icon_selection(self, query, data):\n        \"\"\"Handle icon-based product selection\"\"\"\n        parts = data.split(\"_\", 2)\n        if len(parts) < 3:\n            await query.edit_message_text(\"❌ خطا در انتخاب آیکون.\")\n            return\n\n        category = parts[1]\n        icon = parts[2]\n\n        # Search products by icon\n        products = search_products_by_icon(category, icon)\n\n        if not products:\n            await query.edit_message_text(\"❌ محصولی با این آیکون یافت نشد.\")\n            return\n\n        if len(products) == 1:\n            # Only one product found, select it directly\n            product = products[0]\n            await self._handle_direct_product_selection(\n                query, product, category)\n        else:\n            # Multiple products found, show selection keyboard\n            keyboard = self.keyboards.get_products_keyboard(products, category)\n            await query.edit_message_text(f\"محصولات مرتبط:\",\n                                          reply_markup=keyboard)\n\n    async def _handle_payment_confirmed(self, query, data):\n        \"\"\"Handle payment confirmation from the group\"\"\"\n        # Extract user_id from callback data\n        user_id = int(data.split(\"_\")[2])\n\n        # Get customer info\n        customer = self.user_sessions[user_id]['customer']\n\n        # Send confirmation to customer\n        text = (f\"✅ پرداخت شما تایید شد!\\n\\n\"\n                f\"🙏 از اعتماد شما متشکریم.\")\n\n        await query.bot.send_message(\n            chat_id=user_id,\n            text=text,\n            reply_markup=self.keyboards.get_main_menu(authenticated=True))\n\n        # Edit message in group to confirm\n        await query.edit_message_text(\n            f\"✅ پرداخت مشتری {customer['name']} تایید شد.\")\n\n    async def _handle_contact_made(self, query, data):\n        \"\"\"Handle contact confirmation from the group\"\"\"\n        # Extract user_id from callback data\n        user_id = int(data.split(\"_\")[2])\n\n        # Get customer info\n        customer = self.user_sessions[user_id]['customer']\n\n        # Edit message in group to confirm\n        await query.edit_message_text(\n            f\"📞 تماس با مشتری {customer['name']} برقرار شد.\")\n\n    async def _handle_remind_tomorrow(self, query, data):\n        \"\"\"Handle remind tomorrow request from the group\"\"\"\n        # Extract user_id from callback data\n        user_id = int(data.split(\"_\")[2])\n\n        # Get customer info\n        customer = self.user_sessions[user_id]['customer']\n\n        # Schedule reminder\n        # self.payment_scheduler.schedule_reminder(user_id)\n\n        # Edit message in group to confirm\n        await query.edit_message_text(\n            f\"⏰ یادآوری برای مشتری {customer['name']} برای فردا تنظیم شد.\")\n\n    async def _handle_order_contacted(self, query, data):\n        \"\"\"Handle order contacted confirmation\"\"\"\n        user_id = int(data.split(\"_\")[2])\n        admin_name = query.from_user.first_name or \"ادمین\"\n\n        # Update message\n        updated_text = f\"📞 {admin_name} با مشتری تماس گرفت\\n\" + query.message.text\n\n        # Create updated keyboard with remaining options\n        keyboard = [[\n            InlineKeyboardButton(\"📦 آماده ارسال\",\n                                 callback_data=f\"order_ready_{user_id}\"),\n            InlineKeyboardButton(\"🚚 ارسال شد\",\n                                 callback_data=f\"order_shipped_{user_id}\")\n        ],\n                    [\n                        InlineKeyboardButton(\n                            \"✅ تکمیل شد\",\n                            callback_data=f\"order_completed_{user_id}\"),\n                        InlineKeyboardButton(\n                            \"❌ لغو سفارش\",\n                            callback_data=f\"order_cancelled_{user_id}\")\n                    ]]\n\n        await query.edit_message_text(\n            updated_text, reply_markup=InlineKeyboardMarkup(keyboard))\n\n        # Notify customer - improved error handling\n        try:\n            await query.bot.send_message(\n                chat_id=user_id,\n                text=\n                \"📞 کارشناس ما با شما تماس گرفت. سفارش شما در حال پردازش است.\")\n            logger.info(f\"Successfully notified customer {user_id}\")\n        except Exception as e:\n            logger.error(f\"Error notifying customer {user_id}: {e}\")\n            # Continue processing even if customer notification fails\n\n    async def _handle_order_ready(self, query, data):\n        \"\"\"Handle order ready for shipping\"\"\"\n        user_id = int(data.split(\"_\")[2])\n        admin_name = query.from_user.first_name or \"ادمین\"\n\n        updated_text = f\"📦 {admin_name}: سفارش آماده ارسال شد\\n\" + query.message.text\n\n        keyboard = [[\n            InlineKeyboardButton(\"🚚 ارسال شد\",\n                                 callback_data=f\"order_shipped_{user_id}\"),\n            InlineKeyboardButton(\"✅ تکمیل شد\",\n                                 callback_data=f\"order_completed_{user_id}\")\n        ]]\n\n        await query.edit_message_text(\n            updated_text, reply_markup=InlineKeyboardMarkup(keyboard))\n\n        # Notify customer - improved error handling\n        try:\n            await query.bot.send_message(\n                chat_id=user_id,\n                text=\"📦 سفارش شما آماده و به زودی ارسال خواهد شد!\")\n            logger.info(f\"Successfully notified customer {user_id}\")\n        except Exception as e:\n            logger.error(f\"Error notifying customer {user_id}: {e}\")\n            # Continue processing even if customer notification fails\n\n    async def _handle_order_shipped(self, query, data):\n        \"\"\"Handle order shipped\"\"\"\n        user_id = int(data.split(\"_\")[2])\n        admin_name = query.from_user.first_name or \"ادمین\"\n\n        updated_text = f\"🚚 {admin_name}: سفارش ارسال شد\\n\" + query.message.text\n\n        keyboard = [[\n            InlineKeyboardButton(\"✅ تکمیل شد\",\n                                 callback_data=f\"order_completed_{user_id}\")\n        ]]\n\n        await query.edit_message_text(\n            updated_text, reply_markup=InlineKeyboardMarkup(keyboard))\n\n        # Notify customer - improved error handling\n        try:\n            await query.bot.send_message(\n                chat_id=user_id,\n                text=\"🚚 سفارش شما ارسال شد! به زودی دریافت خواهید کرد.\")\n            logger.info(f\"Successfully notified customer {user_id}\")\n        except Exception as e:\n            logger.error(f\"Error notifying customer {user_id}: {e}\")\n            # Continue processing even if customer notification fails\n\n    async def _handle_order_completed(self, query, data):\n        \"\"\"Handle order completion\"\"\"\n        user_id = int(data.split(\"_\")[2])\n        admin_name = query.from_user.first_name or \"ادمین\"\n\n        updated_text = f\"✅ {admin_name}: سفارش تکمیل شد\\n\" + query.message.text\n\n        await query.edit_message_text(updated_text)\n\n        # Notify customer - improved error handling\n        try:\n            await query.bot.send_message(\n                chat_id=user_id,\n                text=\n                \"✅ سفارش شما با موفقیت تکمیل شد!\\n🙏 از اعتماد شما متشکریم. امیدواریم از خرید خود راضی باشید.\"\n            )\n            logger.info(f\"Successfully notified customer {user_id}\")\n        except Exception as e:\n            logger.error(f\"Error notifying customer {user_id}: {e}\")\n            # Continue processing even if customer notification fails\n\n    async def _handle_order_cancelled(self, query, data):\n        \"\"\"Handle order cancellation\"\"\"\n        user_id = int(data.split(\"_\")[2])\n        admin_name = query.from_user.first_name or \"ادمین\"\n\n        updated_text = f\"❌ {admin_name}: سفارش لغو شد\\n\" + query.message.text\n\n        await query.edit_message_text(updated_text)\n\n        # Notify customer - improved error handling\n        try:\n            await query.bot.send_message(\n                chat_id=user_id,\n                text=\n                \"❌ متأسفانه سفارش شما لغو شد.\\n📞 برای اطلاعات بیشتر با پشتیبانی تماس بگیرید.\"\n            )\n            logger.info(f\"Successfully notified customer {user_id}\")\n        except Exception as e:\n            logger.error(f\"Error notifying customer {user_id}: {e}\")\n            # Continue processing even if customer notification fails\n\n    async def _handle_order_reminder(self, query, data):\n        \"\"\"Handle order reminder for tomorrow\"\"\"\n        user_id = int(data.split(\"_\")[2])\n        admin_name = query.from_user.first_name or \"ادمین\"\n\n        updated_text = f\"⏰ {admin_name}: یادآوری فردا تنظیم شد\\n\" + query.message.text\n\n        # Keep all original buttons\n        keyboard = [[\n            InlineKeyboardButton(\"✅ تماس گرفته شد\",\n                                 callback_data=f\"order_contacted_{user_id}\"),\n            InlineKeyboardButton(\"📦 آماده ارسال\",\n                                 callback_data=f\"order_ready_{user_id}\")\n        ],\n                    [\n                        InlineKeyboardButton(\n                            \"🚚 ارسال شد\",\n                            callback_data=f\"order_shipped_{user_id}\"),\n                        InlineKeyboardButton(\n                            \"✅ تکمیل شد\",\n                            callback_data=f\"order_completed_{user_id}\")\n                    ],\n                    [\n                        InlineKeyboardButton(\n                            \"❌ لغو سفارش\",\n                            callback_data=f\"order_cancelled_{user_id}\")\n                    ]]\n\n        await query.edit_message_text(\n            updated_text, reply_markup=InlineKeyboardMarkup(keyboard))\n\n    async def _handle_order_status_update(self, query, data):\n        \"\"\"Handle order status update from admin\"\"\"\n        try:\n            logger.info(f\"🔄 شروع پردازش تغییر وضعیت: {data}\")\n\n            # Parse callback data: order_status_ORDER_ID_STATUS\n            parts = data.split(\"_\")\n            if len(parts) < 4:\n                logger.error(f\"❌ فرمت داده نامعتبر: {data}\")\n                await query.answer(\"❌ داده نامعتبر\", show_alert=True)\n                return\n\n            # استخراج order_id و status از callback data\n            order_id = parts[2]\n            new_status = parts[3]\n            admin_name = query.from_user.first_name or \"ادمین\"\n\n            logger.info(\n                f\"📋 پردازش سفارش {order_id} به وضعیت {new_status} توسط {admin_name}\"\n            )\n\n            # پاسخ فوری به کاربر\n            await query.answer(\"🔄 در حال پردازش...\")\n\n            # بررسی وجود سفارش\n            order_data = await self.order_server.get_order_details(order_id)\n            if not order_data:\n                logger.error(f\"❌ سفارش {order_id} یافت نشد\")\n                await query.answer(\"❌ سفارش یافت نشد\", show_alert=True)\n                return\n\n            # بروزرسانی وضعیت سفارش\n            success = await self.order_server.update_order_status(\n                order_id=order_id,\n                new_status=new_status,\n                admin_name=admin_name)\n\n            if success:\n                logger.info(f\"✅ وضعیت سفارش {order_id} با موفقیت تغییر کرد\")\n                status_text = self.order_server._get_status_text(new_status)\n\n                try:\n                    # بروزرسانی پیام گروه\n                    current_text = query.message.text\n\n                    # اضافه کردن خط جدید در ابتدای پیام\n                    updated_text = f\"📝 {admin_name}: وضعیت به '{status_text}' تغییر کرد\\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n{current_text}\"\n\n                    # ایجاد کیبورد جدید\n                    keyboard = self.order_server._create_admin_buttons(\n                        order_id, order_data['user_id'])\n\n                    await query.edit_message_text(\n                        updated_text,\n                        reply_markup=InlineKeyboardMarkup(keyboard))\n                    logger.info(f\"✅ پیام گروه بروزرسانی شد\")\n\n                except Exception as edit_error:\n                    logger.error(f\"❌ خطا در بروزرسانی پیام گروه: {edit_error}\")\n                    # ارسال پیام تایید جداگانه\n                    try:\n                        confirmation_message = f\"✅ وضعیت سفارش {order_id} به '{status_text}' تغییر کرد توسط {admin_name}\"\n                        await query.message.reply_text(confirmation_message)\n                        logger.info(f\"✅ پیام تایید ارسال شد\")\n                    except Exception as reply_error:\n                        logger.error(\n                            f\"❌ خطا در ارسال پیام تایید: {reply_error}\")\n\n            else:\n                logger.error(f\"❌ خطا در بروزرسانی وضعیت سفارش {order_id}\")\n                await query.answer(\"❌ خطا در بروزرسانی وضعیت\", show_alert=True)\n\n        except Exception as e:\n            logger.error(f\"❌ خطای کلی در _handle_order_status_update: {e}\")\n            logger.error(f\"   Data: {data}\")\n            logger.error(\n                f\"   User: {query.from_user.first_name if query.from_user else 'Unknown'}\"\n            )\n\n            try:\n                await query.answer(f\"❌ خطا در پردازش: {str(e)[:30]}\",\n                                   show_alert=True)\n            except Exception as msg_error:\n                logger.error(f\"❌ خطا در ارسال پیام خطا: {msg_error}\")\n\n    async def _handle_order_details_request(self, query, data):\n        \"\"\"Handle request for order details\"\"\"\n        try:\n            order_id = data.replace(\"order_details_\", \"\")\n            order_data = await self.order_server.get_order_details(order_id)\n\n            if not order_data:\n                await query.answer(\"❌ سفارش یافت نشد\")\n                return\n\n            # Create detailed invoice message\n            customer = order_data.get('customer', {})\n            pricing = order_data.get('pricing', {})\n            cart_items = order_data.get('cart_items', [])\n\n            invoice_text = (\n                f\"📋 فاکتور - {order_id}\\n\"\n                f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n                f\"👤 {customer.get('name', 'نامشخص')}\\n\"\n                f\"🏙️ {customer.get('city', 'نامشخص')}\\n\"\n                f\"🆔 کد نمایندگی: {customer.get('customer_id', 'نامشخص')}\\n\"\n                f\"📱 شناسه کاربر: {order_data.get('user_id', 'نامشخص')}\\n\"\n                f\"⏰ {persian_numbers(order_data.get('created_at', '')[:16].replace('T', ' - '))}\\n\\n\"\n                f\"📦 آیتم‌ها:\\n\")\n\n            # Add cart items\n            for i, item in enumerate(cart_items, 1):\n                item_total = item.get('price', 0) * item.get('quantity', 0)\n                invoice_text += (\n                    f\"{persian_numbers(str(i))}. {item.get('product_name', 'محصول')}\\n\"\n                    f\"   📏 {item.get('size', 'نامشخص')} | \"\n                    f\"📦 {persian_numbers(str(item.get('quantity', 0)))} عدد | \"\n                    f\"💰 {format_price(item_total)}\\n\")\n\n            # Add pricing\n            invoice_text += (\n                f\"\\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n                f\"💳 {order_data.get('payment_method', 'نقدی')}\\n\"\n                f\"💰 مبلغ کل: {format_price(pricing.get('total', 0))} تومان\\n\"\n                f\"📊 {self.order_server._get_status_text(order_data.get('status', 'pending'))}\"\n            )\n\n            # Create management keyboard\n            keyboard = self.order_server._create_admin_buttons(\n                order_id, order_data['user_id'])\n            keyboard.append([\n                InlineKeyboardButton(\"🔙 بازگشت به لیست\",\n                                     callback_data=\"back_to_daily_orders\")\n            ])\n\n            await query.edit_message_text(\n                invoice_text, reply_markup=InlineKeyboardMarkup(keyboard))\n\n        except Exception as e:\n            logger.error(f\"Error showing order details: {e}\")\n            await query.answer(\"❌ خطا در نمایش جزئیات\")\n\n    async def _handle_daily_stats_request(self, query):\n        \"\"\"Handle daily statistics request\"\"\"\n        try:\n            stats = await self.order_server.get_orders_statistics()\n            today_orders = await self.order_server.get_todays_orders()\n\n            stats_text = (\n                f\"📊 آمار امروز ({persian_numbers(datetime.now().strftime('%Y/%m/%d'))})\\n\"\n                f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n                f\"📦 سفارشات امروز: {persian_numbers(str(len(today_orders)))}\\n\"\n                f\"💰 درآمد امروز: {format_price(stats.get('today_revenue', 0))} تومان\\n\\n\"\n                f\"📈 آمار کلی:\\n\"\n                f\"📦 کل سفارشات: {persian_numbers(str(stats.get('total_orders', 0)))}\\n\"\n                f\"💳 کل درآمد: {format_price(stats.get('total_revenue', 0))} تومان\\n\"\n            )\n\n            keyboard = [[\n                InlineKeyboardButton(\"🔙 بازگشت\",\n                                     callback_data=\"back_to_daily_orders\")\n            ]]\n\n            await query.edit_message_text(\n                stats_text, reply_markup=InlineKeyboardMarkup(keyboard))\n\n        except Exception as e:\n            logger.error(f\"Error showing daily stats: {e}\")\n            await query.answer(\"❌ خطا در نمایش آمار\")\n\n    async def _handle_refresh_daily_orders(self, query):\n        \"\"\"Handle refresh daily orders request\"\"\"\n        await query.answer(\"🔄 در حال بروزرسانی...\")\n\n        # Create a fake update object to reuse the _show_daily_orders method\n        class FakeUpdate:\n\n            def __init__(self, message):\n                self.message = message\n\n        fake_update = FakeUpdate(query.message)\n        await self._show_daily_orders(fake_update)\n\n    async def _handle_back_to_daily_orders(self, query):\n        \"\"\"Handle back to daily orders list\"\"\"\n\n        # Create a fake update object to reuse the _show_daily_orders method\n        class FakeUpdate:\n\n            def __init__(self, message):\n                self.message = message\n\n        fake_update = FakeUpdate(query.message)\n        await self._show_daily_orders(fake_update)\n\n    async def _handle_contact_customer_request(self, query, data):\n        \"\"\"Handle request to contact customer\"\"\"\n        try:\n            user_id = int(data.replace(\"contact_customer_\", \"\"))\n\n            contact_message = (\n                f\"📞 درخواست تماس با مشتری\\n\"\n                f\"🆔 شناسه کاربر: {user_id}\\n\\n\"\n                f\"لطفاً از طریق تلفن یا پیام مستقیم با مشتری تماس بگیرید.\")\n\n            await query.answer(\"✅ اطلاعات تماس نمایش داده شد\")\n            await query.message.reply_text(contact_message)\n\n        except Exception as e:\n            logger.error(f\"Error handling contact request: {e}\")\n            await query.answer(\"❌ خطا در پردازش درخواست\")\n\n    async def _handle_check_order_status(self, query, data):\n        \"\"\"Handle customer's request to check order status\"\"\"\n        try:\n            order_id = data.replace(\"check_order_status_\", \"\")\n            order_data = await self.order_server.get_order_details(order_id)\n\n            if not order_data:\n                await query.edit_message_text(\n                    \"❌ سفارش یافت نشد.\",\n                    reply_markup=InlineKeyboardMarkup([[\n                        InlineKeyboardButton(\"🏠 منوی اصلی\",\n                                             callback_data=\"main_menu\")\n                    ]]))\n                return\n\n            status_text = self.order_server._get_status_text(\n                order_data[\"status\"])\n            last_update = datetime.fromisoformat(\n                order_data[\"updated_at\"]).strftime(\"%Y/%m/%d - %H:%M\")\n\n            status_message = (\n                f\"📋 وضعیت سفارش شماره: {order_id}\\n\\n\"\n                f\"📊 وضعیت فعلی: {status_text}\\n\"\n                f\"⏰ آخرین به‌روزرسانی: {persian_numbers(last_update)}\\n\"\n                f\"💳 روش پرداخت: {order_data['payment_method']}\\n\"\n                f\"💰 مبلغ کل: {format_price(order_data['pricing']['total'])} تومان\"\n            )\n\n            keyboard = self.order_server._create_customer_support_buttons(\n                order_id)\n\n            await query.edit_message_text(\n                status_message, reply_markup=InlineKeyboardMarkup(keyboard))\n\n        except Exception as e:\n            logger.error(f\"Error checking order status: {e}\")\n            await query.edit_message_text(\"❌ خطا در بررسی وضعیت سفارش\")\n\n    async def _handle_payment_confirmation_from_group(self, query, data):\n        \"\"\"Handle payment confirmation from the payment reminder group\"\"\"\n        try:\n            # Extract schedule_id and payment_number from callback data\n            parts = data.split(\"_\")\n            schedule_id = parts[2]\n            payment_number = int(parts[3])\n\n            # Mark payment as made\n            success = self.payment_scheduler.mark_payment_made(\n                schedule_id, payment_number)\n\n            if success:\n                await query.edit_message_text(query.message.text +\n                                              \"\\n\\n✅ پرداخت تایید شد\")\n                await query.answer(\"✅ پرداخت با موفقیت ثبت شد!\")\n            else:\n                await query.answer(\"❌ خطا در ثبت پرداخت\")\n\n        except Exception as e:\n            logger.error(f\"Error handling payment confirmation: {e}\")\n            await query.answer(\"❌ خطا در پردازش درخواست\")\n\n    async def _handle_contact_made_from_group(self, query, data):\n        \"\"\"Handle contact made confirmation from the payment reminder group\"\"\"\n        try:\n            admin_name = query.from_user.first_name or \"ادمین\"\n\n            await query.edit_message_text(\n                query.message.text + f\"\\n\\n📞 {admin_name} با مشتری تماس گرفت\")\n            await query.answer(\"✅ تماس ثبت شد\")\n\n        except Exception as e:\n            logger.error(f\"Error handling contact confirmation: {e}\")\n            await query.answer(\"❌ خطا در پردازش درخواست\")\n\n    async def _handle_remind_tomorrow_from_group(self, query, data):\n        \"\"\"Handle remind tomorrow request from the payment reminder group\"\"\"\n        try:\n            admin_name = query.from_user.first_name or \"ادمین\"\n\n            await query.edit_message_text(\n                query.message.text +\n                f\"\\n\\n⏰ {admin_name} یادآوری فردا تنظیم کرد\")\n            await query.answer(\"⏰ یادآوری برای فردا تنظیم شد\")\n\n        except Exception as e:\n            logger.error(f\"Error handling remind tomorrow: {e}\")\n            await query.answer(\"❌ خطا در پردازش درخواست\")\n\n    async def _handle_contact_support_request(self, query):\n        \"\"\"Handle customer's request to contact support\"\"\"\n        user_id = query.from_user.id\n        await self.order_server.send_support_contact_info(user_id)\n        await query.answer(\"📞 اطلاعات تماس ارسال شد\")\n\n    async def _handle_faq_request(self, query):\n        \"\"\"Handle customer's request for FAQ\"\"\"\n        user_id = query.from_user.id\n        await self.order_server.send_faq(user_id)\n        await query.answer(\"❓ سوالات متداول ارسال شد\")\n\n    async def _handle_sewing_type_selection(self, query, data):\n        \"\"\"Handle sewing type selection for curtains\"\"\"\n        sewing_type = data.replace(\"sewing_\", \"\")\n        user_id = query.from_user.id\n\n        # Store selected sewing type in session\n        self.user_sessions[user_id]['selected_sewing_type'] = sewing_type\n\n        sewing_type_name = \"پانچ\" if sewing_type == \"panch\" else \"نواردوزی\"\n\n        text = (f\"✅ نوع دوخت انتخابی: {sewing_type_name}\\n\\n\"\n                \"عالیه! حالا جنس پارچش چی باشه؟\")\n\n        keyboard = self.keyboards.get_fabric_selection_keyboard()\n        await query.edit_message_text(text, reply_markup=keyboard)\n\n    async def _handle_fabric_selection(self, query, data):\n        \"\"\"Handle fabric selection for curtains\"\"\"\n        fabric = data.replace(\"fabric_\", \"\")\n        user_id = query.from_user.id\n\n        # Store selected fabric in session\n        self.user_sessions[user_id]['selected_fabric'] = fabric\n        category = 'curtain_only'\n        self.user_sessions[user_id]['selected_category'] = category\n\n        # Get price based on fabric\n        price = get_product_price('', category, fabric=fabric)\n\n        fabric_name = \"حریر کتان\" if fabric == \"silk_cotton\" else \"مخمل\"\n\n        text = (\n            f\"✅ جنس انتخابی: {fabric_name}\\n\"\n            f\"💰 قیمت: {format_price(price)} تومان\\n\\n\"\n            \"عالیه\\n\\n\"\n            \"عرض پرده ها 135 سانتی متر ثابت است لطفا ارتفاع مد نظر خودتو بنویس\"\n        )\n\n        # Set flag for height input\n        self.user_sessions[user_id]['awaiting_curtain_height'] = True\n\n        keyboard = self.keyboards.get_height_input_keyboard()\n        await query.edit_message_text(text, reply_markup=keyboard)\n\n    async def _handle_curtain_height_input(self, update, height_text):\n        \"\"\"Handle curtain height input\"\"\"\n        user_id = update.effective_user.id\n\n        try:\n            # Parse height (should be a number)\n            height = float(height_text)\n            if height < 2:\n                await update.message.reply_text(\n                    \"❌ ارتفاع باید حداقل 2 متر باشد. لطفاً دوباره وارد کنید:\")\n                return\n\n            # Store height and clear input flag\n            self.user_sessions[user_id]['selected_height'] = height\n            self.user_sessions[user_id]['awaiting_curtain_height'] = False\n\n            # Create custom size string for curtains\n            size = f\"عرض: 135 - ارتفاع: {height}م\"\n            self.user_sessions[user_id]['selected_size'] = size\n\n            # Get price based on fabric\n            fabric = self.user_sessions[user_id]['selected_fabric']\n            category = self.user_sessions[user_id]['selected_category']\n\n            if fabric == 'special':  # For bedside curtain\n                product = self.user_sessions[user_id]['selected_product']\n                price = get_product_price(product['id'], category)\n            else:\n                price = get_product_price('', category, fabric=fabric)\n\n            text = (f\"✅ ارتفاع انتخابی: {height} متر\\n\"\n                    f\"💰 قیمت: {format_price(price)} تومان\\n\\n\"\n                    \"حالا پردت چند قواره باشه؟\")\n\n            keyboard = self.keyboards.get_quantity_keyboard()\n            await update.message.reply_text(text, reply_markup=keyboard)\n\n        except ValueError:\n            await update.message.reply_text(\n                \"❌ لطفاً ارتفاع را به صورت عدد وارد کنید (مثال: 2.5):\")\n\n    async def _handle_back_to_sewing_type(self, query):\n        \"\"\"Handle back to sewing type selection\"\"\"\n        user_id = query.from_user.id\n\n        product = self.user_sessions[user_id].get('selected_product')\n        if product:\n            text = (f\"📦 {product['name']}\\n\\n\"\n                    \"عالیه چه نوع دوختی مد نظرته؟\")\n            keyboard = self.keyboards.get_sewing_type_keyboard()\n            await query.edit_message_text(text, reply_markup=keyboard)\n\n    async def _handle_back_to_fabric_selection(self, query):\n        \"\"\"Handle back to fabric selection\"\"\"\n        user_id = query.from_user.id\n\n        # Clear height input flag\n        if 'awaiting_curtain_height' in self.user_sessions[user_id]:\n            del self.user_sessions[user_id]['awaiting_curtain_height']\n\n        sewing_type = self.user_sessions[user_id].get('selected_sewing_type',\n                                                      'panch')\n        sewing_type_name = \"پانچ\" if sewing_type == \"panch\" else \"نواردوزی\"\n\n        text = (f\"✅ نوع دوخت انتخابی: {sewing_type_name}\\n\\n\"\n                \"عالیه! حالا جنس پارچش چی باشه؟\")\n        keyboard = self.keyboards.get_fabric_selection_keyboard()\n        await query.edit_message_text(text, reply_markup=keyboard)\n\n    async def _handle_order_actions(self, query, data):\n        \"\"\"Optimized handler for all order-related actions\"\"\"\n        try:\n            if data.startswith(\"order_contacted_\"):\n                await self._handle_order_contacted(query, data)\n            elif data.startswith(\"order_ready_\"):\n                await self._handle_order_ready(query, data)\n            elif data.startswith(\"order_shipped_\"):\n                await self._handle_order_shipped(query, data)\n            elif data.startswith(\"order_completed_\"):\n                await self._handle_order_completed(query, data)\n            elif data.startswith(\"order_cancelled_\"):\n                await self._handle_order_cancelled(query, data)\n            elif data.startswith(\"order_remind_\"):\n                await self._handle_order_reminder(query, data)\n            else:\n                logger.warning(f\"Unhandled order action: {data}\")\n                await query.answer(\"درحال پردازش...\")\n        except Exception as e:\n            logger.error(f\"Order action error: {e}\")\n            try:\n                await query.answer(\"❌ خطا در پردازش سفارش.\")\n            except:\n                pass\n\n    def _is_authenticated(self, user_id: int) -> bool:\n        \"\"\"Check if user is authenticated\"\"\"\n        return (user_id in self.user_sessions\n                and self.user_sessions[user_id].get('authenticated', False))\n\n    async def test_group_connection(self, bot):\n        \"\"\"Test if bot can send messages to the configured group\"\"\"\n        logger.info(\"🔍 Testing group connection...\")\n\n        if not self.config.order_group_chat_id:\n            logger.warning(\"❌ Order group chat ID is not configured\")\n            return False\n\n        try:\n            # Try to get chat info\n            chat = await bot.get_chat(self.config.order_group_chat_id)\n            logger.info(f\"✅ Group connection successful!\")\n            logger.info(f\"   Title: {chat.title}\")\n            logger.info(f\"   Type: {chat.type}\")\n            logger.info(f\"   ID: {chat.id}\")\n\n            return True\n        except Exception as e:\n            logger.warning(f\"⚠️ Group connection test failed: {e}\")\n            logger.info(\n                \"   Note: This is normal during startup - bot will work fine\")\n            return False\n\n    async def get_current_chat_info(self, bot, chat_id):\n        \"\"\"Get detailed info about current chat for debugging\"\"\"\n        try:\n            chat = await bot.get_chat(chat_id)\n            logger.info(f\"💬 Chat Info:\")\n            logger.info(f\"   ID: {chat.id}\")\n            logger.info(f\"   Title: {chat.title}\")\n            logger.info(f\"   Type: {chat.type}\")\n            logger.info(\n                f\"   Description: {getattr(chat, 'description', 'N/A')}\")\n            return chat\n        except Exception as e:\n            logger.error(f\"Error getting chat info: {e}\")\n            return None\n\n    async def _send_invoice_to_group(self, invoice_text, user_id):\n        \"\"\"Send invoice to group after order completion\"\"\"\n        group_chat_id = self.config.order_group_chat_id\n        if not group_chat_id:\n            logger.error(\"Group chat ID not configured.\")\n            return\n\n        try:\n            # Note: self.bot is not available in handlers, we need to get it from context\n            logger.info(\n                f\"Invoice sent to group {group_chat_id} for user {user_id}.\")\n        except Exception as e:\n            logger.error(f\"Failed to send invoice to group: {e}\")\n\n    async def _handle_60day_order_confirmation(self, query):\n        \"\"\"Handle confirmation for 60-day payment orders.\"\"\"\n        user_id = query.from_user.id\n\n        if not self._is_authenticated(user_id):\n            await query.edit_message_text(\"❌ ابتدا باید احراز هویت کنید.\")\n            return\n\n        payment_info = self.user_sessions[user_id].get('payment_info')\n        if not payment_info or payment_info['payment_type'] != '60day':\n            await query.edit_message_text(\n                \"❌ اطلاعات سفارش 60 روزه یافت نشد. لطفاً دوباره تلاش کنید.\",\n                reply_markup=self.keyboards.get_main_menu(authenticated=True))\n            return\n\n        customer = self.user_sessions[user_id]['customer']\n        cart_items = self.cart_manager.get_cart(user_id)\n\n        # Schedule the 60-day payment reminder\n        total_amount = payment_info['full_amount']\n        advance_paid = payment_info['amount']\n        remaining_amount = total_amount - advance_paid\n        order_id = f\"ORDER_{user_id}_{int(datetime.now().timestamp())}\"\n\n        self.payment_scheduler.add_60day_payment_schedule(\n            user_id=user_id,\n            customer_info=customer,\n            total_amount=total_amount,\n            advance_paid=advance_paid,\n            remaining_amount=remaining_amount,\n            order_id=order_id)\n        logger.info(f\"✅ برنامه پرداخت 60 روزه برای کاربر {user_id} تنظیم شد\")\n\n        try:\n            # Create order using order management server\n            order_id = await self.order_server.create_order(\n                user_id=user_id,\n                customer=customer,\n                cart_items=cart_items,\n                payment_method=payment_info['payment_method'],\n                discount_rate=payment_info['discount_rate'])\n\n            # Clear cart and payment info\n            self.cart_manager.clear_cart(user_id)\n            if 'payment_info' in self.user_sessions[user_id]:\n                del self.user_sessions[user_id]['payment_info']\n\n            # Confirm to customer\n            await query.edit_message_text(\n                f\"✅ سفارش شما با موفقیت ثبت شد!\\n\"\n                f\"📋 شماره سفارش: {order_id}\\n\"\n                f\"💳 روش پرداخت: {payment_info['payment_method']}\\n\"\n                f\"📅 یادآوری ماهانه برای پیگیری مابقی پرداخت فعال شد.\\n\"\n                f\"📞 کارشناسان ما به زودی با شما تماس خواهند گرفت.\\n\"\n                f\"🙏 از اعتماد شما ممنونیم.\",\n                reply_markup=self.keyboards.get_main_menu(authenticated=True))\n\n            logger.info(\n                f\"✅ سفارش 60 روزه {order_id} با موفقیت ثبت شد برای کاربر {user_id}\"\n            )\n\n        except Exception as e:\n            logger.error(f\"Error in 60-day order confirmation: {e}\")\n            await query.edit_message_text(\n                \"❌ خطایی در ثبت سفارش رخ داد. لطفاً دوباره تلاش کنید.\",\n                reply_markup=self.keyboards.get_main_menu(authenticated=True))\n\n    # Pagination handlers\n    async def _handle_baby_page(self, query, data):\n        \"\"\"Handle baby category pagination\"\"\"\n        page = int(data.split(\"_\")[-1])\n        text = \"👶 کالای خواب نوزاد\\n\\nعالیه! حالا بگو کدوم طرح؟\"\n        keyboard = self.keyboards.get_baby_subcategories(page)\n        await query.edit_message_text(text, reply_markup=keyboard)\n\n    async def _handle_curtain_page(self, query, data):\n        \"\"\"Handle curtain category pagination\"\"\"\n        page = int(data.split(\"_\")[-1])\n        text = \" پرده\\n\\nعالیه! حالا بگو کدوم طرح؟\"\n        keyboard = self.keyboards.get_curtain_subcategories(page)\n        await query.edit_message_text(text, reply_markup=keyboard)\n\n    async def _handle_cushion_page(self, query, data):\n        \"\"\"Handle cushion category pagination\"\"\"\n        page = int(data.split(\"_\")[-1])\n        text = \" کوسن\\n\\nعالیه! حالا بگو کدوم طرح؟\"\n        keyboard = self.keyboards.get_cushion_subcategories(page)\n        await query.edit_message_text(text, reply_markup=keyboard)\n\n    async def _handle_tablecloth_page(self, query, data):\n        \"\"\"Handle tablecloth category pagination\"\"\"\n        page = int(data.split(\"_\")[-1])\n        text = \" فرشینه\\n\\nعالیه! حالا بگو کدوم طرح؟\"\n        keyboard = self.keyboards.get_tablecloth_subcategories(page)\n        await query.edit_message_text(text, reply_markup=keyboard)\n\n    async def _handle_alpha_page(self, query, data):\n        \"\"\"Handle alphabet pagination\"\"\"\n        parts = data.split(\"_\")\n        category = parts[2]\n        page = int(parts[3])\n        text = f\"🔤 جستجوی حروف الفبایی\\n\\nحرف اول نام محصول مورد نظر را انتخاب کنید:\"\n        keyboard = self.keyboards.get_alphabetical_keyboard(category, page)\n        await query.edit_message_text(text, reply_markup=keyboard)\n\n    async def _handle_pay_remaining_balance(self, query, data):\n        \"\"\"Handle remaining balance payment request\"\"\"\n        try:\n            # استخراج order_id از callback data\n            order_id = data.replace(\"pay_remaining_\", \"\")\n            user_id = query.from_user.id\n            \n            logger.info(f\"💳 درخواست واریز مانده حساب برای سفارش {order_id} از کاربر {user_id}\")\n            \n            # دریافت اطلاعات سفارش\n            order_data = await self.order_server.get_order_details(order_id)\n            if not order_data:\n                await query.edit_message_text(\"❌ سفارش یافت نشد.\")\n                return\n                \n            # محاسبه مانده حساب\n            pricing = order_data.get('pricing', {})\n            total_amount = pricing.get('total', 0)\n            paid_amount = pricing.get('paid_amount', 0)\n            remaining_amount = total_amount - paid_amount\n            \n            customer = order_data.get('customer', {})\n            customer_name = customer.get('name', 'مشتری گرامی')\n            \n            # نمایش اطلاعات بانکی برای واریز مانده\n            bank_info = (\n                f\"💳 واریز مانده حساب\\n\"\n                f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n                f\"👤 {customer_name} عزیز\\n\"\n                f\"📋 سفارش: {order_id}\\n\\n\"\n                f\"💰 مبلغ کل فاکتور: {format_price(total_amount)} تومان\\n\"\n                f\"💳 مبلغ پرداخت شده: {format_price(paid_amount)} تومان\\n\"\n                f\"📊 مانده قابل پرداخت: {format_price(remaining_amount)} تومان\\n\\n\"\n                f\"🏧 اطلاعات حساب:\\n\"\n                f\"🏪 بانک ملت\\n\"\n                f\"💳 شماره حساب: ۶۲۱۰۸۶۱۹۱۵۶۸۱۲۰۲\\n\"\n                f\"👤 نام صاحب حساب: شرکت دکوتین\\n\\n\"\n                f\"📸 پس از واریز، لطفاً عکس فیش را ارسال کنید\"\n            )\n            \n            # ذخیره اطلاعات واریز مانده در session\n            if user_id not in self.user_sessions:\n                self.user_sessions[user_id] = {}\n            \n            self.user_sessions[user_id]['remaining_payment'] = {\n                'order_id': order_id,\n                'amount': remaining_amount,\n                'awaiting_receipt': True\n            }\n            \n            keyboard = [[\n                InlineKeyboardButton(\"📸 ارسال فیش واریزی\", \n                                   callback_data=\"upload_remaining_receipt\")\n            ], [\n                InlineKeyboardButton(\"🔙 بازگشت\", \n                                   callback_data=\"main_menu\")\n            ]]\n            \n            await query.edit_message_text(bank_info, \n                                        reply_markup=InlineKeyboardMarkup(keyboard))\n                                        \n        except Exception as e:\n            logger.error(f\"❌ خطا در پردازش واریز مانده حساب: {e}\")\n            await query.edit_message_text(\"❌ خطایی رخ داد. لطفاً دوباره تلاش کنید.\")\n\n    async def _handle_confirm_remaining_payment(self, query, data):\n        \"\"\"Handle confirmation of remaining balance payment\"\"\"\n        try:\n            user_id = query.from_user.id\n            \n            # بررسی session\n            if (user_id not in self.user_sessions or \n                'remaining_payment' not in self.user_sessions[user_id] or\n                'receipt_photo' not in self.user_sessions[user_id]):\n                await query.edit_message_text(\"❌ اطلاعات پرداخت یافت نشد.\")\n                return\n                \n            remaining_payment = self.user_sessions[user_id]['remaining_payment']\n            order_id = remaining_payment['order_id']\n            amount = remaining_payment['amount']\n            receipt_photo = self.user_sessions[user_id]['receipt_photo']\n            \n            # دریافت اطلاعات سفارش و مشتری\n            order_data = await self.order_server.get_order_details(order_id)\n            customer = order_data.get('customer', {})\n            \n            # ارسال فیش به گروه پشتیبانی\n            if self.config.order_group_chat_id:\n                try:\n                    photo_caption = (\n                        f\"💳 واریز مانده حساب دریافت شد\\n\"\n                        f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n                        f\"👤 مشتری: {customer.get('name', 'نامشخص')}\\n\"\n                        f\"🏙️ شهر: {customer.get('city', 'نامشخص')}\\n\"\n                        f\"🆔 کد نمایندگی: {customer.get('customer_id', 'نامشخص')}\\n\"\n                        f\"📱 شناسه کاربر: {user_id}\\n\"\n                        f\"📋 سفارش: {order_id}\\n\"\n                        f\"💰 مبلغ مانده: {format_price(amount)} تومان\\n\"\n                        f\"⏰ زمان ارسال: {persian_numbers(datetime.now().strftime('%Y/%m/%d - %H:%M'))}\\n\\n\"\n                        f\"✅ آماده تایید مجدد سفارش\"\n                    )\n                    \n                    # دکمه‌های ادمین برای تایید\n                    admin_keyboard = [[\n                        InlineKeyboardButton(\"✅ تایید مجدد سفارش\", \n                                           callback_data=f\"order_status_{order_id}_confirmed\"),\n                        InlineKeyboardButton(\"📞 تماس گرفته شد\", \n                                           callback_data=f\"order_status_{order_id}_contacted\")\n                    ]]\n                    \n                    await query.bot.send_photo(\n                        chat_id=self.config.order_group_chat_id,\n                        photo=receipt_photo['file_id'],\n                        caption=photo_caption,\n                        reply_markup=InlineKeyboardMarkup(admin_keyboard)\n                    )\n                    logger.info(f\"✅ فیش واریز مانده حساب به گروه ارسال شد\")\n                    \n                except Exception as e:\n                    logger.error(f\"❌ خطا در ارسال فیش به گروه: {e}\")\n            \n            # تأیید برای مشتری\n            await query.edit_message_text(\n                f\"✅ فیش واریز مانده حساب دریافت شد!\\n\\n\"\n                f\"📋 سفارش: {order_id}\\n\"\n                f\"💰 مبلغ: {format_price(amount)} تومان\\n\\n\"\n                f\"🔄 فیش شما به تیم پشتیبانی ارسال شد\\n\"\n                f\"✅ پس از بررسی و تایید، سفارش شما مجدداً فعال خواهد شد\\n\\n\"\n                f\"📞 در صورت نیاز با پشتیبانی تماس بگیرید\\n\"\n                f\"🙏 از صبر و همکاری شما متشکریم\",\n                reply_markup=InlineKeyboardMarkup([[\n                    InlineKeyboardButton(\"🏠 منوی اصلی\", callback_data=\"main_menu\")\n                ]])\n            )\n            \n            # پاک کردن اطلاعات از session\n            if 'remaining_payment' in self.user_sessions[user_id]:\n                del self.user_sessions[user_id]['remaining_payment']\n            if 'receipt_photo' in self.user_sessions[user_id]:\n                del self.user_sessions[user_id]['receipt_photo']\n                \n            logger.info(f\"✅ واریز مانده حساب تایید شد برای سفارش {order_id}\")\n            \n        except Exception as e:\n            logger.error(f\"❌ خطا در تایید واریز مانده حساب: {e}\")\n            await query.edit_message_text(\"❌ خطایی رخ داد. لطفاً دوباره تلاش کنید.\")\n\n    async def _handle_upload_remaining_receipt(self, query):\n        \"\"\"Handle upload remaining balance receipt request\"\"\"\n        await query.edit_message_text(\n            \"📸 لطفاً عکس فیش واریز مانده حساب خود را در این چت ارسال کنید\\n\\n\"\n            \"⚠️ فقط تصاویر با فرمت JPG, PNG قابل قبول هستند\\n\\n\"\n            \"پس از ارسال عکس، دکمه تایید نمایش داده خواهد شد\",\n            reply_markup=InlineKeyboardMarkup([[\n                InlineKeyboardButton(\"🔙 بازگشت\", callback_data=\"main_menu\")\n            ]])\n        )\n\n    async def _handle_check_recipient_selection(self, query, data):\n        \"\"\"Handle admin selection of check recipient\"\"\"\n        try:\n            # Extract recipient and user_id from callback data\n            # Format: check_recipient_{recipient}_{user_id}\n            parts = data.split(\"_\")\n            recipient = parts[2]  # farank, nima, majid, vahid\n            user_id = int(parts[3])\n            \n            admin_name = query.from_user.first_name or \"ادمین\"\n            \n            # Define recipient information\n            recipients = {\n                'farank': {\n                    'name': 'خانم فرانک غریبی',\n                    'national_id': '0012311138'\n                },\n                'nima': {\n                    'name': 'آقای نیما کریمی', \n                    'national_id': '0451640594'\n                },\n                'majid': {\n                    'name': 'مجید ترابیان',\n                    'national_id': '007335310'\n                },\n                'vahid': {\n                    'name': 'آقای وحید ترابیان',\n                    'national_id': '0077860357'\n                }\n            }\n            \n            recipient_info = recipients.get(recipient)\n            if not recipient_info:\n                await query.answer(\"❌ گیرنده نامعتبر\", show_alert=True)\n                return\n                \n            # Send message to customer\n            customer_message = (\n                f\"✅ چک شما توسط تیم پشتیبانی دکوتین مورد قبول قرار گرفت\\n\\n\"\n                f\"📝 لطفاً چک را به اسم {recipient_info['name']} \"\n                f\"به کد ملی: {recipient_info['national_id']} ثبت کنید\\n\\n\"\n                f\"📅 تا 10 روز کاری چک را به آدرس کارخانه بخش حسابداری ارسال کنید\"\n            )\n            \n            # Customer confirmation keyboard\n            customer_keyboard = [[\n                InlineKeyboardButton(\"✅ چک را ثبت کرده ام وتا 10 روز کاری ارسال خواهم کرد\", \n                                   callback_data=f\"check_customer_confirm_{user_id}\")\n            ]]\n            \n            # Send message to customer\n            try:\n                await self.bot.send_message(\n                    chat_id=user_id,\n                    text=customer_message,\n                    reply_markup=InlineKeyboardMarkup(customer_keyboard)\n                )\n                \n                # Update support group message\n                updated_text = f\"✅ {admin_name}: ارسال شد به {recipient_info['name']}\\n\" + query.message.caption\n                \n                await query.edit_message_caption(\n                    caption=updated_text,\n                    reply_markup=query.message.reply_markup\n                )\n                \n                await query.answer(f\"✅ پیام برای {recipient_info['name']} ارسال شد\")\n                logger.info(f\"Check recipient message sent to customer {user_id} for {recipient_info['name']}\")\n                \n            except Exception as e:\n                logger.error(f\"Error sending check recipient message to customer {user_id}: {e}\")\n                await query.answer(\"❌ خطا در ارسال پیام\", show_alert=True)\n                \n        except Exception as e:\n            logger.error(f\"Error handling check recipient selection: {e}\")\n            await query.answer(\"❌ خطایی رخ داد\", show_alert=True)\n\n    async def _handle_check_customer_confirmation(self, query, data):\n        \"\"\"Handle customer confirmation of check submission\"\"\"\n        try:\n            user_id = int(data.split(\"_\")[-1])\n            \n            if user_id not in self.user_sessions:\n                await query.answer(\"❌ جلسه منقضی شده\", show_alert=True)\n                return\n                \n            # Get customer and cart info\n            customer = self.user_sessions[user_id]['customer']\n            cart_items = self.cart_manager.get_cart(user_id)\n            check_info = self.user_sessions[user_id].get('check_payment_info', {})\n            \n            # Send invoice and check photo again to support group\n            support_text = (f\"🔄 تایید مجدد چک از مشتری\\n\"\n                           f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n                           f\"👤 مشتری: {customer['name']}\\n\"\n                           f\"🏙️ شهر: {customer['city']}\\n\"\n                           f\"🆔 کد نمایندگی: {customer['customer_id']}\\n\"\n                           f\"📱 شناسه کاربر: {user_id}\\n\"\n                           f\"💰 مبلغ: {format_price(check_info.get('amount', 0))} تومان\\n\"\n                           f\"💳 روش: {check_info.get('payment_method', 'نامشخص')}\\n\\n\"\n                           f\"✅ مشتری تایید کرد که چک را ثبت و ارسال خواهد کرد\")\n            \n            # Get stored check photo\n            receipt_photo = self.user_sessions[user_id].get('receipt_photo')\n            \n            if receipt_photo and self.config.order_group_chat_id:\n                # Same admin buttons (no customer confirmation button)\n                keyboard = [\n                    [InlineKeyboardButton(\"👩 خانم فرانک غریبی\", \n                                       callback_data=f\"check_recipient_farank_{user_id}\")],\n                    [InlineKeyboardButton(\"👨 نیما کریمی\", \n                                       callback_data=f\"check_recipient_nima_{user_id}\")],\n                    [InlineKeyboardButton(\"👨 مجید ترابیان\", \n                                       callback_data=f\"check_recipient_majid_{user_id}\")],\n                    [InlineKeyboardButton(\"👨 وحید ترابیان\", \n                                       callback_data=f\"check_recipient_vahid_{user_id}\")]\n                ]\n                \n                await self.bot.send_photo(\n                    chat_id=self.config.order_group_chat_id,\n                    photo=receipt_photo['file_id'],\n                    caption=support_text,\n                    reply_markup=InlineKeyboardMarkup(keyboard)\n                )\n                \n                logger.info(f\"Check photo and invoice resent to support group for user {user_id}\")\n                \n            # Notify customer\n            await query.edit_message_text(\n                \"✅ پیش فاکتور و عکس چک مجدد برای تیم پشتیبانی ارسال شد\\n\"\n                \"⏰ پس از بررسی، نتیجه برای شما ارسال خواهد شد\"\n            )\n            \n        except Exception as e:\n            logger.error(f\"Error handling check customer confirmation: {e}\")\n            await query.answer(\"❌ خطایی رخ داد\", show_alert=True)\n","size_bytes":179804},"bot/hesabfa_integration.py":{"content":"\n#!/usr/bin/env python3\n\"\"\"\nHesabfa API Integration\nادغام با نرم‌افزار حسابفا برای ثبت خودکار پیش‌فاکتورها\n\"\"\"\n\nimport requests\nimport json\nfrom typing import Dict, List, Optional, Any\nfrom datetime import datetime\nfrom utils.logger import setup_logger\nfrom utils.persian_utils import format_price, persian_numbers\n\nlogger = setup_logger(__name__)\n\nclass HesabfaAPI:\n    \"\"\"کلاس ادغام با API حسابفا\"\"\"\n    \n    def __init__(self, api_key: str = \"\", login_token: str = \"\"):\n        import os\n        self.api_key = api_key or os.getenv(\"HESABFA_API_KEY\", \"WjJ88NUd9rjK6dIUKYilbtCoPFCUFHs8\")\n        self.login_token = login_token or os.getenv(\"HESABFA_LOGIN_TOKEN\", \"\")\n        self.base_url = \"https://app.hesabfa.com/api/v1\"\n        self.headers = {\n            \"Content-Type\": \"application/json\",\n            \"apikey\": self.api_key,\n            \"logintoken\": self.login_token\n        }\n    \n    async def create_invoice(self, order_data: Dict) -> Dict[str, Any]:\n        \"\"\"ایجاد پیش‌فاکتور در حسابفا\"\"\"\n        try:\n            logger.info(f\"🔄 شروع ثبت فاکتور در حسابفا برای سفارش {order_data.get('order_id')}\")\n            \n            # آماده‌سازی داده‌های فاکتور\n            invoice_data = self._prepare_invoice_data(order_data)\n            logger.info(f\"📋 داده‌های فاکتور آماده شد: {json.dumps(invoice_data, ensure_ascii=False, indent=2)}\")\n            \n            # ارسال درخواست به API حسابفا\n            url = f\"{self.base_url}/invoice\"\n            logger.info(f\"🌐 ارسال درخواست به: {url}\")\n            \n            response = requests.post(\n                url, \n                headers=self.headers, \n                json=invoice_data,\n                timeout=60,  # افزایش timeout به 60 ثانیه\n                verify=True  # اطمینان از SSL\n            )\n            \n            logger.info(f\"📡 پاسخ حسابفا: Status={response.status_code}\")\n            \n            if response.status_code == 200:\n                result = response.json()\n                logger.info(f\"📄 محتوای پاسخ: {json.dumps(result, ensure_ascii=False, indent=2)}\")\n                \n                if result.get(\"Success\"):\n                    invoice_result = result.get(\"Result\", {})\n                    logger.info(f\"✅ پیش‌فاکتور با موفقیت در حسابفا ثبت شد - ID: {invoice_result.get('Id')}\")\n                    return {\n                        \"success\": True,\n                        \"invoice_id\": invoice_result.get(\"Id\"),\n                        \"invoice_number\": invoice_result.get(\"Number\"),\n                        \"message\": \"پیش‌فاکتور با موفقیت در حسابفا ثبت شد\"\n                    }\n                else:\n                    error_msg = result.get(\"ErrorMessage\", \"خطای نامشخص\")\n                    logger.error(f\"❌ خطا در ثبت پیش‌فاکتور: {error_msg}\")\n                    return {\n                        \"success\": False,\n                        \"error\": error_msg\n                    }\n            else:\n                response_text = response.text[:500] if response.text else \"بدون محتوا\"\n                logger.error(f\"❌ خطا در ارتباط با حسابفا: HTTP {response.status_code}\")\n                logger.error(f\"   Response: {response_text}\")\n                return {\n                    \"success\": False,\n                    \"error\": f\"خطا در ارتباط با حسابفا: {response.status_code} - {response_text[:100]}\"\n                }\n                \n        except requests.exceptions.Timeout:\n            logger.error(\"❌ Timeout در ارتباط با حسابفا\")\n            logger.error(f\"   URL: {url}\")\n            logger.warning(\"⚠️ ممکن است محدودیت شبکه‌ای وجود داشته باشد\")\n            return {\n                \"success\": False,\n                \"error\": \"زمان انتظار ارتباط با حسابفا به پایان رسید - لطفاً دسترسی شبکه را بررسی کنید\"\n            }\n        except requests.exceptions.ConnectionError:\n            logger.error(\"❌ مشکل در اتصال به حسابفا - ممکن است سرور در دسترس نباشد\")\n            logger.error(f\"   URL: {url}\")\n            logger.warning(\"⚠️ از محیط‌های مختلف (خارج از Replit) تست کنید\")\n            return {\n                \"success\": False,\n                \"error\": \"عدم دسترسی به سرور حسابفا - ممکن است محدودیت شبکه‌ای وجود داشته باشد\"\n            }\n        except Exception as e:\n            logger.error(f\"❌ خطا در ایجاد پیش‌فاکتور حسابفا: {e}\")\n            logger.error(f\"   نوع خطا: {type(e).__name__}\")\n            return {\n                \"success\": False,\n                \"error\": f\"خطای سیستمی: {str(e)}\"\n            }\n    \n    def _prepare_invoice_data(self, order_data: Dict) -> Dict:\n        \"\"\"آماده‌سازی داده‌های فاکتور برای حسابفا\"\"\"\n        customer = order_data.get(\"customer\", {})\n        cart_items = order_data.get(\"cart_items\", [])\n        pricing = order_data.get(\"pricing\", {})\n        \n        # آماده‌سازی اطلاعات مشتری\n        contact_data = {\n            \"Name\": customer.get(\"name\", \"مشتری\"),\n            \"Code\": customer.get(\"customer_id\", \"\"),\n            \"City\": customer.get(\"city\", \"\"),\n            \"ContactType\": 1  # 1 = مشتری\n        }\n        \n        # آماده‌سازی آیتم‌های فاکتور\n        invoice_items = []\n        for item in cart_items:\n            invoice_items.append({\n                \"ItemCode\": item.get(\"product_id\", \"\"),\n                \"ItemName\": item.get(\"product_name\", \"\"),\n                \"Description\": f\"سایز: {item.get('size', '')}\",\n                \"Quantity\": item.get(\"quantity\", 1),\n                \"UnitPrice\": item.get(\"price\", 0),\n                \"Tax\": 0,  # مالیات محاسبه شده جداگانه\n                \"Discount\": 0\n            })\n        \n        # داده‌های اصلی فاکتور\n        invoice_data = {\n            \"Contact\": contact_data,\n            \"InvoiceItems\": invoice_items,\n            \"Number\": order_data.get(\"order_id\", \"\"),\n            \"Date\": datetime.now().strftime(\"%Y/%m/%d\"),\n            \"DueDate\": datetime.now().strftime(\"%Y/%m/%d\"),\n            \"Status\": 0,  # 0 = پیش‌فاکتور\n            \"Reference\": f\"سفارش تلگرام - {order_data.get('order_id')}\",\n            \"Notes\": f\"روش پرداخت: {order_data.get('payment_method', '')}\\nکاربر تلگرام: {order_data.get('user_id', '')}\",\n            \"Tag\": \"تلگرام-بات\",\n            \"Project\": \"DecoTeen Bot Orders\",\n            \"SalesPerson\": \"ربات فروش\",\n            \"Currency\": \"IRR\"\n        }\n        \n        # اضافه کردن تخفیف در صورت وجود\n        if pricing.get(\"discount\", 0) > 0:\n            invoice_data[\"Discount\"] = pricing.get(\"discount\", 0)\n            invoice_data[\"DiscountType\"] = 1  # 1 = مقدار ثابت\n        \n        return invoice_data\n    \n    async def create_contact_if_not_exists(self, customer: Dict) -> Dict[str, Any]:\n        \"\"\"ایجاد مخاطب در حسابفا در صورت عدم وجود\"\"\"\n        try:\n            contact_data = {\n                \"Name\": customer.get(\"name\", \"مشتری\"),\n                \"Code\": customer.get(\"customer_id\", \"\"),\n                \"City\": customer.get(\"city\", \"\"),\n                \"ContactType\": 1,  # 1 = مشتری\n                \"Tag\": \"تلگرام-بات\",\n                \"Notes\": f\"مشتری ثبت شده از طریق ربات تلگرام\"\n            }\n            \n            url = f\"{self.base_url}/contact\"\n            response = requests.post(url, headers=self.headers, json=contact_data)\n            \n            if response.status_code == 200:\n                result = response.json()\n                if result.get(\"Success\"):\n                    logger.info(f\"✅ مخاطب جدید در حسابفا ثبت شد: {customer.get('name')}\")\n                    return {\n                        \"success\": True,\n                        \"contact_id\": result.get(\"Result\", {}).get(\"Id\")\n                    }\n                else:\n                    # اگر مخاطب از قبل وجود داشت، خطا نیست\n                    logger.info(f\"ℹ️ مخاطب قبلاً در حسابفا وجود داشت: {customer.get('name')}\")\n                    return {\"success\": True}\n            else:\n                logger.warning(f\"⚠️ مشکل در ایجاد مخاطب: HTTP {response.status_code}\")\n                return {\"success\": False}\n                \n        except Exception as e:\n            logger.error(f\"❌ خطا در ایجاد مخاطب: {e}\")\n            return {\"success\": False}\n    \n    async def get_invoice_status(self, invoice_id: str) -> Dict[str, Any]:\n        \"\"\"دریافت وضعیت فاکتور از حسابفا\"\"\"\n        try:\n            url = f\"{self.base_url}/invoice/{invoice_id}\"\n            response = requests.get(url, headers=self.headers)\n            \n            if response.status_code == 200:\n                result = response.json()\n                if result.get(\"Success\"):\n                    return {\n                        \"success\": True,\n                        \"invoice\": result.get(\"Result\")\n                    }\n            \n            return {\"success\": False}\n            \n        except Exception as e:\n            logger.error(f\"خطا در دریافت وضعیت فاکتور: {e}\")\n            return {\"success\": False}\n    \n    async def update_invoice_status(self, invoice_id: str, status: int) -> Dict[str, Any]:\n        \"\"\"به‌روزرسانی وضعیت فاکتور در حسابفا\"\"\"\n        try:\n            # 0 = پیش‌فاکتور، 1 = فاکتور، 2 = پرداخت شده\n            url = f\"{self.base_url}/invoice/{invoice_id}\"\n            data = {\"Status\": status}\n            \n            response = requests.put(url, headers=self.headers, json=data)\n            \n            if response.status_code == 200:\n                result = response.json()\n                if result.get(\"Success\"):\n                    logger.info(f\"✅ وضعیت فاکتور {invoice_id} به‌روزرسانی شد\")\n                    return {\"success\": True}\n            \n            return {\"success\": False}\n            \n        except Exception as e:\n            logger.error(f\"خطا در به‌روزرسانی وضعیت فاکتور: {e}\")\n            return {\"success\": False}\n","size_bytes":10917},"bot/keyboards.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nBot Keyboards\nManages all inline keyboards for the Telegram bot.\n\"\"\"\n\nfrom telegram import InlineKeyboardButton, InlineKeyboardMarkup\nfrom typing import List, Dict, Any\nfrom data.product_data import PERSIAN_ALPHABET, get_category_product_icons, search_products_by_icon\n\n\nclass BotKeyboards:\n    \"\"\"Class to manage all bot keyboards\"\"\"\n\n    def get_main_menu(self,\n                      authenticated: bool = False) -> InlineKeyboardMarkup:\n        \"\"\"Get main menu keyboard\"\"\"\n        buttons = []\n\n        if authenticated:\n            buttons.extend([[\n                InlineKeyboardButton(\"🛒 شروع خرید\",\n                                     callback_data=\"start_shopping\")\n            ], [\n                InlineKeyboardButton(\"🛍️ سبد خرید\", callback_data=\"view_cart\")\n            ],\n                            [\n                                InlineKeyboardButton(\n                                    \"📋 مشاهده پیش فاکتور\",\n                                    callback_data=\"view_invoice\")\n                            ]])\n\n        return InlineKeyboardMarkup(buttons)\n\n    def get_categories_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get main product categories keyboard\"\"\"\n        buttons = [\n            [\n                InlineKeyboardButton(\" کالای خواب نوزاد\",\n                                     callback_data=\"category_baby\")\n            ],\n            [\n                InlineKeyboardButton(\" کالای خواب نوجوان\",\n                                     callback_data=\"category_teen\")\n            ],\n            [\n                InlineKeyboardButton(\"کالای خواب بزرگسال\",\n                                     callback_data=\"category_adult\")\n            ],\n            [\n                InlineKeyboardButton(\" پرده\",\n                                     callback_data=\"category_curtain_only\")\n            ],\n            [InlineKeyboardButton(\" کوسن \", callback_data=\"category_cushion\")],\n            [\n                InlineKeyboardButton(\" فرشینه\",\n                                     callback_data=\"category_tablecloth\")\n            ],\n            [InlineKeyboardButton(\"🏠 منوی اصلی\", callback_data=\"main_menu\")]\n        ]\n        return InlineKeyboardMarkup(buttons)\n\n    def get_curtain_subcategories(self, page: int = 0) -> InlineKeyboardMarkup:\n        \"\"\"Get curtain subcategories keyboard with icon navigation and pagination\"\"\"\n        buttons = []\n\n        # Get product icons for curtain_only category\n        product_icons = get_category_product_icons('curtain_only')\n\n        # Pagination settings\n        items_per_page = 8  # 4 rows * 2 buttons\n        start_idx = page * items_per_page\n        end_idx = start_idx + items_per_page\n        page_icons = product_icons[start_idx:end_idx]\n\n        # Create buttons for each unique icon - 2 buttons per row\n        row = []\n        for i, (icon, description, product_id) in enumerate(page_icons):\n            button_text = description\n            callback_data = f\"product_{product_id}\"\n            row.append(\n                InlineKeyboardButton(button_text, callback_data=callback_data))\n\n            # Create rows of 2 buttons each\n            if (i + 1) % 2 == 0:\n                buttons.append(row)\n                row = []\n\n        # Add remaining button if any\n        if row:\n            buttons.append(row)\n\n        # Add pagination buttons\n        nav_row = []\n        total_pages = (len(product_icons) + items_per_page -\n                       1) // items_per_page\n\n        if page > 0:\n            nav_row.append(\n                InlineKeyboardButton(\"⬅️ صفحه قبل\",\n                                     callback_data=f\"curtain_page_{page-1}\"))\n\n        if page < total_pages - 1:\n            nav_row.append(\n                InlineKeyboardButton(\"➡️ صفحه بعد\",\n                                     callback_data=f\"curtain_page_{page+1}\"))\n\n        if nav_row:\n            buttons.append(nav_row)\n\n        # Add alphabet search button\n        buttons.append([\n            InlineKeyboardButton(\"🔤 جستجوی حروف الفبایی\",\n                                 callback_data=\"alphabet_search_curtain_only\")\n        ])\n\n        # Add back button\n        buttons.append([\n            InlineKeyboardButton(\"🔙 بازگشت\",\n                                 callback_data=\"back_to_categories\")\n        ])\n\n        return InlineKeyboardMarkup(buttons)\n\n    def get_curtain_only_subcategories(self) -> InlineKeyboardMarkup:\n        \"\"\"Get curtain only subcategories keyboard with icon navigation\"\"\"\n        buttons = []\n\n        # Get product icons for curtain_only category\n        product_icons = get_category_product_icons('curtain_only')\n\n        # Create buttons for each unique icon - 2 buttons per row\n        row = []\n        for i, (icon, description, product_id) in enumerate(product_icons):\n            button_text = description\n            callback_data = f\"product_{product_id}\"\n            row.append(\n                InlineKeyboardButton(button_text, callback_data=callback_data))\n\n            # Create rows of 2 buttons each\n            if (i + 1) % 2 == 0:\n                buttons.append(row)\n                row = []\n\n        # Add remaining button if any\n        if row:\n            buttons.append(row)\n\n        # Add alphabet search button\n        buttons.append([\n            InlineKeyboardButton(\"🔤 جستجوی حروف الفبایی\",\n                                 callback_data=\"alphabet_search_curtain_only\")\n        ])\n\n        # Add back button\n        buttons.append([\n            InlineKeyboardButton(\"🔙 بازگشت\",\n                                 callback_data=\"back_to_curtain_subcategories\")\n        ])\n\n        return InlineKeyboardMarkup(buttons)\n\n    def get_cushion_subcategories(self, page: int = 0) -> InlineKeyboardMarkup:\n        \"\"\"Get cushion subcategories keyboard with icon navigation and pagination\"\"\"\n        buttons = []\n\n        # Get product icons for cushion category\n        product_icons = get_category_product_icons('cushion')\n\n        # Pagination settings (کوسن کم محصول دارد - 6 تا)\n        items_per_page = 6  # همه در یک صفحه\n        start_idx = page * items_per_page\n        end_idx = start_idx + items_per_page\n        page_icons = product_icons[start_idx:end_idx]\n\n        # Create buttons for each unique icon - 2 buttons per row\n        row = []\n        for i, (icon, description, product_id) in enumerate(page_icons):\n            button_text = description\n            callback_data = f\"icon_cushion_{icon}\"\n            row.append(\n                InlineKeyboardButton(button_text, callback_data=callback_data))\n\n            # Create rows of 2 buttons each\n            if (i + 1) % 2 == 0:\n                buttons.append(row)\n                row = []\n\n        # Add remaining button if any\n        if row:\n            buttons.append(row)\n\n        # Add pagination buttons (if needed)\n        nav_row = []\n        total_pages = (len(product_icons) + items_per_page -\n                       1) // items_per_page\n\n        if page > 0:\n            nav_row.append(\n                InlineKeyboardButton(\"⬅️ صفحه قبل\",\n                                     callback_data=f\"cushion_page_{page-1}\"))\n\n        if page < total_pages - 1:\n            nav_row.append(\n                InlineKeyboardButton(\"➡️ صفحه بعد\",\n                                     callback_data=f\"cushion_page_{page+1}\"))\n\n        if nav_row:\n            buttons.append(nav_row)\n\n        # Add alphabet search button\n        buttons.append([\n            InlineKeyboardButton(\"🔤 جستجوی حروف الفبایی\",\n                                 callback_data=\"alphabet_search_cushion\")\n        ])\n\n        # Add back button\n        buttons.append([\n            InlineKeyboardButton(\"🔙 بازگشت\",\n                                 callback_data=\"back_to_categories\")\n        ])\n\n        return InlineKeyboardMarkup(buttons)\n\n    def get_baby_subcategories(self, page: int = 0) -> InlineKeyboardMarkup:\n        \"\"\"Get baby subcategories keyboard with icon navigation and pagination\"\"\"\n        buttons = []\n\n        # Get product icons for baby category\n        product_icons = get_category_product_icons('baby')\n\n        # Pagination settings\n        items_per_page = 8  # 4 rows * 2 buttons\n        start_idx = page * items_per_page\n        end_idx = start_idx + items_per_page\n        page_icons = product_icons[start_idx:end_idx]\n\n        # Create buttons for each unique icon - 2 buttons per row\n        row = []\n        for i, (icon, description, product_id) in enumerate(page_icons):\n            button_text = description\n            callback_data = f\"icon_baby_{icon}\"\n            row.append(\n                InlineKeyboardButton(button_text, callback_data=callback_data))\n\n            # Create rows of 2 buttons each\n            if (i + 1) % 2 == 0:\n                buttons.append(row)\n                row = []\n\n        # Add remaining button if any\n        if row:\n            buttons.append(row)\n\n        # Add pagination buttons\n        nav_row = []\n        total_pages = (len(product_icons) + items_per_page -\n                       1) // items_per_page\n\n        if page > 0:\n            nav_row.append(\n                InlineKeyboardButton(\"⬅️ صفحه قبل\",\n                                     callback_data=f\"baby_page_{page-1}\"))\n\n        if page < total_pages - 1:\n            nav_row.append(\n                InlineKeyboardButton(\"➡️ صفحه بعد\",\n                                     callback_data=f\"baby_page_{page+1}\"))\n\n        if nav_row:\n            buttons.append(nav_row)\n\n        # Add alphabet search button\n        buttons.append([\n            InlineKeyboardButton(\"🔤 جستجوی حروف الفبایی\",\n                                 callback_data=\"alphabet_search_baby\")\n        ])\n\n        # Add back button\n        buttons.append([\n            InlineKeyboardButton(\"🔙 بازگشت\",\n                                 callback_data=\"back_to_categories\")\n        ])\n\n        return InlineKeyboardMarkup(buttons)\n\n    def get_teen_subcategories(self) -> InlineKeyboardMarkup:\n        \"\"\"Get teen subcategories keyboard with size selection\"\"\"\n        buttons = [[\n            InlineKeyboardButton(\"📏 انتخاب سایز\",\n                                 callback_data=\"size_selection_teen\")\n        ],\n                   [\n                       InlineKeyboardButton(\"🔙 بازگشت\",\n                                            callback_data=\"back_to_categories\")\n                   ]]\n        return InlineKeyboardMarkup(buttons)\n\n    def get_adult_subcategories(self) -> InlineKeyboardMarkup:\n        \"\"\"Get adult subcategories keyboard with size selection\"\"\"\n        buttons = [[\n            InlineKeyboardButton(\"📏 انتخاب سایز\",\n                                 callback_data=\"size_selection_adult\")\n        ],\n                   [\n                       InlineKeyboardButton(\"🔙 بازگشت\",\n                                            callback_data=\"back_to_categories\")\n                   ]]\n        return InlineKeyboardMarkup(buttons)\n\n    def get_tablecloth_subcategories(self,\n                                     page: int = 0) -> InlineKeyboardMarkup:\n        \"\"\"Get tablecloth subcategories keyboard with icon navigation and pagination\"\"\"\n        buttons = []\n\n        # Get product icons for tablecloth category\n        product_icons = get_category_product_icons('tablecloth')\n\n        # Pagination settings\n        items_per_page = 8  # 4 rows * 2 buttons\n        start_idx = page * items_per_page\n        end_idx = start_idx + items_per_page\n        page_icons = product_icons[start_idx:end_idx]\n\n        # Create buttons for each unique icon - 2 buttons per row\n        row = []\n        for i, (icon, description, product_id) in enumerate(page_icons):\n            button_text = description  # Remove icon from button text\n            callback_data = f\"product_{product_id}\"\n            row.append(\n                InlineKeyboardButton(button_text, callback_data=callback_data))\n\n            # Create rows of 2 buttons each\n            if (i + 1) % 2 == 0:\n                buttons.append(row)\n                row = []\n\n        # Add remaining button if any\n        if row:\n            buttons.append(row)\n\n        # Add pagination buttons\n        nav_row = []\n        total_pages = (len(product_icons) + items_per_page -\n                       1) // items_per_page\n\n        if page > 0:\n            nav_row.append(\n                InlineKeyboardButton(\n                    \"⬅️ صفحه قبل\", callback_data=f\"tablecloth_page_{page-1}\"))\n\n        if page < total_pages - 1:\n            nav_row.append(\n                InlineKeyboardButton(\n                    \"➡️ صفحه بعد\", callback_data=f\"tablecloth_page_{page+1}\"))\n\n        if nav_row:\n            buttons.append(nav_row)\n\n        # Add alphabet search button\n        buttons.append([\n            InlineKeyboardButton(\"🔤 جستجوی حروف الفبایی\",\n                                 callback_data=\"alphabet_search_tablecloth\")\n        ])\n\n        # Add back button\n        buttons.append([\n            InlineKeyboardButton(\"🔙 بازگشت\",\n                                 callback_data=\"back_to_categories\")\n        ])\n\n        return InlineKeyboardMarkup(buttons)\n\n    def get_alphabetical_keyboard(self,\n                                  category: str,\n                                  page: int = 0) -> InlineKeyboardMarkup:\n        \"\"\"Get alphabetical search keyboard with pagination\"\"\"\n        buttons = []\n        row = []\n\n        # Pagination settings\n        letters_per_page = 16  # 4 rows * 4 letters\n        start_idx = page * letters_per_page\n        end_idx = start_idx + letters_per_page\n        page_letters = PERSIAN_ALPHABET[start_idx:end_idx]\n\n        for i, letter in enumerate(page_letters):\n            # Create consistent callback data format\n            callback_data = f\"alpha_{category}_{letter}\"\n            row.append(\n                InlineKeyboardButton(letter, callback_data=callback_data))\n\n            # Create rows of 4 buttons each\n            if (i + 1) % 4 == 0:\n                buttons.append(row)\n                row = []\n\n        # Add remaining buttons if any\n        if row:\n            buttons.append(row)\n\n        # Add pagination buttons\n        nav_row = []\n        total_pages = (len(PERSIAN_ALPHABET) + letters_per_page -\n                       1) // letters_per_page\n\n        if page > 0:\n            nav_row.append(\n                InlineKeyboardButton(\n                    \"⬅️ صفحه قبل\",\n                    callback_data=f\"alpha_page_{category}_{page-1}\"))\n\n        if page < total_pages - 1:\n            nav_row.append(\n                InlineKeyboardButton(\n                    \"➡️ صفحه بعد\",\n                    callback_data=f\"alpha_page_{category}_{page+1}\"))\n\n        if nav_row:\n            buttons.append(nav_row)\n\n        # Add back button\n        buttons.append([\n            InlineKeyboardButton(\"🔙 بازگشت\",\n                                 callback_data=\"back_to_categories\")\n        ])\n\n        return InlineKeyboardMarkup(buttons)\n\n    def get_products_keyboard(self, products: List[Dict],\n                              category: str) -> InlineKeyboardMarkup:\n        \"\"\"Get products list keyboard\"\"\"\n        buttons = []\n\n        for product in products:\n            button_text = product['name']\n            callback_data = f\"product_{product['id']}\"\n            buttons.append([\n                InlineKeyboardButton(button_text, callback_data=callback_data)\n            ])\n\n        # Add navigation buttons\n        buttons.append(\n            [InlineKeyboardButton(\"🏠 منوی اصلی\", callback_data=\"main_menu\")])\n\n        return InlineKeyboardMarkup(buttons)\n\n    def get_category_products_keyboard(self,\n                                       category: str) -> InlineKeyboardMarkup:\n        \"\"\"Get category products keyboard with icons\"\"\"\n        buttons = []\n\n        # Get product icons for this category\n        product_icons = get_category_product_icons(category)\n\n        # Create buttons for each unique icon - 2 buttons per row\n        row = []\n        for i, (icon, description, product_id) in enumerate(product_icons):\n            button_text = description\n            callback_data = f\"product_{product_id}\"\n            row.append(\n                InlineKeyboardButton(button_text, callback_data=callback_data))\n\n            # Create rows of 2 buttons each\n            if (i + 1) % 2 == 0:\n                buttons.append(row)\n                row = []\n\n        # Add remaining button if any\n        if row:\n            buttons.append(row)\n\n        # Add alphabet search button\n        buttons.append([\n            InlineKeyboardButton(\"🔤 جستجوی حروف الفبایی\",\n                                 callback_data=f\"alphabet_search_{category}\")\n        ])\n\n        # Add back button\n        buttons.append([\n            InlineKeyboardButton(\"🔙 بازگشت\",\n                                 callback_data=\"back_to_categories\")\n        ])\n\n        return InlineKeyboardMarkup(buttons)\n\n    def get_size_selection_keyboard(self,\n                                    category: str) -> InlineKeyboardMarkup:\n        \"\"\"Get size selection keyboard based on category\"\"\"\n        if category == 'baby':\n            # Baby category: only 75×160\n            sizes = [\"75×160\"]\n        elif category in ['teen', 'adult']:\n            # Teen and adult: specific sizes as requested\n            if category == 'teen':\n                sizes = [\n                    \"90×200\",\n                    \"100×200\",\n                    \"120×200\",\n                ]\n            else:  # category == 'adult'\n                sizes = [\n                    \"140×200\",\n                    \"160×200\",\n                    \"180×200\",\n                ]\n        elif category == 'tablecloth':\n            # Tablecloth category: custom sizes with different prices\n            sizes = [\"120×80\", \"100×100\", \"100×150\", \"120×180\"]\n        else:\n            # Default sizes for other categories\n            sizes = [\n                \"140×200\",\n                \"160×200\",\n                \"180×200\",\n            ]\n\n        buttons = []\n        row = []\n\n        for i, size in enumerate(sizes):\n            row.append(\n                InlineKeyboardButton(size,\n                                     callback_data=f\"size_{size}_{category}\"))\n\n            # Create rows of 3 buttons each for better layout with more sizes\n            if (i + 1) % 3 == 0:\n                buttons.append(row)\n                row = []\n\n        # Add remaining buttons if any\n        if row:\n            buttons.append(row)\n\n        # Add back button\n        buttons.append([\n            InlineKeyboardButton(\"🔙 بازگشت\",\n                                 callback_data=\"back_to_categories\")\n        ])\n\n        return InlineKeyboardMarkup(buttons)\n\n    def get_sewing_type_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get sewing type selection keyboard for curtains\"\"\"\n        buttons = [[\n            InlineKeyboardButton(\"پانچ\", callback_data=\"sewing_panch\"),\n            InlineKeyboardButton(\"نواردوزی\", callback_data=\"sewing_navardozi\")\n        ],\n                   [\n                       InlineKeyboardButton(\"🔙 بازگشت\",\n                                            callback_data=\"back_to_categories\")\n                   ]]\n        return InlineKeyboardMarkup(buttons)\n\n    def get_fabric_selection_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get fabric selection keyboard for curtains\"\"\"\n        buttons = [[\n            InlineKeyboardButton(\"حریر کتان\",\n                                 callback_data=\"fabric_silk_cotton\"),\n            InlineKeyboardButton(\"مخمل\", callback_data=\"fabric_velvet\")\n        ],\n                   [\n                       InlineKeyboardButton(\n                           \"🔙 بازگشت\", callback_data=\"back_to_sewing_type\")\n                   ]]\n        return InlineKeyboardMarkup(buttons)\n\n    def get_height_input_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get height input keyboard for curtains\"\"\"\n        buttons = [[\n            InlineKeyboardButton(\"🔙 بازگشت\",\n                                 callback_data=\"back_to_fabric_selection\")\n        ]]\n        return InlineKeyboardMarkup(buttons)\n\n    def get_quantity_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get quantity selection keyboard\"\"\"\n        buttons = []\n        row = []\n\n        # Quantities 1-10\n        for i in range(1, 11):\n            row.append(InlineKeyboardButton(str(i), callback_data=f\"qty_{i}\"))\n\n            # Create rows of 5 buttons each\n            if i % 5 == 0:\n                buttons.append(row)\n                row = []\n\n        # Add navigation buttons\n        buttons.append([\n            InlineKeyboardButton(\" بازگشت\", callback_data=\"back_to_products\")\n        ])\n\n        return InlineKeyboardMarkup(buttons)\n\n    def get_payment_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get payment options keyboard\"\"\"\n        buttons = [[\n            InlineKeyboardButton(\" پرداخت نقدی (۳۰٪ تخفیف)\",\n                                 callback_data=\"payment_cash_card\")\n        ],\n                   [\n                       InlineKeyboardButton(\" پرداخت ۶۰ روز (۲۵٪ تخفیف)\",\n                                            callback_data=\"payment_60day_card\")\n                   ],\n                   [\n                       InlineKeyboardButton(\n                           \" پرداخت ۹۰ روز (۲۵٪ تخفیف + ۲۵٪ پیش‌پرداخت)\",\n                           callback_data=\"payment_90day_card\")\n                   ],\n                   [\n                       InlineKeyboardButton(\" بازگشت به سبد خرید\",\n                                            callback_data=\"view_cart\")\n                   ],\n                   [\n                       InlineKeyboardButton(\" منوی اصلی\",\n                                            callback_data=\"main_menu\")\n                   ]]\n        return InlineKeyboardMarkup(buttons)\n\n    def get_cart_management_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get cart management keyboard\"\"\"\n        buttons = [[\n            InlineKeyboardButton(\" مشاهده پیش فاکتور\",\n                                 callback_data=\"view_invoice\")\n        ], [\n            InlineKeyboardButton(\" ادامه خرید\", callback_data=\"start_shopping\")\n        ], [InlineKeyboardButton(\" پاک کردن سبد\", callback_data=\"cart_clear\")\n            ], [InlineKeyboardButton(\" منوی اصلی\", callback_data=\"main_menu\")]]\n        return InlineKeyboardMarkup(buttons)\n\n    def get_payment_type_keyboard(self,\n                                  payment_method: str) -> InlineKeyboardMarkup:\n        \"\"\"Get payment type selection keyboard (Cash vs Check)\"\"\"\n        buttons = [\n            [\n                InlineKeyboardButton(\n                    \" پرداخت نقدی\",\n                    callback_data=f\"payment_type_cash_{payment_method}\")\n            ],\n            [\n                InlineKeyboardButton(\n                    \" پرداخت چکی\",\n                    callback_data=f\"payment_type_check_{payment_method}\")\n            ], [InlineKeyboardButton(\" بازگشت\", callback_data=\"view_invoice\")]\n        ]\n        return InlineKeyboardMarkup(buttons)\n\n    def get_cash_payment_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get cash payment confirmation keyboard\"\"\"\n        buttons = [[\n            InlineKeyboardButton(\" ارسال فیش واریزی\",\n                                 callback_data=\"upload_receipt\")\n        ], [InlineKeyboardButton(\" بازگشت\", callback_data=\"view_invoice\")]]\n        return InlineKeyboardMarkup(buttons)\n\n    def get_check_payment_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get check payment keyboard\"\"\"\n        buttons = [[\n            InlineKeyboardButton(\" ارسال عکس چک\",\n                                 callback_data=\"upload_check_photo\")\n        ],\n                   [\n                       InlineKeyboardButton(\" در حال پیگیری\",\n                                            callback_data=\"check_follow_up\")\n                   ],\n                   [\n                       InlineKeyboardButton(\" بازگشت\",\n                                            callback_data=\"view_invoice\")\n                   ]]\n        return InlineKeyboardMarkup(buttons)\n\n    def get_check_confirmation_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get check confirmation keyboard after admin message\"\"\"\n        buttons = [[\n            InlineKeyboardButton(\"✅ چک را ثبت و ارسال می‌کنم به کارخانه\",\n                                 callback_data=\"confirm_check_submission\")\n        ],\n                   [\n                       InlineKeyboardButton(\"🔄 ارسال عکس چک جدید\",\n                                            callback_data=\"upload_check_photo\")\n                   ]]\n        return InlineKeyboardMarkup(buttons)\n","size_bytes":25416},"bot/order_server.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nOrder Management Server\nسرور مدیریت و پیگیری سفارشات\n\"\"\"\n\nimport json\nimport os\nfrom datetime import datetime\nfrom typing import Dict, List, Optional, Any\nfrom telegram import Bot, InlineKeyboardButton, InlineKeyboardMarkup\nfrom bot.config import Config\nfrom bot.pricing import PricingManager\nfrom bot.hesabfa_integration import HesabfaAPI\nfrom utils.logger import setup_logger\nfrom utils.persian_utils import format_price, persian_numbers\n\nlogger = setup_logger(__name__)\n\nclass OrderStatus:\n    \"\"\"وضعیت‌های مختلف سفارش\"\"\"\n    PENDING = \"pending\"           # در انتظار\n    CONTACTED = \"contacted\"       # تماس گرفته شد\n    CONFIRMED = \"confirmed\"       # تایید شد\n    PREPARING = \"preparing\"       # در حال آماده‌سازی\n    READY = \"ready\"              # آماده ارسال\n    SHIPPED = \"shipped\"          # ارسال شد\n    DELIVERED = \"delivered\"      # تحویل داده شد\n    COMPLETED = \"completed\"      # تکمیل شد\n    CANCELLED = \"cancelled\"      # لغو شد\n\nclass OrderManagementServer:\n    \"\"\"سرور مدیریت سفارشات\"\"\"\n\n    def __init__(self):\n        self.config = Config()\n        self.pricing_manager = PricingManager()\n        self.hesabfa_api = HesabfaAPI()\n        self.orders_dir = \"order_data\"\n        self.bot = None\n\n        # ایجاد دایرکتوری سفارشات\n        os.makedirs(self.orders_dir, exist_ok=True)\n\n        # پیام‌های وضعیت برای مشتری\n        self.status_messages = {\n            OrderStatus.PENDING: \"📋 سفارش شما ثبت شد و در حال بررسی است.\",\n            OrderStatus.CONTACTED: \"🔄 سفارش شما توسط تیم پشتیبانی دکوتین درحال آماده سازی است.\",\n            OrderStatus.CONFIRMED: \"✅ عالیه! سفارش شما توسط تیم پشتیبانی دکوتین تایید شد.\\n📞 به زودی برای هماهنگی ارسال با شما تماس خواهیم گرفت.\\n🏦 سعی در ثبت پیش‌فاکتور در سیستم حسابداری انجام می‌شود.\",\n            OrderStatus.PREPARING: \"🔧 سفارش شما در حال آماده‌سازی است.\",\n            OrderStatus.READY: \"📦 سفارش شما آماده ارسال شد!\",\n            OrderStatus.SHIPPED: \"🚚 از انتخاب شما برای خرید از مجموعه دکوتین ممنونیم و سفارش شما ارسال شد.\",\n            OrderStatus.DELIVERED: \"✅ سفارش شما تحویل داده شد.\",\n            OrderStatus.COMPLETED: \"🎉 کاربر گرامی سفارش شما تکمیل شده و در صف ارسال میباشد.\",\n            OrderStatus.CANCELLED: \"\"  # پیام خاص در متد جداگانه\n        }\n\n    def set_bot(self, bot: Bot):\n        \"\"\"تنظیم bot instance\"\"\"\n        self.bot = bot\n\n    async def generate_order_id(self) -> str:\n        \"\"\"Public method to generate order ID\"\"\"\n        return self._generate_order_id(0)  # Use 0 as default user_id for check orders\n\n    async def save_order(self, order_id: str, user_id: int, customer: dict, cart_items: list, payment_info: dict):\n        \"\"\"Public method to save order\"\"\"\n        order_data = {\n            'order_id': order_id,\n            'user_id': user_id,\n            'customer': customer,\n            'cart_items': cart_items,\n            'payment_info': payment_info,\n            'status': OrderStatus.PENDING,\n            'created_at': datetime.now().isoformat()\n        }\n        await self._save_order(order_data)\n\n    def _get_order_file_path(self, order_id: str) -> str:\n        \"\"\"مسیر فایل سفارش\"\"\"\n        return os.path.join(self.orders_dir, f\"order_{order_id}.json\")\n\n    def _generate_order_id(self, user_id: int) -> str:\n        \"\"\"ایجاد شناسه یکتای سفارش\"\"\"\n        # ایجاد شماره سفارش ساده\n        counter_file = os.path.join(self.orders_dir, \"order_counter.txt\")\n\n        try:\n            # خواندن شماره فعلی\n            if os.path.exists(counter_file):\n                with open(counter_file, 'r') as f:\n                    counter = int(f.read().strip())\n            else:\n                counter = 0\n\n            # افزایش شماره\n            counter += 1\n\n            # ذخیره شماره جدید\n            with open(counter_file, 'w') as f:\n                f.write(str(counter))\n\n            return f\"{counter:05d}\"  # شماره 5 رقمی: 00001, 00002, ...\n\n        except Exception as e:\n            logger.error(f\"خطا در ایجاد شماره سفارش: {e}\")\n            # fallback to timestamp\n            timestamp = datetime.now().strftime(\"%H%M%S\")\n            return f\"ORD{timestamp}\"\n\n    async def create_order(self, user_id: int, customer: Dict, cart_items: List[Dict],\n                          payment_method: str, discount_rate: float = 0, receipt_photo_id: str = None) -> str:\n        \"\"\"ایجاد سفارش جدید\"\"\"\n        try:\n            order_id = self._generate_order_id(user_id)\n\n            # محاسبه قیمت‌ها\n            subtotal = self.pricing_manager.calculate_subtotal(cart_items)\n            discount = self.pricing_manager.calculate_discount(subtotal, discount_rate)\n            tax = self.pricing_manager.calculate_tax(subtotal - discount)\n            total = subtotal - discount + tax\n\n            # ایجاد سفارش\n            order_data = {\n                \"order_id\": order_id,\n                \"user_id\": user_id,\n                \"customer\": customer,\n                \"cart_items\": cart_items,\n                \"payment_method\": payment_method,\n                \"pricing\": {\n                    \"subtotal\": subtotal,\n                    \"discount_rate\": discount_rate,\n                    \"discount\": discount,\n                    \"tax\": tax,\n                    \"total\": total\n                },\n                \"status\": OrderStatus.PENDING,\n                \"created_at\": datetime.now().isoformat(),\n                \"updated_at\": datetime.now().isoformat(),\n                \"status_history\": [\n                    {\n                        \"status\": OrderStatus.PENDING,\n                        \"timestamp\": datetime.now().isoformat(),\n                        \"note\": \"سفارش ایجاد شد\"\n                    }\n                ]\n            }\n\n            # ذخیره سفارش\n            await self._save_order(order_data)\n\n            # ارسال پیش‌فاکتور به گروه پشتیبانی\n            await self._send_invoice_to_support_group(order_data, receipt_photo_id)\n\n            # اطلاع‌رسانی به مشتری\n            await self._notify_customer(user_id, OrderStatus.PENDING, order_id)\n\n            logger.info(f\"سفارش جدید ایجاد شد: {order_id}\")\n            return order_id\n\n        except Exception as e:\n            logger.error(f\"خطا در ایجاد سفارش: {e}\")\n            raise\n\n    async def _save_order(self, order_data_or_id, order_data=None):\n        \"\"\"ذخیره سفارش در فایل\"\"\"\n        if order_data is None:\n            # اگر فقط order_data ارسال شده\n            order_file = self._get_order_file_path(order_data_or_id[\"order_id\"])\n            data_to_save = order_data_or_id\n        else:\n            # اگر order_id و order_data جداگانه ارسال شده\n            order_file = self._get_order_file_path(order_data_or_id)\n            data_to_save = order_data\n\n        try:\n            with open(order_file, 'w', encoding='utf-8') as f:\n                json.dump(data_to_save, f, ensure_ascii=False, indent=2)\n            return True\n        except Exception as e:\n            logger.error(f\"خطا در ذخیره سفارش: {e}\")\n            return False\n\n    async def _send_invoice_to_support_group(self, order_data: Dict, receipt_photo_id: str = None):\n        \"\"\"ارسال پیش‌فاکتور به گروه پشتیبانی\"\"\"\n        if not self.bot:\n            logger.warning(\"❌ Bot instance تنظیم نشده است\")\n            return\n\n        if not self.config.order_group_chat_id:\n            logger.warning(\"❌ گروه پشتیبانی تنظیم نشده است\")\n            return\n\n        try:\n            # بررسی دسترسی به گروه\n            try:\n                chat_info = await self.bot.get_chat(self.config.order_group_chat_id)\n                logger.info(f\"✅ دسترسی به گروه تایید شد: {chat_info.title}\")\n            except Exception as chat_error:\n                logger.error(f\"❌ عدم دسترسی به گروه {self.config.order_group_chat_id}: {chat_error}\")\n                return\n\n            # ایجاد پیش‌فاکتور\n            invoice_text = self._generate_invoice_text(order_data)\n\n            # دکمه‌های مدیریت سفارش\n            keyboard = self._create_admin_buttons(order_data[\"order_id\"], order_data[\"user_id\"])\n\n            # اگر عکس فیش وجود دارد، ابتدا آن را ارسال کن\n            if receipt_photo_id:\n                try:\n                    photo_message = await self.bot.send_photo(\n                        chat_id=self.config.order_group_chat_id,\n                        photo=receipt_photo_id,\n                        caption=\"📸 فیش واریزی مشتری\"\n                    )\n                    logger.info(f\"✅ عکس فیش ارسال شد - Message ID: {photo_message.message_id}\")\n                except Exception as photo_error:\n                    logger.error(f\"❌ خطا در ارسال عکس فیش: {photo_error}\")\n                    # ادامه دادن حتی اگر عکس ارسال نشود\n\n            # ارسال فاکتور به گروه\n            sent_message = await self.bot.send_message(\n                chat_id=self.config.order_group_chat_id,\n                text=invoice_text,\n                reply_markup=InlineKeyboardMarkup(keyboard)\n            )\n\n            logger.info(f\"✅ پیش‌فاکتور سفارش {order_data['order_id']} به گروه ارسال شد\")\n            logger.info(f\"   Group ID: {self.config.order_group_chat_id}\")\n            logger.info(f\"   Message ID: {sent_message.message_id}\")\n\n        except Exception as e:\n            logger.error(f\"❌ خطا در ارسال پیش‌فاکتور به گروه: {e}\")\n            logger.error(f\"   Order ID: {order_data.get('order_id', 'Unknown')}\")\n            logger.error(f\"   Group ID: {self.config.order_group_chat_id}\")\n            logger.error(f\"   Error type: {type(e).__name__}\")\n\n            # ارسال اطلاعات بیشتر برای دیباگ\n            if hasattr(e, 'message'):\n                logger.error(f\"   Error message: {e.message}\")\n\n            # حتی اگر ارسال به گروه ناموفق باشد، ادامه پردازش\n\n    def _generate_invoice_text(self, order_data: Dict) -> str:\n        \"\"\"تولید متن پیش‌فاکتور\"\"\"\n        customer = order_data[\"customer\"]\n        cart_items = order_data[\"cart_items\"]\n        pricing = order_data[\"pricing\"]\n\n        invoice_text = (\n            f\"🆕 سفارش جدید - شماره: {order_data['order_id']}\\n\"\n            f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n            f\"👤 نام مشتری: {customer['name']}\\n\"\n            f\"🏙️ شهر: {customer['city']}\\n\"\n            f\"🆔 کد نمایندگی: {customer['customer_id']}\\n\"\n            f\"📱 شناسه کاربر: {order_data['user_id']}\\n\"\n            f\"💳 روش پرداخت: {order_data['payment_method']}\\n\"\n            f\"⏰ زمان ثبت: {persian_numbers('1404/05/14')} - {persian_numbers(datetime.fromisoformat(order_data['created_at']).strftime('%H:%M'))}\\n\\n\"\n            f\"📋 جزئیات سفارش:\\n\"\n            f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n        )\n\n        # آیتم‌های سفارش\n        for i, item in enumerate(cart_items, 1):\n            item_total = item['price'] * item['quantity']\n            invoice_text += (\n                f\"{persian_numbers(str(i))}. {item['product_name']}\\n\"\n                f\"   📏 سایز: {item['size']}\\n\"\n                f\"   📦 تعداد: {persian_numbers(str(item['quantity']))}\\n\"\n                f\"   💰 قیمت: {format_price(item_total)} تومان\\n\\n\"\n            )\n\n        # جمع‌بندی قیمت\n        invoice_text += (\n            f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n            f\"💰 جمع کل: {format_price(pricing['subtotal'])} تومان\\n\"\n        )\n\n        if pricing['discount'] > 0:\n            invoice_text += f\"🎁 تخفیف ({persian_numbers(str(int(pricing['discount_rate'] * 100)))}٪): {format_price(pricing['discount'])} تومان\\n\"\n\n        invoice_text += (\n            f\"📊 مالیات (۹٪): {format_price(pricing['tax'])} تومان\\n\"\n            f\"💳 مبلغ نهایی: {format_price(pricing['total'])} تومان\\n\\n\"\n            f\"📌 وضعیت: {self._get_status_text(order_data['status'])}\"\n        )\n\n        # اضافه کردن اطلاعات حسابفا در صورت وجود\n        if order_data.get(\"hesabfa_invoice_id\"):\n            invoice_text += (\n                f\"\\n\\n🏦 اطلاعات حسابفا:\\n\"\n                f\"📋 شماره فاکتور: {order_data.get('hesabfa_invoice_number', 'نامشخص')}\\n\"\n                f\"🆔 شناسه فاکتور: {order_data.get('hesabfa_invoice_id')}\"\n            )\n\n        return invoice_text\n\n    def _create_admin_buttons(self, order_id: str, user_id: int) -> List[List[InlineKeyboardButton]]:\n        \"\"\"ایجاد دکمه‌های مدیریت برای ادمین (ساده شده)\"\"\"\n        return [\n            [\n                InlineKeyboardButton(\"✅ تایید سفارش\", callback_data=f\"order_status_{order_id}_confirmed\"),\n                InlineKeyboardButton(\"🔄 در حال پیگیری\", callback_data=f\"order_status_{order_id}_contacted\")\n            ],\n            [\n                InlineKeyboardButton(\"🚚 سفارش ارسال شد\", callback_data=f\"order_status_{order_id}_shipped\"),\n                InlineKeyboardButton(\"🎉 سفارش تکمیل شد\", callback_data=f\"order_status_{order_id}_completed\")\n            ],\n            [\n                InlineKeyboardButton(\"❌ لغو سفارش\", callback_data=f\"order_status_{order_id}_cancelled\")\n            ]\n        ]\n\n    async def update_order_status(self, order_id: str, new_status: str, admin_name: str = \"\") -> bool:\n        \"\"\"به‌روزرسانی وضعیت سفارش با اطلاع‌رسانی به مشتری\"\"\"\n        try:\n            logger.info(f\"🔄 تغییر وضعیت سفارش {order_id} به {new_status} توسط {admin_name}\")\n\n            # بارگذاری اطلاعات سفارش\n            order_data = await self._load_order(order_id)\n            if not order_data:\n                logger.error(f\"❌ سفارش {order_id} یافت نشد\")\n                return False\n\n            # ذخیره وضعیت قبلی\n            previous_status = order_data.get('status', OrderStatus.PENDING)\n\n            # به‌روزرسانی وضعیت\n            order_data['status'] = new_status\n            order_data['updated_at'] = datetime.now().isoformat()\n            order_data['status_history'] = order_data.get('status_history', [])\n\n            # اضافه کردن به تاریخچه\n            order_data['status_history'].append({\n                'status': new_status,\n                'timestamp': datetime.now().isoformat(),\n                'admin': admin_name,\n                'previous_status': previous_status\n            })\n\n            # ذخیره تغییرات\n            success = await self._save_order(order_id, order_data)\n            if not success:\n                logger.error(f\"❌ خطا در ذخیره تغییرات سفارش {order_id}\")\n                return False\n\n            logger.info(f\"✅ وضعیت سفارش {order_id} با موفقیت به {new_status} تغییر کرد\")\n\n            # اطلاع‌رسانی فوری به مشتری\n            user_id = order_data.get('user_id')\n            if user_id:\n                logger.info(f\"📤 شروع اطلاع‌رسانی به مشتری {user_id}\")\n                await self._notify_customer(user_id, new_status, order_id, admin_name)\n\n            # ثبت پیش‌فاکتور در حسابفا بعد از تایید ادمین\n            if new_status == OrderStatus.CONFIRMED and not order_data.get(\"hesabfa_invoice_id\"):\n                logger.info(f\"🔄 شروع ثبت پیش‌فاکتور در حسابفا برای سفارش {order_id}\")\n                import asyncio\n                asyncio.create_task(self._process_hesabfa_invoice(order_id, order_data))\n\n            return True\n\n        except Exception as e:\n            logger.error(f\"❌ خطا در به‌روزرسانی وضعیت سفارش {order_id}: {e}\")\n            return False\n\n    async def _load_order(self, order_id: str) -> Optional[Dict]:\n        \"\"\"بارگیری سفارش از فایل\"\"\"\n        order_file = self._get_order_file_path(order_id)\n\n        try:\n            if os.path.exists(order_file):\n                with open(order_file, 'r', encoding='utf-8') as f:\n                    return json.load(f)\n            return None\n        except Exception as e:\n            logger.error(f\"خطا در بارگیری سفارش {order_id}: {e}\")\n            return None\n\n    async def _process_hesabfa_invoice(self, order_id: str, order_data: Dict):\n        \"\"\"پردازش فاکتور حسابفا به صورت غیرهمزمان\"\"\"\n        try:\n            logger.info(f\"🔄 شروع پردازش فاکتور حسابفا برای سفارش {order_id}\")\n\n            # ابتدا مخاطب را ایجاد کن (در صورت عدم وجود)\n            contact_result = await self.hesabfa_api.create_contact_if_not_exists(order_data[\"customer\"])\n            logger.info(f\"📞 نتیجه ایجاد مخاطب: {contact_result.get('success', False)}\")\n\n            # ایجاد پیش‌فاکتور در حسابفا با timeout کوتاه‌تر\n            hesabfa_result = await self.hesabfa_api.create_invoice(order_data)\n            logger.info(f\"🏦 نتیجه ثبت فاکتور: {hesabfa_result}\")\n\n            # بارگیری مجدد سفارش برای به‌روزرسانی\n            current_order = await self._load_order(order_id)\n            if not current_order:\n                logger.error(f\"❌ خطا در بارگیری مجدد سفارش {order_id}\")\n                return\n\n            if hesabfa_result.get(\"success\"):\n                # ذخیره شناسه فاکتور حسابفا در سفارش\n                current_order[\"hesabfa_invoice_id\"] = hesabfa_result.get(\"invoice_id\")\n                current_order[\"hesabfa_invoice_number\"] = hesabfa_result.get(\"invoice_number\")\n\n                # اضافه کردن به تاریخچه\n                hesabfa_entry = {\n                    \"status\": \"hesabfa_created\",\n                    \"timestamp\": datetime.now().isoformat(),\n                    \"admin\": \"سیستم\",\n                    \"note\": f\"پیش‌فاکتور در حسابفا ثبت شد - شماره: {hesabfa_result.get('invoice_number')}\"\n                }\n                current_order[\"status_history\"].append(hesabfa_entry)\n\n                # ذخیره تغییرات\n                await self._save_order(current_order)\n\n                logger.info(f\"✅ پیش‌فاکتور سفارش {order_id} در حسابفا ثبت شد\")\n                logger.info(f\"   📋 شماره فاکتور: {hesabfa_result.get('invoice_number')}\")\n                logger.info(f\"   🆔 شناسه حسابفا: {hesabfa_result.get('invoice_id')}\")\n                logger.info(f\"   👤 مشتری: {order_data['customer']['name']}\")\n            else:\n                error_message = hesabfa_result.get('error', 'خطای نامشخص')\n                logger.error(f\"❌ خطا در ثبت پیش‌فاکتور حسابفا: {error_message}\")\n\n                # ثبت خطا در تاریخچه\n                error_entry = {\n                    \"status\": \"hesabfa_error\",\n                    \"timestamp\": datetime.now().isoformat(),\n                    \"admin\": \"سیستم\",\n                    \"note\": f\"خطا در ثبت پیش‌فاکتور حسابفا: {error_message}\"\n                }\n                current_order[\"status_history\"].append(error_entry)\n                await self._save_order(current_order)\n\n        except Exception as hesabfa_exception:\n            logger.error(f\"❌ خطای غیرمنتظره در ثبت حسابفا: {hesabfa_exception}\")\n\n            # بارگیری مجدد و ثبت خطا\n            try:\n                current_order = await self._load_order(order_id)\n                if current_order:\n                    error_entry = {\n                        \"status\": \"hesabfa_error\",\n                        \"timestamp\": datetime.now().isoformat(),\n                        \"admin\": \"سیستم\",\n                        \"note\": f\"خطای سیستمی در ثبت پیش‌فاکتور: {str(hesabfa_exception)[:100]}\"\n                    }\n                    current_order[\"status_history\"].append(error_entry)\n                    await self._save_order(current_order)\n            except Exception as save_error:\n                logger.error(f\"❌ خطا در ذخیره خطای حسابفا: {save_error}\")\n\n    async def _notify_customer_async(self, user_id: int, status: str, order_id: str, admin_name: str = \"\"):\n        \"\"\"اطلاع‌رسانی غیرهمزمان به مشتری\"\"\"\n        try:\n            await self._notify_customer(user_id, status, order_id, admin_name)\n        except Exception as e:\n            logger.error(f\"❌ خطا در اطلاع‌رسانی غیرهمزمان: {e}\")\n\n    async def _notify_customer(self, user_id: int, status: str, order_id: str, admin_name: str = \"\"):\n        \"\"\"اطلاع‌رسانی به مشتری\"\"\"\n        if not self.bot:\n            logger.warning(\"Bot instance تنظیم نشده است\")\n            return\n\n        try:\n            logger.info(f\"🔔 شروع اطلاع‌رسانی به مشتری {user_id} برای سفارش {order_id}\")\n\n            # بررسی لغو سفارش برای پیام خاص\n            if status == OrderStatus.CANCELLED:\n                # دریافت اطلاعات مشتری و فاکتور\n                order_data = await self._load_order(order_id)\n                customer_name = \"مشتری گرامی\"\n                total_amount = 0\n                paid_amount = 0\n                remaining_amount = 0\n\n                if order_data and order_data.get('customer'):\n                    customer_name = order_data['customer'].get('name', 'مشتری گرامی')\n                \n                # محاسبه مانده حساب از روی pricing\n                if order_data and order_data.get('pricing'):\n                    from utils.persian_utils import format_price\n                    pricing = order_data['pricing']\n                    total_amount = pricing.get('total', 0)\n                    # فرض کنیم مشتری قسمتی پرداخت کرده (مثل پیش پرداخت)\n                    paid_amount = pricing.get('paid_amount', 0)  # این فیلد باید در آینده اضافه شود\n                    remaining_amount = total_amount - paid_amount\n\n                full_message = (\n                    f\"📋 سفارش شماره: {order_id}\\n\\n\"\n                    f\"از انتخاب شما برای خرید از شرکت دکوتین ممنونیم {customer_name} عزیز\\n\\n\"\n                    f\"سقف اعتبار خرید شما به علت مانده حساب مسدود شده است\\n\\n\"\n                    f\"💰 مبلغ کل فاکتور: {format_price(total_amount)} تومان\\n\"\n                    f\"💳 مبلغ پرداخت شده: {format_price(paid_amount)} تومان\\n\"\n                    f\"📊 مانده حساب: {format_price(remaining_amount)} تومان\\n\\n\"\n                    f\"لطفا مانده حساب خود را واریز نمایید و با ارسال فیش ادامه خرید خود را انجام دهید\\n\\n\"\n                    f\"با تشکر\\n\"\n                    f\"مجموعه دکوتین 🌟\"\n                )\n            else:\n                message = self.status_messages.get(status, f\"وضعیت سفارش شما به {status} تغییر کرد.\")\n\n                # افزودن شماره سفارش\n                full_message = (\n                    f\"📋 سفارش شماره: {order_id}\\n\"\n                    f\"{message}\\n\"\n                )\n\n                if admin_name and status != OrderStatus.PENDING:\n                    full_message += f\"\\n👤 توسط: {admin_name}\"\n\n            # دکمه‌های کمکی برای ارتباط با پشتیبانی\n            is_cancelled = (status == OrderStatus.CANCELLED)\n            keyboard = self._create_customer_support_buttons(order_id, is_cancelled)\n\n            # ارسال پیام با retry\n            max_retries = 3\n            for attempt in range(max_retries):\n                try:\n                    await self.bot.send_message(\n                        chat_id=user_id,\n                        text=full_message,\n                        reply_markup=InlineKeyboardMarkup(keyboard)\n                    )\n                    logger.info(f\"✅ اطلاع‌رسانی وضعیت {status} به مشتری {user_id} ارسال شد\")\n                    return\n                except Exception as send_error:\n                    logger.warning(f\"⚠️ تلاش {attempt + 1} ناموفق: {send_error}\")\n                    if attempt == max_retries - 1:\n                        # آخرین تلاش با پیام ساده\n                        simple_message = f\"📋 سفارش {order_id} به‌روزرسانی شد.\"\n                        await self.bot.send_message(\n                            chat_id=user_id,\n                            text=simple_message\n                        )\n                        logger.info(f\"✅ پیام ساده به مشتری {user_id} ارسال شد\")\n\n        except Exception as e:\n            logger.error(f\"❌ خطا در اطلاع‌رسانی به مشتری {user_id}: {e}\")\n            logger.error(f\"   سفارش: {order_id}, وضعیت: {status}\")\n            logger.error(f\"   خطای کامل: {str(e)}\")\n\n            # تلاش نهایی برای ارسال پیام بسیار ساده\n            try:\n                await self.bot.send_message(\n                    chat_id=user_id,\n                    text=f\"سفارش {order_id} به‌روزرسانی شد.\"\n                )\n                logger.info(f\"✅ پیام اضطراری به مشتری {user_id} ارسال شد\")\n            except:\n                logger.error(f\"❌ حتی پیام اضطراری نیز ارسال نشد\")\n\n    def _create_customer_support_buttons(self, order_id: str, is_cancelled: bool = False) -> List[List[InlineKeyboardButton]]:\n        \"\"\"Create customer support buttons for order status\"\"\"\n        if is_cancelled:\n            # برای سفارشات لغو شده فقط دو دکمه نمایش داده شود\n            return [\n                [\n                    InlineKeyboardButton(\"📞 تماس با پشتیبانی\", callback_data=\"contact_support\"),\n                    InlineKeyboardButton(\"💳 واریز مانده حساب\", callback_data=f\"pay_remaining_{order_id}\")\n                ]\n            ]\n        else:\n            # برای سایر سفارشات دکمه‌های عادی\n            return [\n                [\n                    InlineKeyboardButton(\"📋 وضعیت سفارش\", callback_data=f\"check_order_status_{order_id}\"),\n                    InlineKeyboardButton(\"📞 تماس با پشتیبانی\", callback_data=\"contact_support\")\n                ],\n                [\n                    InlineKeyboardButton(\"❓ سوالات متداول\", callback_data=\"faq\")\n                ]\n            ]\n\n    def _get_status_text(self, status: str) -> str:\n        \"\"\"متن فارسی وضعیت\"\"\"\n        status_texts = {\n            OrderStatus.PENDING: \"در انتظار\",\n            OrderStatus.CONTACTED: \"در حال پیگیری\",\n            OrderStatus.CONFIRMED: \"تایید شد\",\n            OrderStatus.PREPARING: \"در حال آماده‌سازی\",\n            OrderStatus.READY: \"آماده ارسال\",\n            OrderStatus.SHIPPED: \"ارسال شد\",\n            OrderStatus.DELIVERED: \"تحویل داده شد\",\n            OrderStatus.COMPLETED: \"تکمیل شد\",\n            OrderStatus.CANCELLED: \"لغو شد\"\n        }\n        return status_texts.get(status, status)\n\n    async def get_order_details(self, order_id: str) -> Optional[Dict]:\n        \"\"\"دریافت جزئیات سفارش\"\"\"\n        return await self._load_order(order_id)\n\n    async def get_customer_orders(self, user_id: int) -> List[Dict]:\n        \"\"\"دریافت تمام سفارشات یک مشتری\"\"\"\n        orders = []\n\n        try:\n            for filename in os.listdir(self.orders_dir):\n                if filename.startswith(f\"order_{user_id}_\") and filename.endswith(\".json\"):\n                    order_id = filename.replace(\"order_\", \"\").replace(\".json\", \"\")\n                    order_data = await self._load_order(order_id)\n                    if order_data:\n                        orders.append(order_data)\n\n            # مرتب‌سازی بر اساس تاریخ ایجاد (جدیدترین اول)\n            orders.sort(key=lambda x: x[\"created_at\"], reverse=True)\n            return orders\n\n        except Exception as e:\n            logger.error(f\"خطا در دریافت سفارشات مشتری {user_id}: {e}\")\n            return []\n\n    async def get_all_orders(self, status_filter: str = None) -> List[Dict]:\n        \"\"\"دریافت تمام سفارشات (برای ادمین)\"\"\"\n        orders = []\n\n        try:\n            for filename in os.listdir(self.orders_dir):\n                if filename.startswith(\"order_\") and filename.endswith(\".json\"):\n                    order_id = filename.replace(\"order_\", \"\").replace(\".json\", \"\")\n                    order_data = await self._load_order(order_id)\n                    if order_data:\n                        if status_filter is None or order_data[\"status\"] == status_filter:\n                            orders.append(order_data)\n\n            # مرتب‌سازی بر اساس تاریخ ایجاد (جدیدترین اول)\n            orders.sort(key=lambda x: x[\"created_at\"], reverse=True)\n            return orders\n\n        except Exception as e:\n            logger.error(f\"خطا در دریافت تمام سفارشات: {e}\")\n            return []\n\n    async def send_support_contact_info(self, user_id: int):\n        \"\"\"ارسال اطلاعات تماس پشتیبانی\"\"\"\n        if not self.bot:\n            return\n\n        try:\n            contact_message = (\n                \"📞 اطلاعات تماس پشتیبانی\\n\\n\"\n                \"🕐 ساعات کاری: شنبه تا پنج‌شنبه - ۹ صبح تا ۶ عصر\\n\"\n                \"📞 تلفن: ۰۲۱-۱۲۳۴۵۶۷۸\\n\"\n                \"📱 واتساپ: ۰۹۱۲۳۴۵۶۷۸۹\\n\"\n                \"✉️ ایمیل: support@example.com\\n\\n\"\n                \"⚡ پاسخگویی سریع در ساعات کاری\"\n            )\n\n            keyboard = [[\n                InlineKeyboardButton(\"🏠 منوی اصلی\", callback_data=\"main_menu\")\n            ]]\n\n            await self.bot.send_message(\n                chat_id=user_id,\n                text=contact_message,\n                reply_markup=InlineKeyboardMarkup(keyboard)\n            )\n\n        except Exception as e:\n            logger.error(f\"خطا در ارسال اطلاعات تماس: {e}\")\n\n    async def send_faq(self, user_id: int):\n        \"\"\"ارسال سوالات متداول\"\"\"\n        if not self.bot:\n            return\n\n        try:\n            faq_message = (\n                \"❓ سوالات متداول\\n\\n\"\n                \"🔸 چقدر طول می‌کشد تا سفارش آماده شود؟\\n\"\n                \"معمولاً ۳ تا ۵ روز کاری\\n\\n\"\n                \"🔸 هزینه ارسال چقدر است؟\\n\"\n                \"برای سفارشات بالای ۵ میلیون تومان رایگان\\n\\n\"\n                \"🔸 آیا امکان تغییر یا لغو سفارش وجود دارد؟\\n\"\n                \"تا قبل از آماده‌سازی امکان‌پذیر است\\n\\n\"\n                \"🔸 چگونه می‌توانم وضعیت سفارش را پیگیری کنم؟\\n\"\n                \"از طریق همین ربات یا تماس با پشتیبانی\"\n            )\n\n            keyboard = [\n                [InlineKeyboardButton(\"📞 تماس با پشتیبانی\", callback_data=\"contact_support\")],\n                [InlineKeyboardButton(\"🏠 منوی اصلی\", callback_data=\"main_menu\")]\n            ]\n\n            await self.bot.send_message(\n                chat_id=user_id,\n                text=faq_message,\n                reply_markup=InlineKeyboardMarkup(keyboard)\n            )\n\n        except Exception as e:\n            logger.error(f\"خطا در ارسال سوالات متداول: {e}\")\n\n    async def get_todays_orders(self) -> List[Dict]:\n        \"\"\"دریافت سفارشات امروز\"\"\"\n        today_orders = []\n        today_date = datetime.now().strftime(\"%Y-%m-%d\")\n\n        try:\n            for filename in os.listdir(self.orders_dir):\n                if filename.startswith(\"order_\") and filename.endswith(\".json\"):\n                    order_id = filename.replace(\"order_\", \"\").replace(\".json\", \"\")\n                    order_data = await self._load_order(order_id)\n\n                    if order_data:\n                        # بررسی تاریخ ایجاد سفارش\n                        order_date = order_data.get('created_at', '')[:10]\n                        if order_date == today_date:\n                            today_orders.append(order_data)\n\n            # مرتب‌سازی بر اساس زمان ایجاد (جدیدترین اول)\n            today_orders.sort(key=lambda x: x.get('created_at', ''), reverse=True)\n            return today_orders\n\n        except Exception as e:\n            logger.error(f\"خطا در دریافت سفارشات امروز: {e}\")\n            return []\n\n    async def get_orders_by_date(self, target_date: str) -> List[Dict]:\n        \"\"\"دریافت سفارشات بر اساس تاریخ (فرمت: YYYY-MM-DD)\"\"\"\n        date_orders = []\n\n        try:\n            for filename in os.listdir(self.orders_dir):\n                if filename.startswith(\"order_\") and filename.endswith(\".json\"):\n                    order_id = filename.replace(\"order_\", \"\").replace(\".json\", \"\")\n                    order_data = await self._load_order(order_id)\n\n                    if order_data:\n                        order_date = order_data.get('created_at', '')[:10]\n                        if order_date == target_date:\n                            date_orders.append(order_data)\n\n            # مرتب‌سازی بر اساس زمان ایجاد\n            date_orders.sort(key=lambda x: x.get('created_at', ''))\n            return date_orders\n\n        except Exception as e:\n            logger.error(f\"خطا در دریافت سفارشات تاریخ {target_date}: {e}\")\n            return []\n\n    async def get_orders_statistics(self) -> Dict:\n        \"\"\"دریافت آمار کلی سفارشات\"\"\"\n        try:\n            all_orders = await self.get_all_orders()\n            today_orders = await self.get_todays_orders()\n\n            # آمار کلی\n            total_orders = len(all_orders)\n            today_count = len(today_orders)\n\n            # آمار وضعیت\n            status_stats = {}\n            total_revenue = 0\n            today_revenue = 0\n\n            for order in all_orders:\n                status = order.get('status', 'pending')\n                status_text = self._get_status_text(status)\n                status_stats[status_text] = status_stats.get(status_text, 0) + 1\n                total_revenue += order.get('pricing', {}).get('total', 0)\n\n            for order in today_orders:\n                today_revenue += order.get('pricing', {}).get('total', 0)\n\n            return {\n                'total_orders': total_orders,\n                'today_orders': today_count,\n                'total_revenue': total_revenue,\n                'today_revenue': today_revenue,\n                'status_distribution': status_stats\n            }\n\n        except Exception as e:\n            logger.error(f\"خطا در محاسبه آمار: {e}\")\n            return {}","size_bytes":37322},"bot/payment_reminder.py":{"content":"\n#!/usr/bin/env python3\n\"\"\"\nPayment Reminder System\nAutomated system to send monthly payment reminders for 90-day payment plans.\n\"\"\"\n\nimport asyncio\nfrom datetime import datetime\nfrom telegram import Bot, InlineKeyboardButton, InlineKeyboardMarkup\nfrom bot.payment_scheduler import PaymentScheduler\nfrom bot.config import Config\nfrom utils.logger import setup_logger\n\nlogger = setup_logger(__name__)\n\nclass PaymentReminderBot:\n    \"\"\"Automated payment reminder system\"\"\"\n    \n    def __init__(self, config: Config):\n        self.config = config\n        self.bot = Bot(token=config.bot_token)\n        self.payment_scheduler = PaymentScheduler()\n    \n    async def send_daily_reminders(self):\n        \"\"\"Check and send daily payment reminders\"\"\"\n        try:\n            pending_reminders = self.payment_scheduler.get_pending_reminders()\n            \n            if not pending_reminders:\n                logger.info(\"No payment reminders due today\")\n                return\n            \n            logger.info(f\"Found {len(pending_reminders)} payment reminders to send\")\n            \n            for reminder in pending_reminders:\n                await self._send_reminder_to_group(reminder)\n                \n        except Exception as e:\n            logger.error(f\"Error sending daily reminders: {e}\")\n    \n    async def _send_reminder_to_group(self, reminder_info):\n        \"\"\"Send payment reminder to order group\"\"\"\n        try:\n            message = self.payment_scheduler.generate_reminder_message(reminder_info)\n            \n            # Create keyboard for payment confirmation\n            keyboard = [\n                [\n                    InlineKeyboardButton(\n                        \"✅ پرداخت انجام شد\",\n                        callback_data=f\"payment_confirmed_{reminder_info['schedule_id']}_{reminder_info['payment_number']}\"\n                    )\n                ],\n                [\n                    InlineKeyboardButton(\n                        \"📞 تماس گرفته شد\",\n                        callback_data=f\"contact_made_{reminder_info['schedule_id']}_{reminder_info['payment_number']}\"\n                    )\n                ],\n                [\n                    InlineKeyboardButton(\n                        \"⏰ یادآوری فردا\",\n                        callback_data=f\"remind_tomorrow_{reminder_info['schedule_id']}_{reminder_info['payment_number']}\"\n                    )\n                ]\n            ]\n            \n            await self.bot.send_message(\n                chat_id=self.config.order_group_chat_id,\n                text=message,\n                reply_markup=InlineKeyboardMarkup(keyboard)\n            )\n            \n            logger.info(f\"Sent payment reminder for user {reminder_info['user_id']}\")\n            \n        except Exception as e:\n            logger.error(f\"Error sending reminder to group: {e}\")\n    \n    async def handle_payment_confirmation(self, schedule_id: str, payment_number: int):\n        \"\"\"Handle payment confirmation from group admin\"\"\"\n        try:\n            success = self.payment_scheduler.mark_payment_made(schedule_id, payment_number)\n            \n            if success:\n                logger.info(f\"Payment {payment_number} confirmed for schedule {schedule_id}\")\n                return \"✅ پرداخت با موفقیت ثبت شد!\"\n            else:\n                logger.error(f\"Failed to confirm payment {payment_number} for schedule {schedule_id}\")\n                return \"❌ خطا در ثبت پرداخت\"\n                \n        except Exception as e:\n            logger.error(f\"Error handling payment confirmation: {e}\")\n            return \"❌ خطا در ثبت پرداخت\"\n\nasync def run_daily_reminder_check():\n    \"\"\"Function to run daily reminder check\"\"\"\n    config = Config()\n    reminder_bot = PaymentReminderBot(config)\n    await reminder_bot.send_daily_reminders()\n\nif __name__ == \"__main__\":\n    # Run daily reminder check\n    asyncio.run(run_daily_reminder_check())\n","size_bytes":4009},"bot/payment_scheduler.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nPayment Scheduler for 90-day Payment Plans\nManages monthly reminders for remaining payments.\n\"\"\"\n\nimport json\nimport os\nfrom datetime import datetime, timedelta\nfrom typing import Dict, List, Any, Optional\nfrom utils.logger import setup_logger\nfrom utils.persian_utils import format_price, persian_numbers\n\nlogger = setup_logger(__name__)\n\nclass PaymentScheduler:\n    \"\"\"Manages payment schedules and monthly reminders\"\"\"\n\n    def __init__(self, data_dir: str = \"payment_data\"):\n        self.data_dir = data_dir\n        os.makedirs(self.data_dir, exist_ok=True)\n        self.payment_file = os.path.join(self.data_dir, \"payment_schedules.json\")\n\n    def _load_payment_schedules(self) -> Dict[str, Any]:\n        \"\"\"Load payment schedules from file\"\"\"\n        try:\n            if os.path.exists(self.payment_file):\n                with open(self.payment_file, 'r', encoding='utf-8') as f:\n                    return json.load(f)\n            return {}\n        except Exception as e:\n            logger.error(f\"Error loading payment schedules: {e}\")\n            return {}\n\n    def _save_payment_schedules(self, schedules: Dict[str, Any]) -> bool:\n        \"\"\"Save payment schedules to file\"\"\"\n        try:\n            with open(self.payment_file, 'w', encoding='utf-8') as f:\n                json.dump(schedules, f, ensure_ascii=False, indent=2, default=str)\n            return True\n        except Exception as e:\n            logger.error(f\"Error saving payment schedules: {e}\")\n            return False\n\n    def add_60day_payment_schedule(self, user_id: int, customer_info: Dict[str, Any], \n                                 total_amount: float, advance_paid: float, \n                                 remaining_amount: float, order_id: str) -> bool:\n        \"\"\"Add a new 60-day payment schedule\"\"\"\n        schedules = self._load_payment_schedules()\n\n        # Calculate payment date (60 days from now)\n        today = datetime.now()\n        payment_date = (today + timedelta(days=60)).strftime(\"%Y-%m-%d\")\n\n        schedule_id = f\"{user_id}_{order_id}_{int(today.timestamp())}\"\n\n        payment_schedule = {\n            'user_id': user_id,\n            'customer_info': customer_info,\n            'order_id': order_id,\n            'total_amount': total_amount,\n            'advance_paid': advance_paid,\n            'remaining_amount': remaining_amount,\n            'payment_date': payment_date,\n            'payment_type': '60day',\n            'payments_made': [],\n            'created_date': today.strftime(\"%Y-%m-%d\"),\n            'status': 'active'\n        }\n\n        schedules[schedule_id] = payment_schedule\n\n        if self._save_payment_schedules(schedules):\n            logger.info(f\"Added 60-day payment schedule for user {user_id}, order {order_id}\")\n            return True\n        return False\n\n    def add_90day_payment_schedule(self, user_id: int, customer_info: Dict[str, Any], \n                                 total_amount: float, advance_paid: float, \n                                 remaining_amount: float, order_id: str) -> bool:\n        \"\"\"Add a new 90-day payment schedule\"\"\"\n        schedules = self._load_payment_schedules()\n\n        # Calculate monthly payments (remaining amount / 3 months)\n        monthly_amount = remaining_amount / 3\n\n        # Calculate payment dates\n        today = datetime.now()\n        payment_dates = [\n            (today + timedelta(days=30)).strftime(\"%Y-%m-%d\"),\n            (today + timedelta(days=60)).strftime(\"%Y-%m-%d\"),\n            (today + timedelta(days=90)).strftime(\"%Y-%m-%d\")\n        ]\n\n        schedule_id = f\"{user_id}_{order_id}_{int(today.timestamp())}\"\n\n        payment_schedule = {\n            'user_id': user_id,\n            'customer_info': customer_info,\n            'order_id': order_id,\n            'total_amount': total_amount,\n            'advance_paid': advance_paid,\n            'remaining_amount': remaining_amount,\n            'monthly_amount': monthly_amount,\n            'payment_dates': payment_dates,\n            'payments_made': [],\n            'created_date': today.strftime(\"%Y-%m-%d\"),\n            'status': 'active'\n        }\n\n        schedules[schedule_id] = payment_schedule\n\n        if self._save_payment_schedules(schedules):\n            logger.info(f\"Added 90-day payment schedule for user {user_id}, order {order_id}\")\n            return True\n        return False\n\n    def get_pending_reminders(self) -> List[Dict[str, Any]]:\n        \"\"\"Get list of users who need payment reminders today\"\"\"\n        schedules = self._load_payment_schedules()\n        today = datetime.now().strftime(\"%Y-%m-%d\")\n        pending_reminders = []\n\n        for schedule_id, schedule in schedules.items():\n            if schedule['status'] != 'active':\n                continue\n\n            payment_type = schedule.get('payment_type', '90day')\n            \n            if payment_type == '60day':\n                # For 60-day payments: single payment date\n                payment_date = schedule['payment_date']\n                if payment_date == today and not schedule['payments_made']:\n                    reminder_info = {\n                        'schedule_id': schedule_id,\n                        'user_id': schedule['user_id'],\n                        'customer_info': schedule['customer_info'],\n                        'payment_number': 1,\n                        'payment_amount': schedule['remaining_amount'],\n                        'payment_type': '60day',\n                        'payment_date': payment_date\n                    }\n                    pending_reminders.append(reminder_info)\n            else:\n                # For 90-day payments: multiple payment dates\n                for i, payment_date in enumerate(schedule['payment_dates']):\n                    if payment_date == today:\n                        # Check if this payment hasn't been made yet\n                        if i not in schedule['payments_made']:\n                            reminder_info = {\n                                'schedule_id': schedule_id,\n                                'user_id': schedule['user_id'],\n                                'customer_info': schedule['customer_info'],\n                                'payment_number': i + 1,\n                                'monthly_amount': schedule['monthly_amount'],\n                                'remaining_payments': 3 - len(schedule['payments_made']),\n                                'payment_type': '90day',\n                                'payment_date': payment_date\n                            }\n                            pending_reminders.append(reminder_info)\n\n        return pending_reminders\n\n    def mark_payment_made(self, schedule_id: str, payment_number: int) -> bool:\n        \"\"\"Mark a payment as completed\"\"\"\n        schedules = self._load_payment_schedules()\n\n        if schedule_id not in schedules:\n            logger.error(f\"Schedule {schedule_id} not found\")\n            return False\n\n        schedule = schedules[schedule_id]\n        payment_type = schedule.get('payment_type', '90day')\n\n        if payment_type == '60day':\n            # For 60-day payments: mark as completed immediately\n            schedule['payments_made'] = [0]  # Single payment made\n            schedule['status'] = 'completed'\n        else:\n            # For 90-day payments: add payment to made payments list\n            if payment_number - 1 not in schedule['payments_made']:\n                schedule['payments_made'].append(payment_number - 1)\n                schedule['payments_made'].sort()\n\n            # Check if all payments are completed\n            if len(schedule['payments_made']) >= 3:\n                schedule['status'] = 'completed'\n\n        if self._save_payment_schedules(schedules):\n            logger.info(f\"Marked payment {payment_number} as completed for schedule {schedule_id}\")\n            return True\n        return False\n\n    def get_user_payment_schedules(self, user_id: int) -> List[Dict[str, Any]]:\n        \"\"\"Get all payment schedules for a specific user\"\"\"\n        schedules = self._load_payment_schedules()\n        user_schedules = []\n\n        for schedule_id, schedule in schedules.items():\n            if schedule['user_id'] == user_id:\n                user_schedules.append({\n                    'schedule_id': schedule_id,\n                    **schedule\n                })\n\n        return user_schedules\n\n    def generate_reminder_message(self, reminder_info: Dict[str, Any]) -> str:\n        \"\"\"Generate reminder message for payment\"\"\"\n        customer = reminder_info['customer_info']\n        payment_type = reminder_info.get('payment_type', '90day')\n        \n        if payment_type == '60day':\n            amount = reminder_info['payment_amount']\n            message = [\n                \"🔔 یادآوری پرداخت 60 روزه\",\n                \"=\" * 30,\n                \"\",\n                f\"👤 مشتری: {customer['name']}\",\n                f\"🏙️ شهر: {customer['city']}\",\n                f\"🆔 کد مشتری: {customer['customer_id']}\",\n                \"\",\n                f\"💰 مبلغ باقی‌مانده: {format_price(amount)} تومان\",\n                f\"📅 سررسید پرداخت: امروز\",\n                \"\",\n                \"📞 لطفاً با مشتری تماس بگیرید تا پرداخت کامل را انجام دهد.\",\n                \"\",\n                \"برای ثبت پرداخت از دکمه‌های زیر استفاده کنید:\"\n            ]\n        else:\n            payment_num = reminder_info['payment_number']\n            amount = reminder_info['monthly_amount']\n            remaining = reminder_info['remaining_payments']\n            \n            message = [\n                \"🔔 یادآوری پرداخت قسط ماهانه\",\n                \"=\" * 30,\n                \"\",\n                f\"👤 مشتری: {customer['name']}\",\n                f\"🏙️ شهر: {customer['city']}\",\n                f\"🆔 کد مشتری: {customer['customer_id']}\",\n                \"\",\n                f\"📅 قسط شماره: {persian_numbers(str(payment_num))} از ۳\",\n                f\"💰 مبلغ قسط: {format_price(amount)} تومان\",\n                f\"📊 اقساط باقی‌مانده: {persian_numbers(str(remaining - 1))}\",\n                \"\",\n                \"📞 لطفاً با مشتری تماس بگیرید تا پرداخت را انجام دهد.\",\n                \"\",\n                \"برای ثبت پرداخت از دکمه‌های زیر استفاده کنید:\"\n            ]\n\n        return \"\\n\".join(message)\n\n    def cancel_payment_schedule(self, schedule_id: str) -> bool:\n        \"\"\"Cancel a payment schedule\"\"\"\n        schedules = self._load_payment_schedules()\n\n        if schedule_id not in schedules:\n            logger.error(f\"Schedule {schedule_id} not found\")\n            return False\n\n        schedules[schedule_id]['status'] = 'cancelled'\n\n        if self._save_payment_schedules(schedules):\n            logger.info(f\"Cancelled payment schedule {schedule_id}\")\n            return True\n        return False\n\n    def schedule_payment_reminder(self, user_id: int, customer_name: str, amount: int, due_days: int, order_data: Dict):\n        \"\"\"Schedule a payment reminder\"\"\"\n        try:\n            # Load existing schedules\n            schedules = self._load_payment_schedules()\n\n            # Calculate due date\n            due_date = (datetime.now() + timedelta(days=due_days)).isoformat()\n\n            # Create schedule entry\n            schedule_id = f\"{user_id}_{int(datetime.now().timestamp())}\"\n            schedules[schedule_id] = {\n                'user_id': user_id,\n                'customer_name': customer_name,\n                'amount': amount,\n                'due_date': due_date,\n                'due_days': due_days,\n                'status': 'pending',\n                'created_at': datetime.now().isoformat(),\n                'order_data': order_data\n            }\n\n            # Save schedules\n            if self._save_payment_schedules(schedules):\n                logger.info(f\"Payment reminder scheduled for user {user_id}, due in {due_days} days\")\n                return schedule_id\n            else:\n                return None\n\n\n        except Exception as e:\n            logger.error(f\"Error scheduling payment reminder: {e}\")\n            return None","size_bytes":12386},"bot/pricing.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nPricing and Invoice Management\nHandles price calculations and invoice generation.\n\"\"\"\n\nfrom typing import List, Dict, Any\nfrom utils.persian_utils import format_price, persian_numbers\nfrom datetime import datetime\n\n\nclass PricingManager:\n    \"\"\"Manages pricing and invoice generation\"\"\"\n\n    def __init__(self):\n        # نرخ‌های تخفیف به‌روزرسانی شده\n        self.discount_rates = {\n            'cash': 0.30,  # تخفیف ۳۰٪ نقدی\n            'installment': 0.25,  # تخفیف ۲۵٪ اقساطی\n            '60day': 0.25,  # تخفیف ۲۵٪ برای ۶۰ روزه\n            '90day': 0.25  # تخفیف ۲۵٪ برای ۹۰ روزه\n        }\n\n        # اطلاعات حساب بانکی\n        self.bank_info = {\n            'card_number': '6219861915854102',\n            'sheba_number': '110560611828005185959401',\n            'account_holder': 'نیما کریمی'\n        }\n\n    def calculate_subtotal(self, cart_items: List[Dict[str, Any]]) -> float:\n        \"\"\"Calculate subtotal from cart items\"\"\"\n        return sum(item['price'] * item['quantity'] for item in cart_items)\n\n    def calculate_discount(self, subtotal: float, discount_rate: float) -> int:\n        \"\"\"محاسبه تخفیف\"\"\"\n        return int(subtotal * discount_rate)\n\n    def calculate_tax(self, amount: int) -> int:\n        \"\"\"محاسبه مالیات ()\"\"\"\n        return int(amount * 0.09)\n\n    def calculate_total(self, subtotal: float, discount: float = 0) -> float:\n        \"\"\"Calculate final total\"\"\"\n        return subtotal - discount\n\n    def generate_invoice(self, cart_items: List[Dict[str, Any]],\n                         customer: Dict[str, Any]) -> str:\n        \"\"\"Generate invoice with all payment options displayed\"\"\"\n        if not cart_items:\n            return \"❌ سبد خرید خالی است.\"\n\n        # Calculate amounts\n        subtotal = self.calculate_subtotal(cart_items)\n\n        # Calculate discounts for each option\n        cash_discount = self.calculate_discount(subtotal, 0.30)\n        installment_discount = self.calculate_discount(subtotal, 0.25)\n\n        cash_total = subtotal - cash_discount\n        installment_total = subtotal - installment_discount\n        advance_payment_90 = installment_total * 0.25\n\n        # Generate invoice text\n        invoice_lines = [\n            \"📋 پیش‌فاکتور سفارش\", \"=\" * 30, \"\", f\"👤 مشتری: {customer['name']}\",\n            f\"🏙️ شهر: {customer['city']}\",\n            f\"🆔 کد مشتری: {customer['customer_id']}\",\n            f\"📅 تاریخ: {self._get_persian_date()}\", \"\", \"📦 اقلام سفارش:\",\n            \"-\" * 20\n        ]\n\n        # Add cart items\n        for i, item in enumerate(cart_items, 1):\n            item_total = item['price'] * item['quantity']\n            invoice_lines.extend([\n                f\"{persian_numbers(str(i))}. {item['product_name']}\",\n                f\"   📏 سایز: {item['size']}\",\n                f\"   📦 تعداد: {persian_numbers(str(item['quantity']))}\",\n                f\"   💰 قیمت واحد: {format_price(item['price'])} تومان\",\n                f\"   💰 قیمت کل: {format_price(item_total)} تومان\", \"\"\n            ])\n\n        # Add total amount\n        invoice_lines.extend([\n            \"-\" * 20, f\"💰 مبلغ کل: {format_price(subtotal)} تومان\",\n            \"\",\n            \"💳 برای انتخاب روش پرداخت، یکی از گزینه‌های زیر را انتخاب کنید:\"\n        ])\n\n        return \"\\n\".join(invoice_lines)\n\n    def generate_final_invoice(self, cart_items: List[Dict[str, Any]],\n                               customer: Dict[str, Any], payment_method: str,\n                               discount_rate: float) -> str:\n        \"\"\"Generate final invoice with payment method and discounts\"\"\"\n        if not cart_items:\n            return \"❌ سبد خرید خالی است.\"\n\n        # Calculate amounts\n        subtotal = self.calculate_subtotal(cart_items)\n        discount = self.calculate_discount(subtotal, discount_rate)\n        total = subtotal - discount\n\n        # Generate invoice text\n        invoice_lines = [\n            \"📋 فاکتور نهایی\", \"=\" * 30, \"\", f\"👤 مشتری: {customer['name']}\",\n            f\"🏙️ شهر: {customer['city']}\",\n            f\"🆔 کد مشتری: {customer['customer_id']}\",\n            f\"📅 تاریخ: {self._get_persian_date()}\",\n            f\"💳 روش پرداخت: {payment_method}\", \"\", \"📦 اقلام سفارش:\", \"-\" * 20\n        ]\n\n        # Add cart items\n        for i, item in enumerate(cart_items, 1):\n            item_total = item['price'] * item['quantity']\n            invoice_lines.extend([\n                f\"{persian_numbers(str(i))}. {item['product_name']}\",\n                f\"   📏 سایز: {item['size']}\",\n                f\"   📦 تعداد: {persian_numbers(str(item['quantity']))}\",\n                f\"   💰 قیمت واحد: {format_price(item['price'])} تومان\",\n                f\"   💰 قیمت کل: {format_price(item_total)} تومان\", \"\"\n            ])\n\n        # Add calculations\n        invoice_lines.extend([\n            \"-\" * 20, f\"💰 مجموع: {format_price(subtotal)} تومان\",\n            f\"🎁 تخفیف ({persian_numbers(str(int(discount_rate * 100)))}٪): {format_price(discount)} تومان\",\n            f\"💰 مبلغ قابل پرداخت: {format_price(total)} تومان\"\n        ])\n\n        # Add special details for installment payment\n        if payment_method == \"پرداخت اقساطی\":\n            invoice_lines.extend([\n                \"\", \"💳 جزئیات پرداخت اقساطی:\",\n                f\"🎁 تخفیف ویژه: {persian_numbers(str(int(discount_rate * 100)))}٪\",\n                \"📞 جزئیات اقساط با تماس کارشناس اعلام خواهد شد\"\n            ])\n\n        invoice_lines.extend(\n            [\"\", \"✅ سفارش شما ثبت شد و به زودی با شما تماس خواهیم گرفت.\"])\n\n        return \"\\n\".join(invoice_lines)\n\n    def generate_invoice_text(self, order_data: Dict) -> str:\n        \"\"\"تولید متن پیش‌فاکتور\"\"\"\n        customer = order_data[\"customer\"]\n        cart_items = order_data[\"items\"]\n\n        subtotal = sum(item['price'] * item['quantity'] for item in cart_items)\n        discount_rate = 0.25\n        discount = subtotal * discount_rate\n        total = subtotal - discount\n        advance_payment = total * 0.25\n\n        invoice_text = (\n            f\"🆕 سفارش جدید - شماره: {order_data['order_id']}\\n\"\n            f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n            f\"👤 نام مشتری: {customer['name']}\\n\"\n            f\"🏙️ شهر: {customer['city']}\\n\"\n            f\"💰 قیمت کل: {format_price(subtotal)} تومان\\n\"\n            f\"🎁 تخفیف (25٪): {format_price(discount)} تومان\\n\"\n            f\"💰 مبلغ قابل پرداخت: {format_price(total)} تومان\\n\"\n            f\"💳 پیش‌پرداخت (25٪): {format_price(advance_payment)} تومان\\n\"\n            f\"📅 تاریخ: ۱۴۰۴/۰۵/۱۴\\n\"\n            f\"📋 جزئیات سفارش:\\n\"\n            f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\")\n        for i, item in enumerate(cart_items, 1):\n            item_total = item['price'] * item['quantity']\n            invoice_text += (\n                f\"{persian_numbers(str(i))}. {item['product_name']}\\n\"\n                f\"   📏 سایز: {item['size']}\\n\"\n                f\"   📦 تعداد: {persian_numbers(str(item['quantity']))}\\n\"\n                f\"   💰 قیمت: {format_price(item_total)} تومان\\n\\n\")\n        return invoice_text\n\n    def generate_cash_payment_invoice(self, order_data: Dict) -> str:\n        \"\"\"تولید فاکتور پرداخت نقدی با تخفیف 30%\"\"\"\n        customer = order_data[\"customer\"]\n        cart_items = order_data[\"items\"]\n\n        subtotal = sum(item['price'] * item['quantity'] for item in cart_items)\n        discount_rate = 0.30  # 30% discount for cash payment\n        discount = subtotal * discount_rate\n        total = subtotal - discount\n\n        invoice_text = (f\"💳 پرداخت نقدی (30% تخفیف)\\n\"\n                        f\"شماره سفارش: {order_data['order_id']}\\n\"\n                        f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n                        f\"👤 نام مشتری: {customer['name']}\\n\"\n                        f\"🏙️ شهر: {customer['city']}\\n\"\n                        f\"📅 تاریخ: {self._get_persian_date()}\\n\\n\"\n                        f\"📋 جزئیات سفارش:\\n\"\n                        f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\")\n\n        # Add cart items\n        for i, item in enumerate(cart_items, 1):\n            item_total = item['price'] * item['quantity']\n            invoice_text += (\n                f\"{persian_numbers(str(i))}. {item['product_name']}\\n\"\n                f\"   📏 سایز: {item['size']}\\n\"\n                f\"   📦 تعداد: {persian_numbers(str(item['quantity']))}\\n\"\n                f\"   💰 قیمت: {format_price(item_total)} تومان\\n\\n\")\n\n        # Add totals\n        invoice_text += (\n            f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n            f\"💰 مبلغ کل: {format_price(subtotal)} تومان\\n\"\n            f\"🎁 مبلغ تخفیف ({persian_numbers('30')}٪): {format_price(discount)} تومان\\n\\n\"\n            f\"💳 اطلاعات پرداخت:\\n\"\n            f\"🏪 نام صاحب حساب: {self.bank_info['account_holder']}\\n\"\n            f\"💳 شماره کارت: {self.bank_info['card_number']}\\n\"\n            f\"🏦 شماره شبا: IR{self.bank_info['sheba_number']}\\n\\n\"\n            f\"✅ پس از واریز، لطفاً فیش واریزی را ارسال کنید.\")\n\n        return invoice_text\n\n    def generate_installment_payment_invoice(self, order_data: Dict) -> str:\n        \"\"\"تولید فاکتور پرداخت اقساطی با تخفیف 25%\"\"\"\n        customer = order_data[\"customer\"]\n        cart_items = order_data[\"items\"]\n\n        subtotal = sum(item['price'] * item['quantity'] for item in cart_items)\n        discount_rate = 0.25  # 25% discount for installment payment\n        discount = subtotal * discount_rate\n        total = subtotal - discount\n\n        invoice_text = (f\"📅 پرداخت اقساطی (25% تخفیف)\\n\"\n                        f\"شماره سفارش: {order_data['order_id']}\\n\"\n                        f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n                        f\"👤 نام مشتری: {customer['name']}\\n\"\n                        f\"🏙️ شهر: {customer['city']}\\n\"\n                        f\"📅 تاریخ: {self._get_persian_date()}\\n\\n\"\n                        f\"📋 جزئیات سفارش:\\n\"\n                        f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\")\n\n        # Add cart items\n        for i, item in enumerate(cart_items, 1):\n            item_total = item['price'] * item['quantity']\n            invoice_text += (\n                f\"{persian_numbers(str(i))}. {item['product_name']}\\n\"\n                f\"   📏 سایز: {item['size']}\\n\"\n                f\"   📦 تعداد: {persian_numbers(str(item['quantity']))}\\n\"\n                f\"   💰 قیمت: {format_price(item_total)} تومان\\n\\n\")\n\n        # Add totals\n        invoice_text += (\n            f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n            f\"💰 مبلغ کل: {format_price(subtotal)} تومان\\n\"\n            f\"🎁 مبلغ تخفیف ({persian_numbers('25')}٪): {format_price(discount)} تومان\\n\"\n            f\"💰 مبلغ نهایی: {format_price(total)} تومان\")\n\n        return invoice_text\n\n    def generate_60day_payment_invoice(self, order_data: Dict) -> str:\n        \"\"\"تولید فاکتور پرداخت 60 روزه با تخفیف 25% + پیش پرداخت 25%\"\"\"\n        customer = order_data[\"customer\"]\n        cart_items = order_data[\"items\"]\n\n        subtotal = sum(item['price'] * item['quantity'] for item in cart_items)\n        discount_rate = 0.25  # 25% discount\n        discount = subtotal * discount_rate\n        total = subtotal - discount\n        advance_payment = total * 0.25  # 25% advance payment from final amount\n\n        invoice_text = (f\"🕐 پرداخت 60 روزه (25% تخفیف)\\n\"\n                        f\"شماره سفارش: {order_data['order_id']}\\n\"\n                        f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n                        f\"👤 نام مشتری: {customer['name']}\\n\"\n                        f\"🏙️ شهر: {customer['city']}\\n\"\n                        f\"📅 تاریخ: {self._get_persian_date()}\\n\\n\"\n                        f\"📋 جزئیات سفارش:\\n\"\n                        f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\")\n\n        # Add cart items\n        for i, item in enumerate(cart_items, 1):\n            item_total = item['price'] * item['quantity']\n            invoice_text += (\n                f\"{persian_numbers(str(i))}. {item['product_name']}\\n\"\n                f\"   📏 سایز: {item['size']}\\n\"\n                f\"   📦 تعداد: {persian_numbers(str(item['quantity']))}\\n\"\n                f\"   💰 قیمت: {format_price(item_total)} تومان\\n\\n\")\n\n        # Add totals and payment terms\n        invoice_text += (\n            f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n            f\"💰 مبلغ کل: {format_price(subtotal)} تومان\\n\"\n            f\"🎁 مبلغ تخفیف ({persian_numbers('25')}٪): {format_price(discount)} تومان\\n\"\n            f\"💰 مبلغ نهایی: {format_price(total)} تومان\\n\"\n            f\"💳 مبلغ پیش‌پرداخت ({persian_numbers('25')}٪): {format_price(advance_payment)} تومان\\n\\n\"\n            f\"💳 اطلاعات پرداخت پیش‌پرداخت:\\n\"\n            f\"🏪 نام صاحب حساب: {self.bank_info['account_holder']}\\n\"\n            f\"💳 شماره کارت: {self.bank_info['card_number']}\\n\"\n            f\"🏦 شماره شبا: IR{self.bank_info['sheba_number']}\\n\\n\"\n            f\"📅 شرایط پرداخت:\\n\"\n            f\"• پیش‌پرداخت 25٪ از مبلغ نهایی\\n\"\n            f\"• مابقی 60 روز پس از تحویل\\n\"\n            f\"• تخفیف ویژه 25٪ اعمال شده\\n\\n\"\n            f\"✅ پس از واریز پیش‌پرداخت، فیش واریزی را ارسال کنید.\")\n\n        return invoice_text\n\n    def _get_persian_date(self) -> str:\n        \"\"\"Get current date in Persian format\"\"\"\n        # Return current Persian date: 1404/5/14\n        return persian_numbers(\"14 مرداد 1404\")\n","size_bytes":15352},"bot/zarinpal.py":{"content":"\n#!/usr/bin/env python3\n\"\"\"\nZarinPal Payment Integration\nHandles payment processing through ZarinPal gateway.\n\"\"\"\n\nimport requests\nimport json\nfrom typing import Dict, Any, Optional\nfrom utils.logger import setup_logger\n\nlogger = setup_logger(__name__)\n\nclass ZarinPalGateway:\n    \"\"\"ZarinPal payment gateway integration\"\"\"\n\n    def __init__(self, merchant_id: str, sandbox: bool = True):\n        self.merchant_id = merchant_id\n        self.sandbox = sandbox\n\n        if sandbox:\n            self.request_url = \"https://sandbox.zarinpal.com/pg/rest/WebGate/PaymentRequest.json\"\n            self.verify_url = \"https://sandbox.zarinpal.com/pg/rest/WebGate/PaymentVerification.json\"\n            self.gateway_url = \"https://sandbox.zarinpal.com/pg/StartPay/\"\n        else:\n            self.request_url = \"https://www.zarinpal.com/pg/rest/WebGate/PaymentRequest.json\"\n            self.verify_url = \"https://www.zarinpal.com/pg/rest/WebGate/PaymentVerification.json\"\n            self.gateway_url = \"https://www.zarinpal.com/pg/StartPay/\"\n\n    def create_payment_request(self, amount: int, description: str, \n                             callback_url: str, customer_email: str = \"\",\n                             customer_mobile: str = \"\") -> Dict[str, Any]:\n        \"\"\"Create payment request\"\"\"\n        try:\n            data = {\n                \"MerchantID\": self.merchant_id,\n                \"Amount\": amount,\n                \"Description\": description,\n                \"CallbackURL\": callback_url,\n                \"Email\": customer_email,\n                \"Mobile\": customer_mobile\n            }\n\n            response = requests.post(self.request_url, json=data, timeout=10)\n            result = response.json()\n\n            if result[\"Status\"] == 100:\n                authority = result[\"Authority\"]\n                payment_url = f\"{self.gateway_url}{authority}\"\n\n                logger.info(f\"Payment request created successfully. Authority: {authority}\")\n                return {\n                    \"success\": True,\n                    \"authority\": authority,\n                    \"payment_url\": payment_url\n                }\n            else:\n                error_msg = self._get_error_message(result[\"Status\"])\n                logger.error(f\"ZarinPal payment request failed: {error_msg}\")\n                return {\n                    \"success\": False,\n                    \"error\": error_msg\n                }\n\n        except requests.exceptions.RequestException as e:\n            logger.error(f\"Request error: {e}\")\n            return {\n                \"success\": False,\n                \"error\": \"خطا در ارتباط با درگاه پرداخت\"\n            }\n        except Exception as e:\n            logger.error(f\"Unexpected error: {e}\")\n            return {\n                \"success\": False,\n                \"error\": \"خطای غیرمنتظره در ایجاد درخواست پرداخت\"\n            }\n\n    def verify_payment(self, authority: str, amount: int) -> Dict[str, Any]:\n        \"\"\"Verify payment\"\"\"\n        try:\n            data = {\n                \"MerchantID\": self.merchant_id,\n                \"Authority\": authority,\n                \"Amount\": amount\n            }\n\n            response = requests.post(self.verify_url, json=data, timeout=10)\n            result = response.json()\n\n            if result[\"Status\"] == 100:\n                ref_id = result[\"RefID\"]\n                logger.info(f\"Payment verified successfully. RefID: {ref_id}\")\n                return {\n                    \"success\": True,\n                    \"ref_id\": ref_id,\n                    \"status\": \"verified\"\n                }\n            else:\n                error_msg = self._get_error_message(result[\"Status\"])\n                logger.error(f\"Payment verification failed: {error_msg}\")\n                return {\n                    \"success\": False,\n                    \"error\": error_msg\n                }\n\n        except requests.exceptions.RequestException as e:\n            logger.error(f\"Request error during verification: {e}\")\n            return {\n                \"success\": False,\n                \"error\": \"خطا در تأیید پرداخت\"\n            }\n        except Exception as e:\n            logger.error(f\"Unexpected error during verification: {e}\")\n            return {\n                \"success\": False,\n                \"error\": \"خطای غیرمنتظره در تأیید پرداخت\"\n            }\n\n    def _get_error_message(self, status_code: int) -> str:\n        \"\"\"Get Persian error message for status code\"\"\"\n        error_messages = {\n            -1: \"اطلاعات ارسال شده ناقص است\",\n            -2: \"IP یا مرچنت کد پذیرنده صحیح نیست\",\n            -3: \"با توجه به محدودیت‌های شاپرک امکان پردازش وجود ندارد\",\n            -4: \"سطح تأیید پذیرنده پایین‌تر از سطح نقره‌ای است\",\n            -11: \"درخواست مورد نظر یافت نشد\",\n            -12: \"امکان ویرایش درخواست میسر نمی‌باشد\",\n            -21: \"هیچ نوع عملیات مالی برای این تراکنش یافت نشد\",\n            -22: \"تراکنش ناموفق می‌باشد\",\n            -33: \"رقم تراکنش با رقم پرداخت شده مطابقت ندارد\",\n            -34: \"سقف تقسیم تراکنش از لحاظ تعداد یا رقم عبور نموده است\",\n            -40: \"اجازه دسترسی به متد مربوطه وجود ندارد\",\n            -41: \"اطلاعات ارسال شده مربوط به AdditionalData غیر معتبر می‌باشد\",\n            -42: \"مدت زمان معتبر طول عمر شناسه پرداخت باید بین ۳۰ دقیقه تا ۴۵ روز باشد\",\n            -54: \"درخواست مورد نظر آرشیو شده است\",\n            101: \"عملیات پرداخت موفق بوده و قبلاً PaymentVerification تراکنش انجام شده است\"\n        }\n        \n        return error_messages.get(status_code, f\"خطای نامشخص با کد {status_code}\")\n","size_bytes":6136},"bot/zarinpal_test.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nZarinPal Payment Integration - Fixed Version\nHandles payment processing through ZarinPal gateway.\n\"\"\"\n\nimport requests\nimport json\nfrom typing import Dict, Any, Optional\nfrom utils.logger import setup_logger\n\nlogger = setup_logger(__name__)\n\n\nclass ZarinPalGateway:\n    \"\"\"ZarinPal payment gateway integration\"\"\"\n\n    def __init__(self, merchant_id: str, sandbox: bool = True):\n        self.merchant_id = merchant_id\n        self.sandbox = sandbox\n\n        if sandbox:\n            # Sandbox URLs\n            self.request_url = \"https://sandbox.zarinpal.com/pg/rest/WebGate/PaymentRequest.json\"\n            self.verify_url = \"https://sandbox.zarinpal.com/pg/rest/WebGate/PaymentVerification.json\"\n            self.gateway_url = \"https://sandbox.zarinpal.com/pg/StartPay/\"\n        else:\n            # Production URLs - API v4\n            self.request_url = \"https://api.zarinpal.com/pg/v4/payment/request/\"\n            self.verify_url = \"https://api.zarinpal.com/pg/v4/payment/verify/\"\n            self.gateway_url = \"https://www.zarinpal.com/pg/StartPay/\"\n\n    def create_payment_request(self,\n                               amount: int,\n                               description: str,\n                               callback_url: str,\n                               customer_email: str = \"\",\n                               customer_mobile: str = \"\") -> Dict[str, Any]:\n        \"\"\"Create payment request\"\"\"\n        try:\n            if self.sandbox:\n                # Sandbox API (v3 format)\n                data = {\n                    \"MerchantID\": self.merchant_id,\n                    \"Amount\": amount,\n                    \"Description\": description,\n                    \"CallbackURL\": callback_url,\n                    \"Email\": customer_email,\n                    \"Mobile\": customer_mobile\n                }\n                headers = {'Content-Type': 'application/json'}\n            else:\n                # Production API (v4 format)\n                data = {\n                    \"merchant_id\": self.merchant_id,\n                    \"amount\": amount,\n                    \"description\": description,\n                    \"callback_url\": callback_url,\n                    \"metadata\": {\n                        \"email\": customer_email,\n                        \"mobile\": customer_mobile\n                    }\n                }\n                headers = {\n                    'Content-Type': 'application/json',\n                    'Accept': 'application/json'\n                }\n\n            logger.info(f\"Sending payment request to: {self.request_url}\")\n            logger.info(\n                f\"Request data: {json.dumps(data, ensure_ascii=False)}\")\n\n            response = requests.post(self.request_url,\n                                     json=data,\n                                     headers=headers,\n                                     timeout=15)\n\n            logger.info(f\"Response status: {response.status_code}\")\n            logger.info(f\"Response headers: {dict(response.headers)}\")\n            logger.info(f\"Response text: {response.text}\")\n\n            if response.status_code != 200:\n                return {\n                    \"success\": False,\n                    \"error\":\n                    f\"HTTP Error {response.status_code}: {response.text}\"\n                }\n\n            result = response.json()\n\n            if self.sandbox:\n                # Sandbox response format\n                if result.get(\"Status\") == 100:\n                    authority = result.get(\"Authority\")\n                    payment_url = f\"{self.gateway_url}{authority}\"\n\n                    logger.info(\n                        f\"Payment request created successfully. Authority: {authority}\"\n                    )\n                    return {\n                        \"success\": True,\n                        \"authority\": authority,\n                        \"payment_url\": payment_url\n                    }\n                else:\n                    error_msg = self._get_error_message(\n                        result.get(\"Status\", -999))\n                    logger.error(\n                        f\"ZarinPal payment request failed: {error_msg}\")\n                    return {\"success\": False, \"error\": error_msg}\n            else:\n                # Production response format\n                if result.get(\"data\") and result[\"data\"].get(\"code\") == 100:\n                    authority = result[\"data\"].get(\"authority\")\n                    payment_url = f\"{self.gateway_url}{authority}\"\n\n                    logger.info(\n                        f\"Payment request created successfully. Authority: {authority}\"\n                    )\n                    return {\n                        \"success\": True,\n                        \"authority\": authority,\n                        \"payment_url\": payment_url\n                    }\n                else:\n                    error_msg = result.get(\"errors\",\n                                           {}).get(\"message\", \"خطای نامشخص\")\n                    logger.error(\n                        f\"ZarinPal payment request failed: {error_msg}\")\n                    return {\"success\": False, \"error\": error_msg}\n\n        except requests.exceptions.Timeout:\n            logger.error(\"Request timeout\")\n            return {\n                \"success\": False,\n                \"error\": \"زمان درخواست به پایان رسید. لطفاً دوباره تلاش کنید.\"\n            }\n        except requests.exceptions.ConnectionError:\n            logger.error(\"Connection error\")\n            return {\n                \"success\":\n                False,\n                \"error\":\n                \"خطا در اتصال به درگاه پرداخت. اتصال اینترنت خود را بررسی کنید.\"\n            }\n        except requests.exceptions.RequestException as e:\n            logger.error(f\"Request error: {e}\")\n            return {\"success\": False, \"error\": \"خطا در ارتباط با درگاه پرداخت\"}\n        except json.JSONDecodeError as e:\n            logger.error(f\"JSON decode error: {e}\")\n            return {\"success\": False, \"error\": \"پاسخ نامعتبر از درگاه پرداخت\"}\n        except Exception as e:\n            logger.error(f\"Unexpected error: {e}\")\n            return {\n                \"success\": False,\n                \"error\": \"خطای غیرمنتظره در ایجاد درخواست پرداخت\"\n            }\n\n    def verify_payment(self, authority: str, amount: int) -> Dict[str, Any]:\n        \"\"\"Verify payment\"\"\"\n        try:\n            if self.sandbox:\n                # Sandbox API (v3 format)\n                data = {\n                    \"MerchantID\": self.merchant_id,\n                    \"Authority\": authority,\n                    \"Amount\": amount\n                }\n                headers = {'Content-Type': 'application/json'}\n            else:\n                # Production API (v4 format)\n                data = {\n                    \"merchant_id\": self.merchant_id,\n                    \"authority\": authority,\n                    \"amount\": amount\n                }\n                headers = {\n                    'Content-Type': 'application/json',\n                    'Accept': 'application/json'\n                }\n\n            logger.info(f\"Verifying payment with authority: {authority}\")\n\n            response = requests.post(self.verify_url,\n                                     json=data,\n                                     headers=headers,\n                                     timeout=15)\n\n            logger.info(\n                f\"Verification response status: {response.status_code}\")\n            logger.info(f\"Verification response: {response.text}\")\n\n            if response.status_code != 200:\n                return {\n                    \"success\": False,\n                    \"error\":\n                    f\"HTTP Error {response.status_code}: {response.text}\"\n                }\n\n            result = response.json()\n\n            if self.sandbox:\n                # Sandbox response format\n                if result.get(\"Status\") == 100:\n                    ref_id = result.get(\"RefID\")\n                    logger.info(\n                        f\"Payment verified successfully. RefID: {ref_id}\")\n                    return {\n                        \"success\": True,\n                        \"ref_id\": ref_id,\n                        \"status\": \"verified\"\n                    }\n                else:\n                    error_msg = self._get_error_message(\n                        result.get(\"Status\", -999))\n                    logger.error(f\"Payment verification failed: {error_msg}\")\n                    return {\"success\": False, \"error\": error_msg}\n            else:\n                # Production response format\n                if result.get(\"data\") and result[\"data\"].get(\"code\") == 100:\n                    ref_id = result[\"data\"].get(\"ref_id\")\n                    logger.info(\n                        f\"Payment verified successfully. RefID: {ref_id}\")\n                    return {\n                        \"success\": True,\n                        \"ref_id\": ref_id,\n                        \"status\": \"verified\"\n                    }\n                else:\n                    error_msg = result.get(\"errors\",\n                                           {}).get(\"message\", \"خطای نامشخص\")\n                    logger.error(f\"Payment verification failed: {error_msg}\")\n                    return {\"success\": False, \"error\": error_msg}\n\n        except requests.exceptions.Timeout:\n            logger.error(\"Verification request timeout\")\n            return {\n                \"success\": False,\n                \"error\": \"زمان تأیید پرداخت به پایان رسید\"\n            }\n        except requests.exceptions.ConnectionError:\n            logger.error(\"Verification connection error\")\n            return {\n                \"success\": False,\n                \"error\": \"خطا در اتصال برای تأیید پرداخت\"\n            }\n        except requests.exceptions.RequestException as e:\n            logger.error(f\"Verification request error: {e}\")\n            return {\"success\": False, \"error\": \"خطا در تأیید پرداخت\"}\n        except json.JSONDecodeError as e:\n            logger.error(f\"Verification JSON decode error: {e}\")\n            return {\"success\": False, \"error\": \"پاسخ نامعتبر در تأیید پرداخت\"}\n        except Exception as e:\n            logger.error(f\"Unexpected verification error: {e}\")\n            return {\n                \"success\": False,\n                \"error\": \"خطای غیرمنتظره در تأیید پرداخت\"\n            }\n\n    def _get_error_message(self, status_code: int) -> str:\n        \"\"\"Get Persian error message for status code\"\"\"\n        error_messages = {\n            -1: \"اطلاعات ارسال شده ناقص است\",\n            -2: \"IP یا مرچنت کد پذیرنده صحیح نیست\",\n            -3: \"با توجه به محدودیت‌های شاپرک امکان پردازش وجود ندارد\",\n            -4: \"سطح تأیید پذیرنده پایین‌تر از سطح نقره‌ای است\",\n            -11: \"درخواست مورد نظر یافت نشد\",\n            -12: \"امکان ویرایش درخواست میسر نمی‌باشد\",\n            -21: \"هیچ نوع عملیات مالی برای این تراکنش یافت نشد\",\n            -22: \"تراکنش ناموفق می‌باشد\",\n            -33: \"رقم تراکنش با رقم پرداخت شده مطابقت ندارد\",\n            -34: \"سقف تقسیم تراکنش از لحاظ تعداد یا رقم عبور نموده است\",\n            -40: \"اجازه دسترسی به متد مربوطه وجود ندارد\",\n            -41: \"اطلاعات ارسال شده مربوط به AdditionalData غیر معتبر می‌باشد\",\n            -42:\n            \"مدت زمان معتبر طول عمر شناسه پرداخت باید بین ۳۰ دقیقه تا ۴۵ روز باشد\",\n            -54: \"درخواست مورد نظر آرشیو شده است\",\n            101:\n            \"عملیات پرداخت موفق بوده و قبلاً PaymentVerification تراکنش انجام شده است\",\n            -999: \"خطای نامشخص - پاسخ از سرور دریافت نشد\"\n        }\n\n        return error_messages.get(status_code,\n                                  f\"خطای نامشخص با کد {status_code}\")\n","size_bytes":12534},"data/__init__.py":{"content":"\"\"\"\nData Package\nContains customer database and product catalog management.\n\"\"\"\n","size_bytes":80},"data/customer_service.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nCustomer Service and Authentication\nManages customer database and authentication.\n\"\"\"\n\nfrom typing import Optional, Dict, Any, List\nfrom utils.logger import setup_logger\n\nlogger = setup_logger(__name__)\n\nclass CustomerService:\n    \"\"\"Customer service management class\"\"\"\n    \n    def __init__(self):\n        # Customer database with authentic customer codes from original data\n        self.customers = {\n            # کدهای مشتری شش رقمی طبق فایل اصلی\n            \"000001\": {\"customer_id\": \"000001\", \"name\": \"خانم نیلوفر صفرپور\", \"city\": \"اردبیل\"},\n            \"000002\": {\"customer_id\": \"000002\", \"name\": \"خانم اعظم افرایی\", \"city\": \"اصفهان\"},\n            \"000003\": {\"customer_id\": \"000003\", \"name\": \"آقای مجید زین العابدین\", \"city\": \"اصفهان\"},\n            \"000004\": {\"customer_id\": \"000004\", \"name\": \"آقای روح الله شاکریان\", \"city\": \"کاشان\"},\n            \"000005\": {\"customer_id\": \"000005\", \"name\": \"آقای یاشار حیدری\", \"city\": \"مطهری کرج\"},\n            \"000006\": {\"customer_id\": \"000006\", \"name\": \"آقای شاهوی امیری\", \"city\": \"کرج\"},\n            \"000007\": {\"customer_id\": \"000007\", \"name\": \"آقای مرتضی انجیله ای\", \"city\": \"دشت بهشت کرج\"},\n            \"000008\": {\"customer_id\": \"000008\", \"name\": \"آقای جواد رشیدی\", \"city\": \"اکومال کرج\"},\n            \"000009\": {\"customer_id\": \"000009\", \"name\": \"خانم مژگان جعفری\", \"city\": \"کاج کرج\"},\n            \"000010\": {\"customer_id\": \"000010\", \"name\": \"آقای سینا اسد اللهی\", \"city\": \"رستاخیز\"},\n            \"000011\": {\"customer_id\": \"000011\", \"name\": \"خانم ندا اکبری\", \"city\": \"تبریز\"},\n            \"000012\": {\"customer_id\": \"000012\", \"name\": \"آقای ایمان کوهگرد\", \"city\": \"تبریز\"},\n            \"000013\": {\"customer_id\": \"000013\", \"name\": \"آقای بهروز توفیقی\", \"city\": \"میانه\"},\n            \"000014\": {\"customer_id\": \"000014\", \"name\": \"آقای یعقوب عبداللهی\", \"city\": \"ارومیه\"},\n            \"000015\": {\"customer_id\": \"000015\", \"name\": \"آقای امیر شمامی\", \"city\": \"بوکان\"},\n            \"000016\": {\"customer_id\": \"000016\", \"name\": \"آقای حسین شفقی\", \"city\": \"خوی\"},\n            \"000017\": {\"customer_id\": \"000017\", \"name\": \"خانم شهربانو فولادی\", \"city\": \"بوشهر\"},\n            \"000018\": {\"customer_id\": \"000018\", \"name\": \"آقای امین گودرزی\", \"city\": \"بندرگناوه\"},\n            \"000019\": {\"customer_id\": \"000019\", \"name\": \"آقای سیدعلی حسین زاده\", \"city\": \"شهرجم\"},\n            \"000020\": {\"customer_id\": \"000020\", \"name\": \"آقای سعید صالحی\", \"city\": \"جامی تهران\"},\n            \"000021\": {\"customer_id\": \"000021\", \"name\": \"آقای مجید رحیمی\", \"city\": \"خلیج فارس تهران\"},\n            \"000022\": {\"customer_id\": \"000022\", \"name\": \"آقای امین کوهزاد\", \"city\": \"کاسپین تهران\"},\n            \"000023\": {\"customer_id\": \"000023\", \"name\": \"آقای وحید صادقی\", \"city\": \"دلاوران تهران\"},\n            \"000024\": {\"customer_id\": \"000024\", \"name\": \"آقای اکوان\", \"city\": \"چهاردانگه تهران\"},\n            \"000025\": {\"customer_id\": \"000025\", \"name\": \"آقای محمد اسداللهی\", \"city\": \"ورامین\"},\n            \"000026\": {\"customer_id\": \"000026\", \"name\": \"آقای سعیدی\", \"city\": \"ایرانمال تهران\"},\n            \"000027\": {\"customer_id\": \"000027\", \"name\": \"آقای مرتضی رمضانی\", \"city\": \"جاجرود تهران\"},\n            \"000028\": {\"customer_id\": \"000028\", \"name\": \"آقای فرزاد رجب زاده\", \"city\": \"بجنورد\"},\n            \"000029\": {\"customer_id\": \"000029\", \"name\": \"آقای مهدی باقر نژاد\", \"city\": \"تربت حیدریه\"},\n            \"000030\": {\"customer_id\": \"000030\", \"name\": \"آقای کاوه مددیان\", \"city\": \"مشهد\"},\n            \"000031\": {\"customer_id\": \"000031\", \"name\": \"آقای محسن اصغری\", \"city\": \"بیرجند\"},\n            \"000032\": {\"customer_id\": \"000032\", \"name\": \"آقای مسعود مهر ابادی\", \"city\": \"سبزوار\"},\n            \"000033\": {\"customer_id\": \"000033\", \"name\": \"آقای حمید رضا علیزاده\", \"city\": \"شهرفردوس\"},\n            \"000034\": {\"customer_id\": \"000034\", \"name\": \"آقای مهدی کشاورز\", \"city\": \"اپادانا اهواز\"},\n            \"000035\": {\"customer_id\": \"000035\", \"name\": \"آقای فرشاد کامران فر\", \"city\": \"اهواز\"},\n            \"000036\": {\"customer_id\": \"000036\", \"name\": \"آقای اسد الله فلاحی\", \"city\": \"بندر ماهشهر\"},\n            \"000037\": {\"customer_id\": \"000037\", \"name\": \"آقای محسن مروج\", \"city\": \"بهبهان\"},\n            \"000038\": {\"customer_id\": \"000038\", \"name\": \"خانم غزاله گلچین\", \"city\": \"دزفول\"},\n            \"000039\": {\"customer_id\": \"000039\", \"name\": \"آقای ابراهیم حسین زاده\", \"city\": \"اندیمشک\"},\n            \"000040\": {\"customer_id\": \"000040\", \"name\": \"آقای محمد کرد\", \"city\": \"شوش دانیال\"},\n            \"000041\": {\"customer_id\": \"000041\", \"name\": \"خانم مریم احمدخانی\", \"city\": \"ابهر\"},\n            \"000042\": {\"customer_id\": \"000042\", \"name\": \"آقای رضا آربونی\", \"city\": \"زنجان\"},\n            \"000043\": {\"customer_id\": \"000043\", \"name\": \"آقای رضا کیفری\", \"city\": \"گرمسار\"},\n            \"000044\": {\"customer_id\": \"000044\", \"name\": \"آقای امین سرابندی\", \"city\": \"زاهدان\"},\n            \"000045\": {\"customer_id\": \"000045\", \"name\": \"خانم مریم ترشیزی\", \"city\": \"زاهدان\"},\n            \"000046\": {\"customer_id\": \"000046\", \"name\": \"آقای علی رئیسی\", \"city\": \"شهرکرد\"},\n            \"000047\": {\"customer_id\": \"000047\", \"name\": \"آقای ایمان آهی تبار\", \"city\": \"آمل وبابل\"},\n            \"000048\": {\"customer_id\": \"000048\", \"name\": \"آقای کمال باقری\", \"city\": \"بهشهر\"},\n            \"000049\": {\"customer_id\": \"000049\", \"name\": \"آقای بابک مدنی\", \"city\": \"اراک\"},\n            \"000050\": {\"customer_id\": \"000050\", \"name\": \"خانم نسا صالحی\", \"city\": \"ساوه\"},\n            \"000051\": {\"customer_id\": \"000051\", \"name\": \"آقای یوسف سفاری\", \"city\": \"قشم\"},\n            \"000052\": {\"customer_id\": \"000052\", \"name\": \"آقای مسعود سلیمی\", \"city\": \"هوم بندر عباس\"},\n            \"000053\": {\"customer_id\": \"000053\", \"name\": \"آقای محمد قنبری\", \"city\": \"ملایر\"},\n            \"000054\": {\"customer_id\": \"000054\", \"name\": \"آقای نادعلی نعیم ابادی\", \"city\": \"یزد\"},\n            \"000055\": {\"customer_id\": \"000055\", \"name\": \"آقای ساسان کشاورز\", \"city\": \"بیضا\"},\n            \"000056\": {\"customer_id\": \"000056\", \"name\": \"آقای مسعود همایون\", \"city\": \"مرو دشت\"},\n            \"000057\": {\"customer_id\": \"000057\", \"name\": \"آقای حمید رمضانی\", \"city\": \"قزوین\"},\n            \"000058\": {\"customer_id\": \"000058\", \"name\": \"آقای علی افسری\", \"city\": \"قم\"},\n            \"000059\": {\"customer_id\": \"000059\", \"name\": \"آقای مسعود نوحی\", \"city\": \"کرمان\"},\n            \"000060\": {\"customer_id\": \"000060\", \"name\": \"آقای محمد نژاد صالحی\", \"city\": \"سیرجان\"},\n            \"000061\": {\"customer_id\": \"000061\", \"name\": \"آقای کیان\", \"city\": \"شهر بابک\"},\n            \"000062\": {\"customer_id\": \"000062\", \"name\": \"آقای فرید سیاه بیدی\", \"city\": \"کرمانشاه\"},\n            \"000063\": {\"customer_id\": \"000063\", \"name\": \"آقای ابوطالب حسینی\", \"city\": \"یاسوج\"},\n            \"000064\": {\"customer_id\": \"000064\", \"name\": \"آقای میلاد پاکزاد\", \"city\": \"گچساران\"},\n            \"000065\": {\"customer_id\": \"000065\", \"name\": \"آقای بهروز بحری\", \"city\": \"سقز\"},\n            \"000066\": {\"customer_id\": \"000066\", \"name\": \"آقای یوسف بهرامیان\", \"city\": \"سنندج\"},\n            \"000067\": {\"customer_id\": \"000067\", \"name\": \"آقای محسن عامریان\", \"city\": \"گنبد\"},\n            \"000068\": {\"customer_id\": \"000068\", \"name\": \"آقای ابراهیم حسین زاده\", \"city\": \"گرگان\"},\n            \"000069\": {\"customer_id\": \"000069\", \"name\": \"آقای کامران فلاح باقری\", \"city\": \"انزلی\"},\n            \"000070\": {\"customer_id\": \"000070\", \"name\": \"آقای اروین محمدی\", \"city\": \"لاکانی رشت\"},\n            \"000071\": {\"customer_id\": \"000071\", \"name\": \"آقای مصطفی کامران\", \"city\": \"رشت\"},\n            \"000072\": {\"customer_id\": \"000072\", \"name\": \"آقای محمد دادرس\", \"city\": \"لاهیجان\"},\n            \"000073\": {\"customer_id\": \"000073\", \"name\": \"آقای حسین بخشی\", \"city\": \"لنگرود\"},\n            \"000074\": {\"customer_id\": \"000074\", \"name\": \"آقای علیرضا احمد خانی\", \"city\": \"تنکابن\"},\n            \"000075\": {\"customer_id\": \"000075\", \"name\": \"آقای مهدی قلی زاده\", \"city\": \"هوم چالوس\"},\n            \"000076\": {\"customer_id\": \"000076\", \"name\": \"آقای حسین مختاری\", \"city\": \"ساری\"},\n            \"000077\": {\"customer_id\": \"000077\", \"name\": \"آقای مهدی خلدبرین\", \"city\": \"نور\"},\n            \"000078\": {\"customer_id\": \"000078\", \"name\": \"آقای نیما کریمی\", \"city\": \"\"},\n            \"000079\": {\"customer_id\": \"000079\", \"name\": \"آقای ابولفضل موسوی\", \"city\": \"\"},\n            \"000080\": {\"customer_id\": \"000080\", \"name\": \"خانم مژده سلطان محمدی\", \"city\": \"\"},\n            \"000081\": {\"customer_id\": \"000081\", \"name\": \"خانم احمدی\", \"city\": \"\"},\n            \"000082\": {\"customer_id\": \"000082\", \"name\": \"آقای محمد طهماسبی\", \"city\": \"\"},\n            \"000083\": {\"customer_id\": \"000083\", \"name\": \"آقای کمال محمدی\", \"city\": \"\"},\n            \"000084\": {\"customer_id\": \"000084\", \"name\": \"خانم حمیرا عظیمی\", \"city\": \"\"},\n            \"000085\": {\"customer_id\": \"000085\", \"name\": \"خانم سهیلا قمرپور\", \"city\": \"\"},\n            \"000086\": {\"customer_id\": \"000086\", \"name\": \"آقای محمد رفیعی\", \"city\": \"\"},\n            \"000087\": {\"customer_id\": \"000087\", \"name\": \"آقای سعیدپوررضایی\", \"city\": \"چالوس\"},\n            \"000088\": {\"customer_id\": \"000088\", \"name\": \"آقای مسعود سلیمی\", \"city\": \"اپادانا بندر عباس\"},\n            \"000089\": {\"customer_id\": \"000089\", \"name\": \"آقای مهدی کشاورز\", \"city\": \"هوم اهواز\"},\n            \"000090\": {\"customer_id\": \"000090\", \"name\": \"آقای شاهرخ عاشوری\", \"city\": \"شیراز\"},\n            \"000091\": {\"customer_id\": \"000091\", \"name\": \"آقای سعید حسنی\", \"city\": \"نصب\"},\n            \"000092\": {\"customer_id\": \"000092\", \"name\": \"شرکت محترم اپادانا\", \"city\": \"\"},\n            \"000093\": {\"customer_id\": \"000093\", \"name\": \"آقای میرعلی سید باقری\", \"city\": \"\"},\n            \"000094\": {\"customer_id\": \"000094\", \"name\": \"خانم زهرامحمدی\", \"city\": \"اپادانا مارکت\"},\n            \"000095\": {\"customer_id\": \"000095\", \"name\": \"آقای کشاورز\", \"city\": \"لاهیجان\"},\n            \"000096\": {\"customer_id\": \"000096\", \"name\": \"آقای یعقوب عبداللهی\", \"city\": \"هوم\"},\n            \"000097\": {\"customer_id\": \"000097\", \"name\": \"آقای رضا ترکمن\", \"city\": \"هوم کاسپین\"},\n            \"000098\": {\"customer_id\": \"000098\", \"name\": \"آقای مرتضی انجیله ای\", \"city\": \"فروشگاه اینترنتی\"},\n            \"000099\": {\"customer_id\": \"000099\", \"name\": \"آقای مجید ترابیان\", \"city\": \"\"},\n            \"000100\": {\"customer_id\": \"000100\", \"name\": \"آقای سجاد بیضایی\", \"city\": \"\"},\n            \"000101\": {\"customer_id\": \"000101\", \"name\": \"خانم جباری\", \"city\": \"\"},\n            \"000102\": {\"customer_id\": \"000102\", \"name\": \"آقای مهدی مختاری\", \"city\": \"هوم ایرانمال\"},\n            \"000103\": {\"customer_id\": \"000103\", \"name\": \"خانم پرویزی\", \"city\": \"شهریار\"},\n            \"000104\": {\"customer_id\": \"000104\", \"name\": \"آقای پیام صالحی\", \"city\": \"آرتین مود\"},\n            \"000105\": {\"customer_id\": \"000105\", \"name\": \"خانم مینو گلشن\", \"city\": \"\"},\n            \"000106\": {\"customer_id\": \"000106\", \"name\": \"آقای مهدی مختاری\", \"city\": \"هوم ایرانمال\"},\n            \"000107\": {\"customer_id\": \"000107\", \"name\": \"خانم پرویزی\", \"city\": \"شهریار\"},\n            \"000108\": {\"customer_id\": \"000108\", \"name\": \"آقای پیام صالحی\", \"city\": \"آرتین مود\"},\n            \"000114\": {\"customer_id\": \"000114\", \"name\": \"سلف بستنی باران\", \"city\": \"\"},\n            \"000116\": {\"customer_id\": \"000116\", \"name\": \"هایپر حس نو\", \"city\": \"\"}\n        }\n        \n        logger.info(f\"Customer database initialized with {len(self.customers)} customers\")\n    \n    def authenticate_customer(self, customer_code: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Authenticate customer by customer code\"\"\"\n        # Clean the input code\n        customer_code = customer_code.strip().replace(' ', '').replace('-', '')\n        \n        # Check if code is exactly 6 digits\n        if not customer_code.isdigit() or len(customer_code) != 6:\n            logger.warning(f\"Invalid customer code format: {customer_code}\")\n            return None\n        \n        # Check if customer exists\n        customer = self.customers.get(customer_code)\n        \n        if customer:\n            logger.info(f\"Customer authenticated successfully: {customer['name']} from {customer['city']}\")\n            return customer.copy()\n        else:\n            logger.warning(f\"Customer code not found: {customer_code}\")\n            return None\n    \n    def get_customer_by_id(self, customer_id: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Get customer information by ID\"\"\"\n        return self.customers.get(customer_id)\n    \n    def get_all_customers(self) -> List[Dict[str, Any]]:\n        \"\"\"Get all customers (for admin use)\"\"\"\n        return list(self.customers.values())\n    \n    def get_customers_by_city(self, city: str) -> List[Dict[str, Any]]:\n        \"\"\"Get all customers from a specific city\"\"\"\n        return [customer for customer in self.customers.values() if customer['city'] == city]\n    \n    def get_customer_count(self) -> int:\n        \"\"\"Get total number of registered customers\"\"\"\n        return len(self.customers)\n    \n    def get_cities(self) -> List[str]:\n        \"\"\"Get list of all cities\"\"\"\n        cities = set(customer['city'] for customer in self.customers.values())\n        return sorted(list(cities))\n    \n    def is_valid_customer_code(self, customer_code: str) -> bool:\n        \"\"\"Check if customer code format is valid\"\"\"\n        if not customer_code:\n            return False\n        \n        # Clean the input code\n        customer_code = customer_code.strip().replace(' ', '').replace('-', '')\n        \n        # Check if code is exactly 6 digits\n        return customer_code.isdigit() and len(customer_code) == 6\n    \n    def add_customer(self, customer_code: str, name: str, city: str) -> bool:\n        \"\"\"Add a new customer (admin function)\"\"\"\n        if not self.is_valid_customer_code(customer_code):\n            logger.error(f\"Invalid customer code format: {customer_code}\")\n            return False\n        \n        if customer_code in self.customers:\n            logger.warning(f\"Customer code already exists: {customer_code}\")\n            return False\n        \n        self.customers[customer_code] = {\n            'customer_id': customer_code,\n            'name': name,\n            'city': city\n        }\n        \n        logger.info(f\"New customer added: {name} from {city} with code {customer_code}\")\n        return True\n    \n    def update_customer(self, customer_code: str, name: str = None, city: str = None) -> bool:\n        \"\"\"Update customer information\"\"\"\n        if customer_code not in self.customers:\n            logger.error(f\"Customer not found: {customer_code}\")\n            return False\n        \n        customer = self.customers[customer_code]\n        \n        if name:\n            customer['name'] = name\n        if city:\n            customer['city'] = city\n        \n        logger.info(f\"Customer updated: {customer_code}\")\n        return True\n    \n    def remove_customer(self, customer_code: str) -> bool:\n        \"\"\"Remove a customer (admin function)\"\"\"\n        if customer_code not in self.customers:\n            logger.error(f\"Customer not found: {customer_code}\")\n            return False\n        \n        customer_name = self.customers[customer_code]['name']\n        del self.customers[customer_code]\n        \n        logger.info(f\"Customer removed: {customer_name} ({customer_code})\")\n        return True\n","size_bytes":17190},"data/product_data.py":{"content":"#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nfrom typing import List, Dict, Any, Optional\n\n# Persian alphabet for search\nPERSIAN_ALPHABET = [\n    'آ', 'ا', 'ب', 'پ', 'ت', 'ث', 'ج', 'چ', 'ح', 'خ', 'د', 'ذ', 'ر', 'ز', 'ژ',\n    'س', 'ش', 'ص', 'ض', 'ط', 'ظ', 'ع', 'غ', 'ف', 'ق', 'ک', 'گ', 'ل', 'م', 'ن',\n    'و', 'ه', 'ی'\n]\n\n# Product prices by category\nPRODUCT_PRICES = {\n    'baby': 4780000,\n    'teen': 4780000,\n    'adult': 5600000,\n    'curtain_only': 1550000,  # Base price for silk-cotton fabric\n    'cushion': 2800000,\n    'tablecloth': 2400000  # Base price (will be overridden by size-based pricing)\n}\n\n# Fabric-based pricing for curtains\nCURTAIN_FABRIC_PRICES = {\n    'silk_cotton': 1550000,  # حریر کتان\n    'velvet': 1950000        # مخمل\n}\n\n# Size-based pricing for tablecloth category\nTABLECLOTH_SIZE_PRICES = {\n    '120×80': 2400000,\n    '100×100': 2400000,\n    '100×150': 3600000,\n    '120×180': 5200000\n}\n\n# Special pricing for specific products\nSPECIAL_PRODUCT_PRICES = {\n    'cushion_5': 585000,  # کوسن مخمل گیم دسته بازی سفید\n    'cushion_6': 585000,  # کوسن مخمل گیم zone\n    'cushion_7': 855000,  # کوسن مخمل awsd\n    'cushion_8': 855000,  # کوسن مخمل ENTER\n    'cushion_9': 3350000,  # کوسن مخمل گیم PS-KING\n    'cushion_10': 585000,  # کوسن مخمل گیم دسته بازی سیاه\n    'curtain_15': 1950000,  # پرده حریر سرتخت (جفت) - قیمت ثابت\n}\n\n# Product categories with updated icons and search characters\nPRODUCT_CATEGORIES = {\n    'baby': {\n        'name':\n        '👶 کالای خواب نوزاد',\n        'price':\n        4780000,\n        'products': [{\n            'id': 'baby_1',\n            'name': 'آنجل',\n            'icon': '👼',\n            'search_char': 'آ'\n        }, {\n            'id': 'baby_2',\n            'name': 'آلیسون',\n            'icon': '🌸',\n            'search_char': 'آ'\n        }, {\n            'id': 'baby_3',\n            'name': 'باربی',\n            'icon': '💄',\n            'search_char': 'ب'\n        }, {\n            'id': 'baby_4',\n            'name': 'باستر',\n            'icon': '🚀',\n            'search_char': 'ب'\n        }, {\n            'id': 'baby_5',\n            'name': 'بلا',\n            'icon': '🌟',\n            'search_char': 'ب'\n        }, {\n            'id': 'baby_6',\n            'name': 'بو',\n            'icon': '👻',\n            'search_char': 'ب'\n        }, {\n            'id': 'baby_7',\n            'name': 'پدینگتون',\n            'icon': '🧸',\n            'search_char': 'پ'\n        }, {\n            'id': 'baby_8',\n            'name': 'دریم بیگ',\n            'icon': '💤',\n            'search_char': 'د'\n        }, {\n            'id': 'baby_9',\n            'name': 'رینبو',\n            'icon': '🌈',\n            'search_char': 'ر'\n        }, {\n            'id': 'baby_10',\n            'name': 'سوفی',\n            'icon': '👶',\n            'search_char': 'س'\n        }, {\n            'id': 'baby_11',\n            'name': 'شوکا',\n            'icon': '🍭',\n            'search_char': 'ش'\n        }, {\n            'id': 'baby_12',\n            'name': 'فارست',\n            'icon': '🌲',\n            'search_char': 'ف'\n        }, {\n            'id': 'baby_13',\n            'name': 'کیوت بیر',\n            'icon': '🧸',\n            'search_char': 'ک'\n        }, {\n            'id': 'baby_14',\n            'name': 'لئو',\n            'icon': '🦁',\n            'search_char': 'ل'\n        }, {\n            'id': 'baby_15',\n            'name': 'مدل ویکی',\n            'icon': '🦄',\n            'search_char': 'م'\n        }, {\n            'id': 'baby_16',\n            'name': 'ولکام',\n            'icon': '🎉',\n            'search_char': 'و'\n        }, {\n            'id': 'baby_17',\n            'name': 'هپی طوسی',\n            'icon': '😊',\n            'search_char': 'ه'\n        }, {\n            'id': 'baby_18',\n            'name': 'هپی صورتی',\n            'icon': '💖',\n            'search_char': 'ه'\n        }, {\n            'id': 'baby_19',\n            'name': 'یونیکورن',\n            'icon': '🦄',\n            'search_char': 'ی'\n        }]\n    },\n    'teen': {\n        'name':\n        '🧒 کالای خواب نوجوان',\n        'price':\n        4780000,\n        'products': [{\n            'id': 'teen_1',\n            'name': 'آرتا طوسی',\n            'icon': '🎨',\n            'search_char': 'آ'\n        }, {\n            'id': 'teen_2',\n            'name': 'A4 سورمه ایی',\n            'icon': '📄',\n            'search_char': 'ا'\n        }, {\n            'id': 'teen_3',\n            'name': 'بالرین سبز چین دار',\n            'icon': '🩰',\n            'search_char': 'ب'\n        }, {\n            'id': 'teen_4',\n            'name': 'بالرین سبز بدون چین',\n            'icon': '💚',\n            'search_char': 'ب'\n        }, {\n            'id': 'teen_5',\n            'name': 'بالرین طوسی چین دار',\n            'icon': '🩰',\n            'search_char': 'ب'\n        }, {\n            'id': 'teen_6',\n            'name': 'بالرین طوسی بدون چین',\n            'icon': '🤍',\n            'search_char': 'ب'\n        }, {\n            'id': 'teen_7',\n            'name': 'پارادایس',\n            'icon': '🏝️',\n            'search_char': 'پ'\n        }, {\n            'id': 'teen_8',\n            'name': 'گیم',\n            'icon': '🎯',\n            'search_char': 'گ'\n        }, {\n            'id': 'teen_9',\n            'name': 'گوتیک',\n            'icon': '🖤',\n            'search_char': 'گ'\n        }, {\n            'id': 'teen_10',\n            'name': 'گرافیت طوسی',\n            'icon': '✏️',\n            'search_char': 'گ'\n        }, {\n            'id': 'teen_11',\n            'name': 'کاج',\n            'icon': '🌲',\n            'search_char': 'ک'\n        }, {\n            'id': 'teen_12',\n            'name': 'کارن A4 سورمه ایی',\n            'icon': '📋',\n            'search_char': 'ک'\n        }, {\n            'id': 'teen_13',\n            'name': 'مدل گیم قرمز',\n            'icon': '🎮',\n            'search_char': 'م'\n        }, {\n            'id': 'teen_14',\n            'name': 'فضا',\n            'icon': '🚀',\n            'search_char': 'ف'\n        }]\n    },\n    'adult': {\n        'name':\n        '👨 کالای خواب بزرگسال',\n        'price':\n        5600000,\n        'products': [{\n            'id': 'adult_1',\n            'name': 'آوانگارد',\n            'icon': '🎭',\n            'search_char': 'آ'\n        }, {\n            'id': 'adult_2',\n            'name': 'آرتا طوسی',\n            'icon': '🎨',\n            'search_char': 'آ'\n        }, {\n            'id': 'adult_3',\n            'name': 'برگ طوسی',\n            'icon': '🍃',\n            'search_char': 'ب'\n        }, {\n            'id': 'adult_4',\n            'name': 'بوهو',\n            'icon': '🌻',\n            'search_char': 'ب'\n        }, {\n            'id': 'adult_5',\n            'name': 'پارادایس طوسی',\n            'icon': '🏖️',\n            'search_char': 'پ'\n        }, {\n            'id': 'adult_6',\n            'name': 'فرشته',\n            'icon': '😇',\n            'search_char': 'ف'\n        }, {\n            'id': 'adult_7',\n            'name': 'گوتیک',\n            'icon': '🖤',\n            'search_char': 'گ'\n        }, {\n            'id': 'adult_8',\n            'name': 'هلن',\n            'icon': '👑',\n            'search_char': 'ه'\n        }]\n    },\n    'curtain_only': {\n        'name':\n        '🪟 پرده',\n        'price':\n        1550000,\n        'products': [{\n            'id': 'curtain_1',\n            'name': 'فارست',\n            'icon': '🌲',\n            'search_char': 'ف'\n        }, {\n            'id': 'curtain_2',\n            'name': 'گیم',\n            'icon': '🎮',\n            'search_char': 'گ'\n        }, {\n            'id': 'curtain_3',\n            'name': 'کیوت بیر',\n            'icon': '🧸',\n            'search_char': 'ک'\n        }, {\n            'id': 'curtain_4',\n            'name': 'بو',\n            'icon': '👻',\n            'search_char': 'ب'\n        }, {\n            'id': 'curtain_5',\n            'name': 'پدینگتون',\n            'icon': '🧸',\n            'search_char': 'پ'\n        }, {\n            'id': 'curtain_6',\n            'name': 'آنجل',\n            'icon': '👼',\n            'search_char': 'آ'\n        }, {\n            'id': 'curtain_7',\n            'name': 'الیسون',\n            'icon': '🌸',\n            'search_char': 'ا'\n        }, {\n            'id': 'curtain_8',\n            'name': 'ولکام',\n            'icon': '🎉',\n            'search_char': 'و'\n        }, {\n            'id': 'curtain_9',\n            'name': 'دریم بیگ',\n            'icon': '💤',\n            'search_char': 'د'\n        }, {\n            'id': 'curtain_10',\n            'name': 'چیکو',\n            'icon': '🐥',\n            'search_char': 'چ'\n        }, {\n            'id': 'curtain_11',\n            'name': 'ویکی',\n            'icon': '🦄',\n            'search_char': 'و'\n        }, {\n            'id': 'curtain_12',\n            'name': 'هپی طوسی',\n            'icon': '😊',\n            'search_char': 'ه'\n        }, {\n            'id': 'curtain_13',\n            'name': 'هپی صورتی',\n            'icon': '💖',\n            'search_char': 'ه'\n        }, {\n            'id': 'curtain_14',\n            'name': 'یونیکورن',\n            'icon': '🦄',\n            'search_char': 'ی'\n        }, {\n            'id': 'curtain_15',\n            'name': 'پرده حریر سرتخت (جفت)',\n            'icon': '🪟',\n            'search_char': 'پ'\n        }, {\n            'id': 'curtain_16',\n            'name': 'رینبو',\n            'icon': '🌈',\n            'search_char': 'ر'\n        }, {\n            'id': 'curtain_17',\n            'name': 'GT قرمز',\n            'icon': '🏎️',\n            'search_char': 'گ'\n        }]\n    },\n    'cushion': {\n        'name':\n        '🧸 کوسن و عروسک',\n        'price':\n        2800000,\n        'products': [{\n            'id': 'cushion_5',\n            'name': 'کوسن مخمل گیم دسته بازی سفید',\n            'icon': '🎮',\n            'search_char': 'ک'\n        }, {\n            'id': 'cushion_6',\n            'name': 'کوسن مخمل گیم zone',\n            'icon': '🎯',\n            'search_char': 'ک'\n        }, {\n            'id': 'cushion_7',\n            'name': 'کوسن مخمل awsd',\n            'icon': '⌨️',\n            'search_char': 'ک'\n        }, {\n            'id': 'cushion_8',\n            'name': 'کوسن مخمل ENTER',\n            'icon': '⏎',\n            'search_char': 'ک'\n        }, {\n            'id': 'cushion_9',\n            'name': 'کوسن مخمل گیم PS-KING',\n            'icon': '🎮',\n            'search_char': 'ک'\n        }, {\n            'id': 'cushion_10',\n            'name': 'کوسن مخمل گیم دسته بازی سیاه',\n            'icon': '🖤',\n            'search_char': 'ک'\n        }]\n    },\n    'tablecloth': {\n        'name':\n        'فرشینه',\n        'price':\n        2400000,  # Base price for smallest size\n        'products': [{\n            'id': 'tablecloth_1',\n            'name': 'کیوت بیر',\n            'icon': '🧸',\n            'search_char': 'ک'\n        }, {\n            'id': 'tablecloth_2',\n            'name': 'مدل فارست',\n            'icon': '🌲',\n            'search_char': 'م'\n        }, {\n            'id': 'tablecloth_3',\n            'name': 'مدل گیم',\n            'icon': '🎮',\n            'search_char': 'م'\n        }, {\n            'id': 'tablecloth_4',\n            'name': 'مدل رینبو',\n            'icon': '🌈',\n            'search_char': 'م'\n        }, {\n            'id': 'tablecloth_5',\n            'name': 'مدل بو',\n            'icon': '👻',\n            'search_char': 'م'\n        }, {\n            'id': 'tablecloth_6',\n            'name': 'مدل پدینگتون',\n            'icon': '🧸',\n            'search_char': 'م'\n        }, {\n            'id': 'tablecloth_7',\n            'name': 'مدل هپی سیتی',\n            'icon': '🏙️',\n            'search_char': 'م'\n        }, {\n            'id': 'tablecloth_8',\n            'name': 'مدل هپی طوسی',\n            'icon': '😊',\n            'search_char': 'م'\n        }, {\n            'id': 'tablecloth_9',\n            'name': 'مدل GTA',\n            'icon': '🚗',\n            'search_char': 'م'\n        }, {\n            'id': 'tablecloth_10',\n            'name': 'مدل یونیکورن',\n            'icon': '🦄',\n            'search_char': 'م'\n        }, {\n            'id': 'tablecloth_11',\n            'name': 'مدل باستر',\n            'icon': '🚀',\n            'search_char': 'م'\n        }, {\n            'id': 'tablecloth_12',\n            'name': 'مدل الیسون',\n            'icon': '🌸',\n            'search_char': 'م'\n        }, {\n            'id': 'tablecloth_13',\n            'name': 'مدل race',\n            'icon': '🏁',\n            'search_char': 'م'\n        }, {\n            'id': 'tablecloth_14',\n            'name': 'مدل هپی صورتی',\n            'icon': '💖',\n            'search_char': 'م'\n        }, {\n            'id': 'tablecloth_15',\n            'name': 'مدل ولکام',\n            'icon': '🎉',\n            'search_char': 'م'\n        }]\n    }\n}\n\n\ndef get_products_by_category(category_id: str) -> List[Dict[str, Any]]:\n    \"\"\"Get all products for a specific category\"\"\"\n    category = PRODUCT_CATEGORIES.get(category_id, {})\n    products = category.get('products', [])\n\n    # Add category_id to each product\n    for product in products:\n        product['category_id'] = category_id\n\n    return products\n\n\ndef get_product_by_id(product_id: str) -> Optional[Dict[str, Any]]:\n    \"\"\"Find a product by its ID across all categories\"\"\"\n    for category_id, category_info in PRODUCT_CATEGORIES.items():\n        for product in category_info.get('products', []):\n            if product['id'] == product_id:\n                product['category_id'] = category_id\n                # Add special price if exists\n                if product_id in SPECIAL_PRODUCT_PRICES:\n                    product['special_price'] = SPECIAL_PRODUCT_PRICES[\n                        product_id]\n                return product\n    return None\n\n\ndef get_product_price(product_id: str, category_id: str, size: str = None, fabric: str = None) -> int:\n    \"\"\"Get price for a specific product, checking for special pricing first\"\"\"\n    if product_id in SPECIAL_PRODUCT_PRICES:\n        return SPECIAL_PRODUCT_PRICES[product_id]\n    \n    # Size-based pricing for tablecloth category\n    if category_id == 'tablecloth' and size and size in TABLECLOTH_SIZE_PRICES:\n        return TABLECLOTH_SIZE_PRICES[size]\n    \n    # Fabric-based pricing for curtains\n    if category_id == 'curtain_only' and fabric and fabric in CURTAIN_FABRIC_PRICES:\n        return CURTAIN_FABRIC_PRICES[fabric]\n    \n    return PRODUCT_PRICES.get(category_id, 2800000)\n\n\ndef search_products_by_name(\n        category_id: str,\n        search_letter: str,\n        subcategory_id: Optional[str] = None) -> List[Dict[str, Any]]:\n    \"\"\"Search products by first letter in a category\"\"\"\n    # Handle subcategory mapping\n    actual_category = subcategory_id if subcategory_id else category_id\n\n    products = get_products_by_category(actual_category)\n\n    # Filter by first letter\n    filtered_products = []\n    for product in products:\n        if product.get('search_char', '').startswith(search_letter):\n            filtered_products.append(product)\n\n    return filtered_products\n\n\ndef get_category_info(category_id: str) -> Dict[str, Any]:\n    \"\"\"Get category information\"\"\"\n    return PRODUCT_CATEGORIES.get(category_id, {})\n\n\ndef get_all_categories() -> Dict[str, Any]:\n    \"\"\"Get all product categories\"\"\"\n    return PRODUCT_CATEGORIES\n\n\ndef get_category_product_icons(category_id: str) -> List[tuple]:\n    \"\"\"Get individual products with their icons and descriptions for a category\"\"\"\n    products = get_products_by_category(category_id)\n\n    # Return individual products instead of grouping\n    result = []\n    for product in products:\n        icon = product.get('icon', '🛍️')\n        description = product['name']  # Just the product name without emoji\n        result.append((icon, description,\n                       product['id']))  # Include product ID for callback\n\n    return result\n\n\ndef search_products_by_icon(category_id: str,\n                            target_icon: str) -> List[Dict[str, Any]]:\n    \"\"\"Search products by icon in a category\"\"\"\n    products = get_products_by_category(category_id)\n\n    # Filter by icon\n    filtered_products = []\n    for product in products:\n        if product.get('icon', '🛍️') == target_icon:\n            filtered_products.append(product)\n\n    return filtered_products\n","size_bytes":17332},"utils/__init__.py":{"content":"\"\"\"\nUtils Package\nContains utility functions for logging, Persian language support, and helper functions.\n\"\"\"\n","size_bytes":110},"utils/logger.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nLogging Configuration\nProvides centralized logging setup for the bot.\n\"\"\"\n\nimport logging\nimport os\nfrom datetime import datetime\n\ndef setup_logger(name: str, log_file: str = None, level: str = \"INFO\") -> logging.Logger:\n    \"\"\"\n    Set up a logger with both file and console handlers\n    \n    Args:\n        name: Logger name (usually __name__)\n        log_file: Path to log file (optional)\n        level: Logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL)\n    \n    Returns:\n        Configured logger instance\n    \"\"\"\n    \n    # Create logger\n    logger = logging.getLogger(name)\n    \n    # Check if logger already has handlers to avoid duplicate logs\n    if logger.handlers:\n        return logger\n    \n    # Set logging level\n    log_levels = {\n        \"DEBUG\": logging.DEBUG,\n        \"INFO\": logging.INFO,\n        \"WARNING\": logging.WARNING,\n        \"ERROR\": logging.ERROR,\n        \"CRITICAL\": logging.CRITICAL\n    }\n    logger.setLevel(log_levels.get(level.upper(), logging.INFO))\n    \n    # Create formatter\n    formatter = logging.Formatter(\n        '%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n        datefmt='%Y-%m-%d %H:%M:%S'\n    )\n    \n    # Console handler\n    console_handler = logging.StreamHandler()\n    console_handler.setFormatter(formatter)\n    logger.addHandler(console_handler)\n    \n    # File handler (if log_file is provided)\n    if log_file:\n        # Create log directory if it doesn't exist\n        log_dir = os.path.dirname(log_file)\n        if log_dir and not os.path.exists(log_dir):\n            os.makedirs(log_dir, exist_ok=True)\n        \n        file_handler = logging.FileHandler(log_file, encoding='utf-8')\n        file_handler.setFormatter(formatter)\n        logger.addHandler(file_handler)\n    \n    # Prevent propagation to root logger\n    logger.propagate = False\n    \n    return logger\n\ndef get_daily_log_file(base_name: str = \"bot\") -> str:\n    \"\"\"\n    Generate a daily log file name\n    \n    Args:\n        base_name: Base name for the log file\n    \n    Returns:\n        Path to daily log file\n    \"\"\"\n    today = datetime.now().strftime(\"%Y-%m-%d\")\n    log_dir = \"bot_logs\"\n    os.makedirs(log_dir, exist_ok=True)\n    return os.path.join(log_dir, f\"{base_name}_{today}.log\")\n","size_bytes":2255},"utils/persian_utils.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nPersian Language Utilities\nHelper functions for Persian text processing and formatting.\n\"\"\"\n\nimport re\nfrom typing import Union\n\n# Persian to English digit mapping\nPERSIAN_DIGITS = '۰۱۲۳۴۵۶۷۸۹'\nENGLISH_DIGITS = '0123456789'\n\n# Persian to English digit translation table\nPERSIAN_TO_ENGLISH = str.maketrans(PERSIAN_DIGITS, ENGLISH_DIGITS)\nENGLISH_TO_PERSIAN = str.maketrans(ENGLISH_DIGITS, PERSIAN_DIGITS)\n\ndef persian_numbers(text: str) -> str:\n    \"\"\"\n    Convert English numbers to Persian numbers\n    \n    Args:\n        text: Text containing English digits\n    \n    Returns:\n        Text with Persian digits\n    \"\"\"\n    return text.translate(ENGLISH_TO_PERSIAN)\n\ndef english_numbers(text: str) -> str:\n    \"\"\"\n    Convert Persian numbers to English numbers\n    \n    Args:\n        text: Text containing Persian digits\n    \n    Returns:\n        Text with English digits\n    \"\"\"\n    return text.translate(PERSIAN_TO_ENGLISH)\n\ndef format_price(price: Union[int, float]) -> str:\n    \"\"\"\n    Format price with Persian number separators\n    \n    Args:\n        price: Price value\n    \n    Returns:\n        Formatted price string with Persian digits and separators\n    \"\"\"\n    if isinstance(price, float):\n        price = int(price)\n    \n    # Add thousand separators\n    price_str = f\"{price:,}\"\n    \n    # Convert to Persian digits\n    price_str = persian_numbers(price_str)\n    \n    return price_str\n\ndef clean_persian_text(text: str) -> str:\n    \"\"\"\n    Clean and normalize Persian text\n    \n    Args:\n        text: Persian text to clean\n    \n    Returns:\n        Cleaned Persian text\n    \"\"\"\n    if not text:\n        return \"\"\n    \n    # Remove extra whitespaces\n    text = re.sub(r'\\s+', ' ', text.strip())\n    \n    # Normalize Persian characters\n    text = text.replace('ك', 'ک')  # Arabic Kaf to Persian Kaf\n    text = text.replace('ي', 'ی')  # Arabic Yeh to Persian Yeh\n    text = text.replace('ة', 'ه')  # Arabic Teh Marbuta to Heh\n    \n    return text\n\ndef is_persian_text(text: str) -> bool:\n    \"\"\"\n    Check if text contains Persian characters\n    \n    Args:\n        text: Text to check\n    \n    Returns:\n        True if text contains Persian characters\n    \"\"\"\n    persian_pattern = r'[\\u0600-\\u06FF\\u200C\\u200D]'\n    return bool(re.search(persian_pattern, text))\n\ndef extract_numbers(text: str) -> list:\n    \"\"\"\n    Extract all numbers (Persian and English) from text\n    \n    Args:\n        text: Text to extract numbers from\n    \n    Returns:\n        List of extracted numbers as integers\n    \"\"\"\n    # Convert Persian digits to English first\n    text = english_numbers(text)\n    \n    # Find all numbers\n    numbers = re.findall(r'\\d+', text)\n    \n    # Convert to integers\n    return [int(num) for num in numbers]\n\ndef format_phone_number(phone: str) -> str:\n    \"\"\"\n    Format Iranian phone number\n    \n    Args:\n        phone: Phone number string\n    \n    Returns:\n        Formatted phone number\n    \"\"\"\n    # Remove all non-digit characters\n    phone = re.sub(r'\\D', '', english_numbers(phone))\n    \n    # Iranian mobile number formatting\n    if len(phone) == 11 and phone.startswith('09'):\n        return persian_numbers(f\"{phone[:4]}-{phone[4:7]}-{phone[7:]}\")\n    elif len(phone) == 10 and phone.startswith('9'):\n        return persian_numbers(f\"۰{phone[:3]}-{phone[3:6]}-{phone[6:]}\")\n    \n    # Return as-is if doesn't match expected patterns\n    return persian_numbers(phone)\n\ndef truncate_persian_text(text: str, max_length: int, suffix: str = \"...\") -> str:\n    \"\"\"\n    Truncate Persian text to specified length\n    \n    Args:\n        text: Text to truncate\n        max_length: Maximum allowed length\n        suffix: Suffix to add when truncating\n    \n    Returns:\n        Truncated text\n    \"\"\"\n    if len(text) <= max_length:\n        return text\n    \n    truncated = text[:max_length - len(suffix)]\n    \n    # Try to break at word boundary\n    last_space = truncated.rfind(' ')\n    if last_space > max_length // 2:\n        truncated = truncated[:last_space]\n    \n    return truncated + suffix\n","size_bytes":4061},"payment_data/bot/__init__.py":{"content":"\"\"\"\nBot Package\nContains all bot-related functionality including handlers, keyboards, and cart management.\n\"\"\"\n","size_bytes":111},"payment_data/bot/cart.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nShopping Cart Management\nHandles cart operations with JSON file-based persistence.\n\"\"\"\n\nimport json\nimport os\nfrom typing import List, Dict, Any, Optional\nfrom utils.logger import setup_logger\n\nlogger = setup_logger(__name__)\n\nclass CartManager:\n    \"\"\"Manages shopping cart operations with file-based persistence\"\"\"\n    \n    def __init__(self, cart_data_dir: str = \"cart_data\"):\n        self.cart_data_dir = cart_data_dir\n        # Ensure cart data directory exists\n        os.makedirs(self.cart_data_dir, exist_ok=True)\n    \n    def _get_cart_file_path(self, user_id: int) -> str:\n        \"\"\"Get the file path for a user's cart\"\"\"\n        return os.path.join(self.cart_data_dir, f\"cart_{user_id}.json\")\n    \n    def get_cart(self, user_id: int) -> List[Dict[str, Any]]:\n        \"\"\"Get cart items for a user\"\"\"\n        cart_file = self._get_cart_file_path(user_id)\n        \n        try:\n            if os.path.exists(cart_file):\n                with open(cart_file, 'r', encoding='utf-8') as f:\n                    return json.load(f)\n            return []\n        except Exception as e:\n            logger.error(f\"Error loading cart for user {user_id}: {e}\")\n            return []\n    \n    def save_cart(self, user_id: int, cart_items: List[Dict[str, Any]]) -> bool:\n        \"\"\"Save cart items for a user\"\"\"\n        cart_file = self._get_cart_file_path(user_id)\n        \n        try:\n            with open(cart_file, 'w', encoding='utf-8') as f:\n                json.dump(cart_items, f, ensure_ascii=False, indent=2)\n            logger.info(f\"Cart saved for user {user_id}: {len(cart_items)} items\")\n            return True\n        except Exception as e:\n            logger.error(f\"Error saving cart for user {user_id}: {e}\")\n            return False\n    \n    def add_to_cart(self, user_id: int, item: Dict[str, Any]) -> bool:\n        \"\"\"Add an item to user's cart\"\"\"\n        cart_items = self.get_cart(user_id)\n        \n        # Check if item already exists in cart\n        existing_item = None\n        for cart_item in cart_items:\n            if (cart_item['product_id'] == item['product_id'] and \n                cart_item['size'] == item['size']):\n                existing_item = cart_item\n                break\n        \n        if existing_item:\n            # Update quantity\n            existing_item['quantity'] += item['quantity']\n            logger.info(f\"Updated quantity for product {item['product_id']} in cart of user {user_id}\")\n        else:\n            # Add new item\n            cart_items.append(item)\n            logger.info(f\"Added new product {item['product_id']} to cart of user {user_id}\")\n        \n        return self.save_cart(user_id, cart_items)\n    \n    def remove_from_cart(self, user_id: int, product_id: str, size: str) -> bool:\n        \"\"\"Remove an item from user's cart\"\"\"\n        cart_items = self.get_cart(user_id)\n        \n        # Find and remove the item\n        cart_items = [\n            item for item in cart_items \n            if not (item['product_id'] == product_id and item['size'] == size)\n        ]\n        \n        logger.info(f\"Removed product {product_id} (size {size}) from cart of user {user_id}\")\n        return self.save_cart(user_id, cart_items)\n    \n    def update_quantity(self, user_id: int, product_id: str, size: str, new_quantity: int) -> bool:\n        \"\"\"Update quantity of an item in user's cart\"\"\"\n        cart_items = self.get_cart(user_id)\n        \n        for item in cart_items:\n            if item['product_id'] == product_id and item['size'] == size:\n                if new_quantity <= 0:\n                    # Remove item if quantity is 0 or negative\n                    return self.remove_from_cart(user_id, product_id, size)\n                else:\n                    item['quantity'] = new_quantity\n                    logger.info(f\"Updated quantity of product {product_id} to {new_quantity} for user {user_id}\")\n                    return self.save_cart(user_id, cart_items)\n        \n        logger.warning(f\"Product {product_id} (size {size}) not found in cart of user {user_id}\")\n        return False\n    \n    def clear_cart(self, user_id: int) -> bool:\n        \"\"\"Clear all items from user's cart\"\"\"\n        return self.save_cart(user_id, [])\n    \n    def get_cart_total(self, user_id: int) -> float:\n        \"\"\"Calculate total price of items in user's cart\"\"\"\n        cart_items = self.get_cart(user_id)\n        total = sum(item['price'] * item['quantity'] for item in cart_items)\n        return total\n    \n    def get_cart_item_count(self, user_id: int) -> int:\n        \"\"\"Get total number of items in user's cart\"\"\"\n        cart_items = self.get_cart(user_id)\n        return sum(item['quantity'] for item in cart_items)\n    \n    def is_cart_empty(self, user_id: int) -> bool:\n        \"\"\"Check if user's cart is empty\"\"\"\n        cart_items = self.get_cart(user_id)\n        return len(cart_items) == 0\n    \n    def get_cart_summary(self, user_id: int) -> Dict[str, Any]:\n        \"\"\"Get a summary of user's cart\"\"\"\n        cart_items = self.get_cart(user_id)\n        \n        return {\n            'items': cart_items,\n            'item_count': sum(item['quantity'] for item in cart_items),\n            'total_price': sum(item['price'] * item['quantity'] for item in cart_items),\n            'unique_products': len(cart_items)\n        }\n","size_bytes":5344},"payment_data/bot/config.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nBot Configuration - Fixed Version\nManages environment variables and configuration settings.\n\"\"\"\n\nimport os\nimport logging\nfrom typing import List, Optional\n\n\nclass Config:\n    \"\"\"Configuration class for the Telegram bot\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize configuration from environment variables\"\"\"\n        # Get bot token from environment or use provided token\n        self.bot_token: str = os.getenv(\"BOT_TOKEN\", \"482872229:AAEG0hySlWspi-KOF5lbR2fMZGJ1qWUPLn0\")\n\n        if not self.bot_token:\n            raise ValueError(\"BOT_TOKEN not found in environment variables\")\n\n        # ZarinPal configuration - using your provided merchant ID\n        self.zarinpal_merchant_id: str = os.getenv(\n            \"ZARINPAL_MERCHANT_ID\", \"fd4166f9-78e2-4228-ac7d-077a5168f064\")\n        self.zarinpal_sandbox: bool = os.getenv(\"ZARINPAL_SANDBOX\",\n                                                \"True\").lower() == \"true\"\n\n        # Order group settings\n        self.order_group_chat_id = os.getenv('ORDER_GROUP_CHAT_ID')\n\n        # اگر تنظیم نشده، از Chat ID گروه DecoTeen Bot Orders استفاده کن\n        if not self.order_group_chat_id:\n            # Chat ID از عکس: -4804296164 (گروه DecoTeen Bot Orders)\n            self.order_group_chat_id = -4804296164\n            logging.info(\n                f\"✅ استفاده از گروه پیش‌فرض: {self.order_group_chat_id}\")\n        else:\n            # تبدیل به int\n            try:\n                self.order_group_chat_id = int(self.order_group_chat_id)\n                logging.info(\n                    f\"✅ استفاده از گروه تنظیم شده: {self.order_group_chat_id}\")\n            except ValueError:\n                logging.error(\n                    f\"❌ ORDER_GROUP_CHAT_ID نامعتبر: {self.order_group_chat_id}\"\n                )\n                # استفاده از گروه پیش‌فرض\n                self.order_group_chat_id = -4804296164\n                logging.info(\n                    f\"✅ استفاده از گروه پیش‌فرض به جای نامعتبر: {self.order_group_chat_id}\"\n                )\n\n        # Optional configurations with safe defaults\n        self.admin_ids: List[int] = self._parse_admin_ids()\n        self.log_level: str = os.getenv(\"LOG_LEVEL\", \"INFO\")\n        self.cart_data_dir: str = os.getenv(\"CART_DATA_DIR\", \"cart_data\")\n        self.max_cart_items: int = int(os.getenv(\"MAX_CART_ITEMS\", \"50\"))\n\n        # Bot domain for payment callbacks\n        self.bot_domain: str = os.getenv(\"BOT_DOMAIN\", \"example.com\")\n\n    def _parse_admin_ids(self) -> List[int]:\n        \"\"\"Parse admin IDs from environment variable\"\"\"\n        admin_ids_str = os.getenv(\"ADMIN_IDS\", \"\")\n        if not admin_ids_str:\n            return []\n\n        try:\n            return [\n                int(id_str.strip()) for id_str in admin_ids_str.split(\",\")\n                if id_str.strip()\n            ]\n        except ValueError:\n            logging.warning(\"Invalid ADMIN_IDS format. Using empty list.\")\n            return []\n\n    def get_callback_url(self) -> str:\n        \"\"\"Get payment callback URL\"\"\"\n        return f\"https://{self.bot_domain}/payment/callback\"\n\n    def validate_setup(self) -> List[str]:\n        \"\"\"Validate configuration and return list of issues\"\"\"\n        issues = []\n\n        if not self.bot_token or self.bot_token == \"YOUR_BOT_TOKEN_HERE\":\n            issues.append(\"BOT_TOKEN is not set or using placeholder value\")\n\n        if not self.zarinpal_merchant_id or self.zarinpal_merchant_id == \"YOUR_MERCHANT_ID\":\n            issues.append(\n                \"ZARINPAL_MERCHANT_ID is not set or using placeholder value\")\n\n        if self.bot_domain == \"example.com\":\n            issues.append(\n                \"BOT_DOMAIN should be set to your actual domain (required for payment callbacks)\"\n            )\n\n        if not self.admin_ids:\n            issues.append(\"Consider setting ADMIN_IDS for bot administration\")\n\n        return issues\n\n    def print_config_status(self):\n        \"\"\"Print configuration status for debugging\"\"\"\n        print(\"=== Bot Configuration Status ===\")\n        print(f\"Bot Token: ✅ Set and Ready\")\n        print(\n            f\"ZarinPal Merchant ID: ✓ Set ({self.zarinpal_merchant_id[:8]}...{self.zarinpal_merchant_id[-8:]})\"\n        )\n        print(f\"Bot Domain: ✓ Set ({self.bot_domain})\")\n        print(f\"Callback URL: {self.get_callback_url()}\")\n        print(f\"Admin IDs: {len(self.admin_ids)} configured\")\n        print(f\"Order Group ID: ✓ Set ({self.order_group_chat_id})\")\n        print(\n            f\"ZarinPal Sandbox: {'Enabled' if self.zarinpal_sandbox else 'Disabled'}\"\n        )\n        print(f\"Max Cart Items: {self.max_cart_items}\")\n        print(\"================================\")\n\n        issues = self.validate_setup()\n        if issues:\n            print(\"⚠️ Configuration Notes:\")\n            for issue in issues:\n                print(f\"  - {issue}\")\n        else:\n            print(\"✅ Configuration is complete!\")\n\n    async def test_group_connection(self, bot):\n        \"\"\"Test connection to order group\"\"\"\n        if not self.order_group_chat_id:\n            print(\"❌ Order group ID not configured\")\n            return False\n\n        try:\n            # Try to get chat info\n            chat = await bot.get_chat(self.order_group_chat_id)\n            print(f\"✅ Group connection successful!\")\n            print(f\"   Title: {chat.title}\")\n            print(f\"   Type: {chat.type}\")\n            print(\n                f\"   Member count: {await bot.get_chat_member_count(self.order_group_chat_id)}\"\n            )\n            return True\n        except Exception as e:\n            print(f\"❌ Group connection failed: {e}\")\n            print(f\"   Group ID: {self.order_group_chat_id}\")\n            print(\"   Possible issues:\")\n            print(\"   - Bot is not a member of the group\")\n            print(\"   - Group ID is incorrect\")\n            print(\"   - Bot doesn't have permission to send messages\")\n            return False\n\n\n# Example usage and testing\nif __name__ == \"__main__\":\n    config = Config()\n    config.print_config_status()\n\n    print(\"\\n✅ Setup Complete! Your bot is ready to run!\")\n","size_bytes":6271},"payment_data/bot/handlers.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nBot Handlers\nMain bot handlers for commands, callbacks, and message processing.\n\"\"\"\n\nfrom telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup\nfrom telegram.ext import ContextTypes, CommandHandler, CallbackQueryHandler, MessageHandler, filters\nfrom bot.keyboards import BotKeyboards\nfrom bot.cart import CartManager\nfrom bot.pricing import PricingManager\nfrom bot.zarinpal import ZarinPalGateway\nfrom bot.payment_scheduler import PaymentScheduler\nfrom bot.order_server import OrderManagementServer, OrderStatus\nfrom bot.config import Config\nfrom data.customer_service import CustomerService\nfrom data.product_data import (get_products_by_category, get_product_by_id,\n                               search_products_by_name,\n                               search_products_by_icon, get_category_info,\n                               get_product_price, PERSIAN_ALPHABET, PRODUCT_PRICES)\nfrom utils.logger import setup_logger\nfrom utils.persian_utils import format_price, persian_numbers\nfrom datetime import datetime\nfrom typing import Dict, List\nimport json\n\nlogger = setup_logger(__name__)\n\n\nclass BotHandlers:\n    \"\"\"Main class handling all bot interactions\"\"\"\n\n    def __init__(self):\n        self.keyboards = BotKeyboards()\n        self.cart_manager = CartManager()\n        self.pricing_manager = PricingManager()\n        self.customer_service = CustomerService()\n        self.config = Config()\n        self.zarinpal = ZarinPalGateway(\n            merchant_id=self.config.zarinpal_merchant_id,\n            sandbox=self.config.zarinpal_sandbox)\n        self.payment_scheduler = PaymentScheduler()\n        self.order_server = OrderManagementServer()\n        self.user_sessions = {}  # Store user session data\n        self.bot = None  # Bot instance برای اطلاع‌رسانی\n        logger.info(\"🔄 PricingManager initialized with updated payment display configurations\")\n\n    def setup_handlers(self, application):\n        \"\"\"Setup all bot handlers\"\"\"\n        # تنظیم bot instance در سرور سفارشات و handlers\n        self.order_server.set_bot(application.bot)\n        self.bot = application.bot  # تنظیم bot instance در handlers\n\n        # Command handlers\n        application.add_handler(CommandHandler(\"start\", self.start_command))\n        application.add_handler(CommandHandler(\"help\", self.help_command))\n        application.add_handler(CommandHandler(\"debug\", self.debug_command))\n        application.add_handler(CommandHandler(\"pricing\", self.pricing_test_command))\n\n        # Callback query handlers\n        application.add_handler(CallbackQueryHandler(self.button_callback))\n\n        # Message handlers\n        application.add_handler(\n            MessageHandler(filters.TEXT & ~filters.COMMAND,\n                           self.handle_text_message))\n\n        # Photo handler for receipt uploads\n        application.add_handler(\n            MessageHandler(filters.PHOTO, self.handle_photo_message))\n\n        # Group message handler for support\n        application.add_handler(\n            MessageHandler(filters.TEXT & filters.ChatType.GROUPS,\n                           self.handle_group_message))\n\n        logger.info(\"✅ All handlers registered successfully\")\n\n    async def start_command(self, update: Update,\n                            context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Handle /start command\"\"\"\n        user_id = update.effective_user.id\n        logger.info(f\"User {user_id} started the bot\")\n\n        # Set user state to awaiting customer code directly\n        if user_id not in self.user_sessions:\n            self.user_sessions[user_id] = {}\n        self.user_sessions[user_id]['awaiting_customer_code'] = True\n\n        welcome_text = (\"🔐 خوش آمدید به فروشگاه دکوتین\\n\\n\"\n                        \"لطفاً کد شش رقمی نمایندگی خود را وارد کنید:\")\n\n        await update.message.reply_text(welcome_text)\n\n    async def help_command(self, update: Update,\n                            context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Handle /help command\"\"\"\n        help_text = (\"📋 راهنمای استفاده از ربات:\\n\\n\"\n                     \"🔹 /start - شروع کار با ربات\\n\"\n                     \"🔹 احراز هویت با کد نمایندگی\\n\"\n                     \"🔹 مرور محصولات بر اساس دسته‌بندی\\n\"\n                     \"🔹 جستجوی حروف الفبایی\\n\"\n                     \"🔹 انتخاب سایز و تعداد\\n\"\n                     \"🔹 افزودن به سبد خرید\\n\"\n                     \"🔹 مشاهده فاکتور و پرداخت\\n\\n\"\n                     \"💡 برای شروع دکمه «احراز هویت نماینده» را بزنید.\")\n        await update.message.reply_text(help_text)\n\n    async def debug_command(self, update: Update,\n                            context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Handle /debug command - for troubleshooting\"\"\"\n        chat_id = update.effective_chat.id\n        chat_type = update.effective_chat.type\n        user_id = update.effective_user.id\n\n        debug_info = (\n            f\"🔍 اطلاعات دیباگ:\\n\\n\"\n            f\"💬 Chat ID: {chat_id}\\n\"\n            f\"📝 Chat Type: {chat_type}\\n\"\n            f\"👤 User ID: {user_id}\\n\"\n            f\"⚙️ Configured Group ID: {self.config.order_group_chat_id}\\n\"\n            f\"✅ Match: {'YES' if str(chat_id) == str(self.config.order_group_chat_id) else 'NO'}\\n\\n\"\n            f\"📋 Test Commands:\\n\"\n            f\"• سفارش\\n\"\n            f\"• راهنما\\n\"\n            f\"• آمار\"\n        )\n\n        await update.message.reply_text(debug_info)\n\n        # ذخیره Chat ID برای استفاده آینده\n        logger.info(f\"🔧 DEBUG: Chat ID {chat_id} can be used as ORDER_GROUP_CHAT_ID\")\n\n    async def pricing_test_command(self, update: Update,\n                                  context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Handle /pricing command - test pricing functionality\"\"\"\n        test_items = [{\n            'product_name': 'تشک بچه تست',\n            'size': '120x60',\n            'quantity': 1,\n            'price': 4780000\n        }]\n        test_customer = {\n            'name': 'تست کاربر',\n            'city': 'تهران',\n            'customer_id': '123456'\n        }\n\n        # Test different pricing methods\n        cash_invoice = self.pricing_manager.generate_final_invoice(\n            test_items, test_customer, \"پرداخت نقدی\", 0.30)\n\n        pricing_info = (\n            f\"💰 تست سیستم قیمت‌گذاری:\\n\\n\"\n            f\"🔧 نرخ تخفیف نقدی: {self.pricing_manager.discount_rates.get('cash', 0) * 100}%\\n\"\n            f\"🔧 نرخ تخفیف اقساطی: {self.pricing_manager.discount_rates.get('installment', 0) * 100}%\\n\"\n            f\"🔧 نرخ تخفیف 90 روزه: {self.pricing_manager.discount_rates.get('90day', 0) * 100}%\\n\\n\"\n            f\"📄 نمونه فاکتور:\\n\"\n            f\"{cash_invoice[:200]}...\"\n        )\n\n        await update.message.reply_text(pricing_info)\n        logger.info(f\"💰 Pricing test executed for user {update.effective_user.id}\")\n\n    async def button_callback(self, update: Update,\n                              context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Handle all button callbacks - Optimized version\"\"\"\n        query = update.callback_query\n        user_id = query.from_user.id\n        data = query.data\n\n        # Fast answer to prevent timeout\n        await query.answer()\n\n        logger.debug(f\"User {user_id} pressed: {data}\")\n\n        # Quick routing dictionary for better performance\n        handlers = {\n            \"authenticate\": self._handle_authentication_request,\n            \"main_menu\": self._handle_main_menu,\n            \"start_shopping\": self._handle_start_shopping,\n            \"view_cart\": self._handle_view_cart,\n            \"view_invoice\": self._handle_view_invoice,\n            \"upload_receipt\": self._handle_upload_receipt_request,\n            \"confirm_payment_receipt\": self._handle_payment_receipt_confirmation,\n            \"confirm_payment_terms\": self._handle_payment_terms_confirmation,\n            \"confirm_order\": self._handle_order_confirmation,\n            \"cart_clear\": self._handle_cart_clear,\n            \"verify_payment\": self._handle_payment_verification,\n            \"payment_completed\": self._handle_payment_completed,\n            \"back_to_categories\": self._handle_back_to_categories,\n            \"back_to_alphabet\": self._handle_back_to_alphabet,\n            \"back_to_curtain_subcategories\": self._handle_back_to_curtain_subcategories,\n            \"back_to_products\": self._handle_back_to_products,\n            \"daily_stats\": self._handle_daily_stats_request,\n            \"refresh_daily_orders\": self._handle_refresh_daily_orders,\n            \"back_to_daily_orders\": self._handle_back_to_daily_orders,\n            \"contact_support\": self._handle_contact_support_request,\n            \"faq\": self._handle_faq_request,\n            \"confirm_60day_order\": self._handle_60day_order_confirmation,\n        }\n\n        try:\n            # Direct handler for exact matches\n            if data in handlers:\n                await handlers[data](query)\n                return\n\n            # Prefix-based routing for better performance\n            if data.startswith(\"category_\"):\n                await self._handle_category_selection(query, data)\n            elif data.startswith(\"subcategory_\"):\n                await self._handle_subcategory_selection(query, data)\n            elif data.startswith(\"alpha_\"):\n                await self._handle_alphabet_selection(query, data)\n            elif data.startswith(\"product_\"):\n                await self._handle_product_selection(query, data)\n            elif data.startswith(\"size_selection_\"):\n                await self._handle_size_selection_from_category(query, data)\n            elif data.startswith(\"size_\"):\n                await self._handle_size_selection(query, data)\n            elif data.startswith(\"qty_\"):\n                await self._handle_quantity_selection(query, data)\n            elif data.startswith(\"payment_\"):\n                await self._handle_payment_selection(query, data)\n            elif data.startswith(\"order_status_\"):\n                await self._handle_order_status_update(query, data)\n            elif data.startswith(\"order_details_\"):\n                await self._handle_order_details_request(query, data)\n            elif data.startswith(\"order_\"):\n                await self._handle_order_actions(query, data)\n            elif data.startswith(\"alphabet_search_\"):\n                await self._handle_alphabet_search(query, data)\n\n            elif data.startswith(\"fabric_\"):\n                await self._handle_fabric_selection(query, data)\n            elif data == \"back_to_fabric_selection\":\n                await self._handle_back_to_fabric_selection(query)\n            elif data.startswith(\"payment_confirmed_\"):\n                await self._handle_payment_confirmation_from_group(query, data)\n            elif data.startswith(\"contact_made_\"):\n                await self._handle_contact_made_from_group(query, data)\n            elif data.startswith(\"remind_tomorrow_\"):\n                await self._handle_remind_tomorrow_from_group(query, data)\n            else:\n                await query.edit_message_text(\" سفارش درحال پیگیری است .\")\n\n        except Exception as e:\n            logger.error(f\"Callback error {data}: {e}\")\n            try:\n                await query.edit_message_text(\"❌ خطایی رخ داد. لطفاً دوباره تلاش کنید.\")\n            except:\n                pass  # Prevent secondary errors\n\n    async def handle_text_message(self, update: Update,\n                                  context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Handle text messages\"\"\"\n        user_id = update.effective_user.id\n        text = update.message.text.strip()\n\n        # Check if user is in authentication process\n        if user_id in self.user_sessions and self.user_sessions[user_id].get(\n                'awaiting_customer_code'):\n            await self._handle_customer_code_input(update, text)\n        # Check if user is inputting curtain height\n        elif user_id in self.user_sessions and self.user_sessions[user_id].get(\n                'awaiting_curtain_height'):\n            await self._handle_curtain_height_input(update, text)\n        else:\n            await update.message.reply_text(\n                \"لطفاً از دکمه‌های موجود استفاده کنید.\",\n                reply_markup=self.keyboards.get_main_menu(\n                    self._is_authenticated(user_id)))\n\n    async def handle_photo_message(self, update: Update,\n                                   context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Handle photo messages (for receipt uploads)\"\"\"\n        user_id = update.effective_user.id\n\n        # Check if user is waiting for receipt upload\n        if (user_id in self.user_sessions and\n            self.user_sessions[user_id].get('payment_info', {}).get('awaiting_receipt')):\n\n            # Store photo info\n            photo = update.message.photo[-1]  # Get highest resolution photo\n            self.user_sessions[user_id]['receipt_photo'] = {\n                'file_id': photo.file_id,\n                'file_unique_id': photo.file_unique_id\n            }\n\n            # Get payment info for final invoice display\n            payment_info = self.user_sessions[user_id]['payment_info']\n            customer = self.user_sessions[user_id]['customer']\n            cart_items = self.cart_manager.get_cart(user_id)\n\n            # Generate final invoice text\n            final_invoice = (\n                f\"✅ فاکتور نهایی\\n\"\n                f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n                f\"👤 مشتری: {customer['name']}\\n\"\n                f\"🏙️ شهر: {customer['city']}\\n\"\n                f\"💳 روش پرداخت: {payment_info['payment_method']}\\n\\n\"\n                f\"💰 مبلغ کل: {format_price(payment_info['subtotal'])} تومان\\n\"\n                f\"🎁 تخفیف ({persian_numbers(str(int(payment_info['discount_rate'] * 100)))}٪): {format_price(payment_info['discount'])} تومان\\n\"\n                f\"💰 مبلغ پرداختی: {format_price(payment_info['amount'])} تومان\\n\\n\"\n                f\"📸 فیش واریزی دریافت شد\\n\"\n                f\"✅ آماده تایید نهایی سفارش\"\n            )\n\n            # Show confirmation button with final invoice\n            keyboard = [[\n                InlineKeyboardButton(\"✅ سفارش را تایید می‌کنم\", callback_data=\"confirm_payment_receipt\")\n            ], [\n                InlineKeyboardButton(\"🔄 ارسال عکس جدید\", callback_data=\"upload_receipt\")\n            ]]\n\n            await update.message.reply_text(\n                final_invoice,\n                reply_markup=InlineKeyboardMarkup(keyboard)\n            )\n        else:\n            await update.message.reply_text(\n                \"لطفاً ابتدا روش پرداخت را انتخاب کنید.\",\n                reply_markup=self.keyboards.get_main_menu(\n                    self._is_authenticated(user_id)))\n\n    async def handle_group_message(self, update: Update,\n                                   context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Handle messages in group chats (support group)\"\"\"\n        chat_id = update.effective_chat.id\n        message_text = update.message.text.strip() if update.message.text else \"\"\n        user_name = update.effective_user.first_name or \"کاربر\"\n\n        # Log group info for debugging\n        logger.info(f\"📩 Group message received:\")\n        logger.info(f\"   Chat ID: {chat_id} (type: {type(chat_id)})\")\n        logger.info(f\"   Chat Title: {getattr(update.effective_chat, 'title', 'N/A')}\")\n        logger.info(f\"   Message: '{message_text}'\")\n        logger.info(f\"   User: {user_name}\")\n        logger.info(f\"   Configured group ID: {self.config.order_group_chat_id} (type: {type(self.config.order_group_chat_id)})\")\n\n        # تبدیل chat_id به int برای مقایسه\n        try:\n            current_group_id = int(chat_id)\n            config_group_id = int(self.config.order_group_chat_id) if self.config.order_group_chat_id else None\n        except (ValueError, TypeError) as e:\n            logger.error(f\"Error converting chat IDs to int: {e}\")\n            return\n\n        # بررسی اینکه آیا این گروه، گروه مناسب هست یا نه\n        if config_group_id and current_group_id != config_group_id:\n            logger.info(f\"❌ پیام از گروه مختلف: {current_group_id} != {config_group_id}\")\n            return\n\n        # اگر هیچ group ID تنظیم نشده، این گروه را به عنوان گروه اصلی در نظر بگیر\n        if not config_group_id:\n            logger.warning(f\"⚠️ GROUP_CHAT_ID تنظیم نشده - استفاده از گروه فعلی: {current_group_id}\")\n            self.config.order_group_chat_id = current_group_id\n\n        logger.info(f\"✅ Processing group message: '{message_text}'\")\n\n        # اگر پیام خالی باشد، نادیده بگیر\n        if not message_text:\n            return\n\n        # فقط پردازش دستورات مشخص - جلوگیری از پردازش پیام‌های عادی\n        message_lower = message_text.lower().strip()\n\n        # لیست دقیق دستورات مجاز\n        valid_commands = [\n            'سفارش', 'سفارشات', 'order', 'orders',\n            'فاکتور', 'فاکتورها', 'invoice', 'invoices',\n            'آمار', 'stat', 'statistics',\n            'راهنما', 'help', 'کمک', 'دستور',\n            'ربات', 'bot', '@decoteen_bot'\n        ]\n\n        # بررسی آیا پیام شامل دستور معتبر است یا خیر\n        is_valid_command = False\n        for cmd in valid_commands:\n            if cmd in message_lower:\n                is_valid_command = True\n                break\n\n        # بررسی دستور وضعیت\n        if message_text.startswith('وضعیت ') or message_text.startswith('status '):\n            is_valid_command = True\n\n        # اگر پیام دستور معتبری نیست، آن را نادیده بگیر\n        if not is_valid_command:\n            logger.debug(f\"🔍 پیام عادی نادیده گرفته شد: '{message_text}'\")\n            return\n\n        try:\n            # پردازش دستورات معتبر\n            if any(word in message_lower for word in ['سفارش', 'سفارشات', 'order', 'orders']):\n                logger.info(\"🎯 دستور سفارش شناسایی شد\")\n                await self._show_daily_orders(update)\n                return\n            elif any(word in message_lower for word in ['فاکتور', 'فاکتورها', 'invoice', 'invoices']):\n                logger.info(\"🎯 دستور فاکتور شناسایی شد\")\n                await self._show_daily_invoices(update)\n                return\n            elif message_text.startswith('وضعیت ') or message_text.startswith('status '):\n                order_id = message_text.replace('وضعیت ', '').replace('status ', '').strip()\n                logger.info(f\"🎯 درخواست وضعیت سفارش: {order_id}\")\n                await self._show_order_status(update, order_id)\n                return\n            elif any(word in message_lower for word in ['آمار', 'stat', 'statistics']):\n                logger.info(\"🎯 دستور آمار شناسایی شد\")\n                await self._show_orders_statistics(update)\n                return\n            elif any(word in message_lower for word in ['راهنما', 'help', 'کمک', 'دستور']):\n                logger.info(\"🎯 دستور راهنما شناسایی شد\")\n                await self._show_group_help(update)\n                return\n            elif message_lower in ['ربات', 'bot', '@decoteen_bot']:\n                logger.info(\"🎯 دستور تست ربات شناسایی شد\")\n                await update.message.reply_text(\n                    \"🤖 ربات DecoTeen آماده خدمات‌رسانی است!\\n\\n\"\n                    \"📋 دستورات موجود:\\n\"\n                    \"• سفارش - نمایش سفارشات امروز\\n\"\n                    \"• فاکتور - نمایش فاکتورهای امروز\\n\"\n                    \"• آمار - نمایش آمار کلی\\n\"\n                    \"• راهنما - نمایش راهنمای کامل\\n\\n\"\n                    f\"🔧 Chat ID این گروه: {current_group_id}\"\n                )\n                return\n\n        except Exception as e:\n            logger.error(f\"❌ خطا در پردازش پیام گروه: {e}\")\n            logger.error(f\"Message: '{message_text}', Chat ID: {current_group_id}\")\n\n            # ارسال پیام خطا به گروه\n            try:\n                await update.message.reply_text(\n                    f\"❌ خطا در پردازش دستور: {str(e)[:100]}\\n\"\n                    \"لطفاً دوباره تلاش کنید یا با پشتیبانی تماس بگیرید.\"\n                )\n            except Exception as reply_error:\n                logger.error(f\"خطا در ارسال پیام خطا: {reply_error}\")\n\n        return\n\n    async def _show_daily_orders(self, update: Update):\n        \"\"\"Show today's orders as clickable summary with icons\"\"\"\n        try:\n            logger.info(\"🔍 درخواست نمایش سفارشات امروز\")\n\n            # Get today's orders\n            today_orders = await self.order_server.get_todays_orders()\n            logger.info(f\"📊 تعداد سفارشات امروز: {len(today_orders)}\")\n\n            if not today_orders:\n                await update.message.reply_text(\n                    f\"📊 سفارشات امروز ({persian_numbers(datetime.now().strftime('%Y/%m/%d'))})\\n\\n\"\n                    \"هیچ سفارش جدیدی امروز ثبت نشده است. 📋\\n\\n\"\n                    \"💡 برای تست می‌توانید یک سفارش جدید ثبت کنید.\"\n                )\n                return\n\n            # Create summary message with clickable icons\n            summary_text = (\n                f\"📊 سفارشات امروز ({persian_numbers(datetime.now().strftime('%Y/%m/%d'))})\\n\"\n                f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n                f\"📦 تعداد کل: {persian_numbers(str(len(today_orders)))}\\n\\n\"\n                f\"🔽 روی هر آیکون کلیک کنید تا فاکتور کامل را ببینید:\\n\\n\"\n            )\n\n            # Create inline keyboard with clickable order icons\n            keyboard = []\n            for i, order in enumerate(today_orders, 1):\n                customer = order.get('customer', {})\n                status_icon = \"🆕\" if order.get('status') == 'pending' else \"✅\"\n\n                button_text = f\"{status_icon} {persian_numbers(str(i))} - {customer.get('name', 'نامشخص')[:10]}\"\n                callback_data = f\"order_details_{order['order_id']}\"\n\n                keyboard.append([InlineKeyboardButton(button_text, callback_data=callback_data)])\n\n            # Add summary row at the bottom\n            keyboard.append([\n                InlineKeyboardButton(\"📈 آمار کلی\", callback_data=\"daily_stats\"),\n                InlineKeyboardButton(\"🔄 بروزرسانی\", callback_data=\"refresh_daily_orders\")\n            ])\n\n            await update.message.reply_text(\n                summary_text,\n                reply_markup=InlineKeyboardMarkup(keyboard)\n            )\n\n            logger.info(\"✅ لیست سفارشات امروز با موفقیت ارسال شد\")\n\n        except Exception as e:\n            logger.error(f\"❌ خطا در نمایش سفارشات روزانه: {e}\")\n            await update.message.reply_text(\n                f\"❌ خطا در نمایش سفارشات روزانه.\\n\"\n                f\"جزئیات: {str(e)[:100]}\\n\"\n                \"لطفاً دوباره تلاش کنید یا با پشتیبانی تماس بگیرید.\"\n            )\n\n    async def _show_daily_invoices(self, update: Update):\n        \"\"\"Show today's invoices in the group\"\"\"\n        try:\n            today_orders = await self.order_server.get_todays_orders()\n\n            if not today_orders:\n                await update.message.reply_text(\n                    \"📄 گزارش فاکتورهای امروز\\n\\n\"\n                    \"هیچ فاکتوری امروز صادر نشده است. 📋\"\n                )\n                return\n\n            invoice_text = (\n                f\"📄 فاکتورهای امروز ({persian_numbers(datetime.now().strftime('%Y/%m/%d'))})\\n\"\n                f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\\n\"\n            )\n\n            for i, order in enumerate(today_orders, 1):\n                customer = order.get('customer', {})\n                pricing = order.get('pricing', {})\n\n                invoice_text += (\n                    f\"{persian_numbers(str(i))}. 📋 {order['order_id']}\\n\"\n                    f\"   👤 {customer.get('name', 'نامشخص')}\\n\"\n                    f\"   🏙️ {customer.get('city', 'نامشخص')}\\n\"\n                    f\"   💰 {format_price(pricing.get('total', 0))} تومان\\n\"\n                    f\"   📊 {self.order_server._get_status_text(order.get('status', 'pending'))}\\n\\n\"\n                )\n\n            # Create action keyboard\n            keyboard = [\n                [\n                    InlineKeyboardButton(\"💾 ذخیره گزارش\", callback_data=\"save_daily_invoices\"),\n                    InlineKeyboardButton(\"📧 ارسال ایمیل\", callback_data=\"email_daily_invoices\")\n                ],\n                [\n                    InlineKeyboardButton(\"🔄 بروزرسانی\", callback_data=\"refresh_daily_invoices\")\n                ]\n            ]\n\n            await update.message.reply_text(\n                invoice_text,\n                reply_markup=InlineKeyboardMarkup(keyboard)\n            )\n\n        except Exception as e:\n            logger.error(f\"Error showing daily invoices: {e}\")\n            await update.message.reply_text(\n                \"❌ خطا در نمایش فاکتورهای روزانه. لطفاً دوباره تلاش کنید.\"\n            )\n\n    async def _show_order_status(self, update: Update, order_id: str):\n        \"\"\"Show specific order status\"\"\"\n        try:\n            order_data = await self.order_server.get_order_details(order_id)\n\n            if not order_data:\n                await update.message.reply_text(\n                    f\"❌ سفارش {order_id} یافت نشد.\\n\"\n                    \"لطفاً شماره سفارش را بررسی کنید.\"\n                )\n                return\n\n            status_text = self.order_server._get_status_text(order_data['status'])\n            customer = order_data.get('customer', {})\n            pricing = order_data.get('pricing', {})\n\n            order_info = (\n                f\"📋 وضعیت سفارش: {order_id}\\n\"\n                f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n                f\"👤 مشتری: {customer.get('name', 'نامشخص')}\\n\"\n                f\"🏙️ شهر: {customer.get('city', 'نامشخص')}\\n\"\n                f\"📊 وضعیت فعلی: {status_text}\\n\"\n                f\"💰 مبلغ کل: {format_price(pricing.get('total', 0))} تومان\\n\"\n                f\"⏰ تاریخ ثبت: {persian_numbers(order_data.get('created_at', '')[:10])}\\n\"\n            )\n\n            # Create management keyboard\n            keyboard = self.order_server._create_admin_buttons(order_id, order_data['user_id'])\n\n            await update.message.reply_text(\n                order_info,\n                reply_markup=InlineKeyboardMarkup(keyboard)\n            )\n\n        except Exception as e:\n            logger.error(f\"Error showing order status: {e}\")\n            await update.message.reply_text(\n                \"❌ خطا در نمایش وضعیت سفارش. لطفاً دوباره تلاش کنید.\"\n            )\n\n    async def _show_orders_statistics(self, update: Update):\n        \"\"\"Show orders statistics in the group\"\"\"\n        try:\n            stats = await self.order_server.get_orders_statistics()\n\n            if not stats:\n                await update.message.reply_text(\n                    \"📊 آمار سفارشات در دسترس نیست.\"\n                )\n                return\n\n            stats_text = (\n                f\"📊 آمار کلی سفارشات\\n\"\n                f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n                f\"📦 کل سفارشات: {persian_numbers(str(stats.get('total_orders', 0)))}\\n\"\n                f\"🆕 سفارشات امروز: {persian_numbers(str(stats.get('today_orders', 0)))}\\n\"\n                f\"💰 درآمد کل: {format_price(stats.get('total_revenue', 0))} تومان\\n\"\n                f\"💳 درآمد امروز: {format_price(stats.get('today_revenue', 0))} تومان\\n\\n\"\n                f\"📈 توزیع وضعیت:\\n\"\n            )\n\n            for status, count in stats.get('status_distribution', {}).items():\n                stats_text += f\"• {status}: {persian_numbers(str(count))}\\n\"\n\n            await update.message.reply_text(stats_text)\n\n        except Exception as e:\n            logger.error(f\"Error showing statistics: {e}\")\n            await update.message.reply_text(\n                \"❌ خطا در نمایش آمار. لطفاً دوباره تلاش کنید.\"\n            )\n\n    async def _show_group_help(self, update: Update):\n        \"\"\"Show help commands for group\"\"\"\n        help_text = (\n            \"🤖 راهنمای دستورات گروه\\n\"\n            \"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n            \"📋 سفارش / سفارشات - نمایش سفارشات امروز\\n\"\n            \"📄 فاکتور / فاکتورها - نمایش فاکتورهای امروز\\n\"\n            \"📊 آمار - نمایش آمار کلی\\n\"\n            \"🔍 وضعیت [شماره سفارش] - بررسی وضعیت سفارش\\n\"\n            \"❓ راهنما / کمک - نمایش این راهنما\\n\\n\"\n            \"💡 نکته: فقط در گروه پشتیبانی فعال است\"\n        )\n\n        await update.message.reply_text(help_text)\n\n    async def _send_order_invoice_card(self, update: Update, order: Dict):\n        \"\"\"Send order as invoice card with management buttons\"\"\"\n        try:\n            customer = order.get('customer', {})\n            pricing = order.get('pricing', {})\n            cart_items = order.get('cart_items', [])\n\n            # Create invoice card\n            invoice_card = (\n                f\"🧾 فاکتور - {order['order_id']}\\n\"\n                f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n                f\"👤 {customer.get('name', 'نامشخص')}\\n\"\n                f\"🏙️ {customer.get('city', 'نامشخص')}\\n\"\n                f\"🆔 کد نمایندگی: {customer.get('customer_id', 'نامشخص')}\\n\"\n                f\"📱 شناسه کاربر: {order.get('user_id', 'نامشخص')}\\n\"\n                f\"⏰ {persian_numbers(order.get('created_at', '')[:16].replace('T', ' - '))}\\n\\n\"\n                f\"📦 آیتم‌ها:\\n\"\n            )\n\n            # Add cart items\n            for i, item in enumerate(cart_items, 1):\n                item_total = item.get('price', 0) * item.get('quantity', 0)\n                invoice_card += (\n                    f\"{persian_numbers(str(i))}. {item.get('product_name', 'محصول')}\\n\"\n                    f\"   📏 {item.get('size', 'نامشخص')} | \"\n                    f\"📦 {persian_numbers(str(item.get('quantity', 0)))} عدد | \"\n                    f\"💰 {format_price(item_total)}\\n\"\n                )\n\n            # Add pricing\n            invoice_card += (\n                f\"\\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n                f\"💳 {order.get('payment_method', 'نقدی')}\\n\"\n                f\"💰 مبلغ کل: {format_price(pricing.get('total', 0))} تومان\\n\"\n                f\"📊 {self.order_server._get_status_text(order.get('status', 'pending'))}\"\n            )\n\n            # Create management keyboard\n            keyboard = [\n                [\n                    InlineKeyboardButton(\"📞 تماس\", callback_data=f\"order_status_{order['order_id']}_contacted\"),\n                    InlineKeyboardButton(\"✅ تایید\", callback_data=f\"order_status_{order['order_id']}_confirmed\"),\n                    InlineKeyboardButton(\"📦 آماده\", callback_data=f\"order_status_{order['order_id']}_ready\")\n                ],\n                [\n                    InlineKeyboardButton(\"🚚 ارسال\", callback_data=f\"order_status_{order['order_id']}_shipped\"),\n                    InlineKeyboardButton(\"🎉 تکمیل\", callback_data=f\"order_status_{order['order_id']}_completed\"),\n                    InlineKeyboardButton(\"❌ لغو\", callback_data=f\"order_status_{order['order_id']}_cancelled\")\n                ]\n            ]\n\n            await update.message.reply_text(\n                invoice_card,\n                reply_markup=InlineKeyboardMarkup(keyboard)\n            )\n\n        except Exception as e:\n            logger.error(f\"Error sending order invoice card: {e}\")\n\n    async def _send_order_summary_with_buttons(self, update: Update, order: Dict):\n        \"\"\"Send order summary with management buttons (kept for compatibility)\"\"\"\n        await self._send_order_invoice_card(update, order)\n\n    async def _handle_authentication_request(self, query):\n        \"\"\"Handle authentication request\"\"\"\n        user_id = query.from_user.id\n\n        # Set user state to awaiting customer code\n        if user_id not in self.user_sessions:\n            self.user_sessions[user_id] = {}\n        self.user_sessions[user_id]['awaiting_customer_code'] = True\n\n        text = (\"🔐 احراز هویت \\n\\n\"\n                \" لطفاً کد نمایندگی خود را وارد کنید:\")\n        await query.edit_message_text(text)\n\n    async def _handle_customer_code_input(self, update, customer_code):\n        \"\"\"Handle customer code input\"\"\"\n        user_id = update.effective_user.id\n\n        # Validate customer code\n        customer = self.customer_service.authenticate_customer(customer_code)\n\n        if customer:\n            # Authentication successful\n            self.user_sessions[user_id] = {\n                'authenticated': True,\n                'customer': customer,\n                'awaiting_customer_code': False\n            }\n\n            welcome_text = (f\"✅ خوش آمدید {customer['name']} عزیز!\\n\"\n                            f\"🏙️ شهر: {customer['city']}\\n\"\n                            f\"🆔 کد نمایندگی: {customer['customer_id']}\\n\\n\"\n                            \"\\n\"\n                            \"جهت سفارش محصول مورد نظر خودرا انتخاب نمایید:\")\n\n            keyboard = self.keyboards.get_categories_keyboard()\n            await update.message.reply_text(welcome_text,\n                                            reply_markup=keyboard)\n        else:\n            # Authentication failed\n            error_text = (\"❌ کد نمایندگی نامعتبر است.\\n\"\n                          \"لطفاً کد نمایندگی صحیح خود را وارد کنید:\")\n            await update.message.reply_text(error_text)\n\n    async def _handle_main_menu(self, query):\n        \"\"\"Handle main menu\"\"\"\n        user_id = query.from_user.id\n        authenticated = self._is_authenticated(user_id)\n\n        if authenticated:\n            customer = self.user_sessions[user_id]['customer']\n            text = (f\"🏠 منوی اصلی\\n\\n\"\n                    f\"👤 {customer['name']}\\n\"\n                    f\"🏙️ {customer['city']}\\n\\n\"\n                    \"یکی از گزینه‌های زیر را انتخاب کنید:\")\n        else:\n            text = \"🏠 منوی اصلی\\n\\nبرای شروع خرید، ابتدا احراز هویت کنید.\"\n\n        keyboard = self.keyboards.get_main_menu(authenticated)\n        await query.edit_message_text(text, reply_markup=keyboard)\n\n    async def _handle_start_shopping(self, query):\n        \"\"\"Handle start shopping\"\"\"\n        user_id = query.from_user.id\n\n        if not self._is_authenticated(user_id):\n            await query.edit_message_text(\"ابتدا باید احراز هویت کنید.\")\n            return\n\n        text = (\"عالیه \\n\\n\"\n                \"جهت سفارش محصول موردنطر خودرا انتخاب کنین:\")\n\n        keyboard = self.keyboards.get_categories_keyboard()\n        await query.edit_message_text(text, reply_markup=keyboard)\n\n    async def _handle_view_cart(self, query):\n        \"\"\"Handle view cart\"\"\"\n        user_id = query.from_user.id\n\n        if not self._is_authenticated(user_id):\n            await query.edit_message_text(\"ابتدا باید احراز هویت کنید.\")\n            return\n\n        cart_items = self.cart_manager.get_cart(user_id)\n\n        if not cart_items:\n            text = \"🛍️ سبد خرید شما خالی است.\"\n            keyboard = self.keyboards.get_main_menu(authenticated=True)\n        else:\n            text = \"🛍️ سبد خرید شما:\\n\\n\"\n            total = 0\n\n            for i, item in enumerate(cart_items, 1):\n                item_total = item['price'] * item['quantity']\n                total += item_total\n                text += (\n                    f\"{persian_numbers(str(i))}. {item['product_name']}\\n\"\n                    f\"   📏 سایز: {item['size']}\\n\"\n                    f\"   📦 تعداد: {persian_numbers(str(item['quantity']))}\\n\"\n                    f\"   💰 قیمت: {format_price(item_total)} تومان\\n\\n\")\n\n            text += f\"💰 مجموع: {format_price(total)} تومان\"\n            keyboard = self.keyboards.get_cart_management_keyboard()\n\n        await query.edit_message_text(text, reply_markup=keyboard)\n\n    async def _handle_view_invoice(self, query):\n        \"\"\"Handle view invoice\"\"\"\n        user_id = query.from_user.id\n\n        if not self._is_authenticated(user_id):\n            await query.edit_message_text(\"ابتدا باید احراز هویت کنید.\")\n            return\n\n        cart_items = self.cart_manager.get_cart(user_id)\n        customer = self.user_sessions[user_id]['customer']\n\n        invoice_text = self.pricing_manager.generate_invoice(\n            cart_items, customer)\n        keyboard = self.keyboards.get_payment_keyboard()\n\n        await query.edit_message_text(invoice_text, reply_markup=keyboard)\n\n    async def _handle_category_selection(self, query, data):\n        \"\"\"Handle category selection\"\"\"\n        category = data.replace(\"category_\", \"\")\n        user_id = query.from_user.id\n\n        # Store selected category in session\n        if user_id not in self.user_sessions:\n            self.user_sessions[user_id] = {}\n        self.user_sessions[user_id]['selected_category'] = category\n\n        category_info = get_category_info(category)\n        category_name = category_info.get('name', category)\n\n        if category == \"curtain_only\":\n            # For curtain_only, show products directly with icon-based keyboard\n            text = f\"{category_name}\\n\\nعالیه! حالا بگو کدوم طرح؟\"\n            keyboard = self.keyboards.get_category_products_keyboard(category)\n        elif category == \"tablecloth\":\n            # For tablecloth, show subcategories first\n            keyboard = self.keyboards.get_tablecloth_subcategories()\n            await query.edit_message_text(\"انتخاب فرشینه:\",\n                                          reply_markup=keyboard)\n            return\n        else:\n            # For other categories, show products directly with icon-based keyboard\n            text = f\"{category_name}\\n\\nعالیه! حالا بگو کدوم طرح؟\"\n            keyboard = self.keyboards.get_category_products_keyboard(category)\n\n        await query.edit_message_text(text, reply_markup=keyboard)\n\n    async def _handle_subcategory_selection(self, query, data):\n        \"\"\"Handle subcategory selection\"\"\"\n        subcategory = data.replace(\"subcategory_\", \"\")\n        user_id = query.from_user.id\n\n        # Store selected subcategory in session\n        if user_id not in self.user_sessions:\n            self.user_sessions[user_id] = {}\n        self.user_sessions[user_id]['selected_subcategory'] = subcategory\n\n        text = f\"🔤 جستجوی حروف الفبایی\\n\\nحرف اول نام محصول مورد نظر را انتخاب کنید:\"\n        keyboard = self.keyboards.get_alphabetical_keyboard(subcategory)\n        await query.edit_message_text(text, reply_markup=keyboard)\n\n    async def _handle_alphabet_selection(self, query, data):\n        \"\"\"Handle alphabet selection\"\"\"\n        parts = data.split(\"_\")\n        if len(parts) < 3:\n            await query.edit_message_text(\"❌ داده نامعتبر.\")\n            return\n        category = parts[1]\n        letter = parts[2]\n        user_id = query.from_user.id\n\n        # Get products starting with selected letter\n        subcategory = self.user_sessions[user_id].get('selected_subcategory')\n        actual_category = subcategory if subcategory else category\n\n        products = search_products_by_name(category, letter, subcategory)\n\n        if not products:\n            text = f\"❌ محصولی با حرف «{letter}» یافت نشد.\\n\\nحرف دیگری را انتخاب کنید:\"\n            keyboard = self.keyboards.get_alphabetical_keyboard(\n                actual_category)\n        else:\n            text = f\"📦 محصولات با حرف «{letter}»:\\n\\nیکی را انتخاب کنید:\"\n            keyboard = self.keyboards.get_products_keyboard(products, category)\n\n            # Store filtered products in session\n            self.user_sessions[user_id]['filtered_products'] = products\n\n        await query.edit_message_text(text, reply_markup=keyboard)\n\n    async def _handle_product_selection(self, query, data):\n        \"\"\"Handle product selection\"\"\"\n        product_id = data.replace(\"product_\", \"\")\n        user_id = query.from_user.id\n\n        # Find product by ID\n        product = get_product_by_id(product_id)\n\n        if not product:\n            await query.edit_message_text(\"❌ محصول یافت نشد.\")\n            return\n\n        # Store selected product in session\n        self.user_sessions[user_id]['selected_product'] = product\n\n        # Get price based on product (check for special pricing first)\n        category = product.get('category_id', 'baby')\n\n        # For curtains, show fabric selection first\n        if category == 'curtain_only':\n            # Check if it's the special bedside curtain\n            if product_id == 'curtain_15':  # پرده حریر سرتخت (جفت)\n                price = get_product_price(product['id'], category)\n                text = (f\"📦 {product['name']}\\n\"\n                        f\"💰 قیمت: {format_price(price)} تومان\\n\\n\"\n                        \"عالیه! انتخابت\\n\"\n                        \"ارتفاع: 240 و عرض 2×290 هست که قابل تغییر نیست\")\n                self.user_sessions[user_id]['selected_fabric'] = 'special'\n                self.user_sessions[user_id]['selected_category'] = category\n                self.user_sessions[user_id]['selected_size'] = 'ارتفاع: 240 - عرض: 2×290'\n\n                keyboard = [[InlineKeyboardButton(\"بله همین محصول رو میخوام\", callback_data=\"qty_1\")]]\n                keyboard.append([InlineKeyboardButton(\"🔙 بازگشت\", callback_data=\"back_to_categories\")])\n                keyboard = InlineKeyboardMarkup(keyboard)\n            else:\n                text = (f\"📦 {product['name']}\\n\\n\"\n                        \"عالیه! مدل پرده‌ای که انتخاب کردی. حالا جنس پارچش چی باشه؟\")\n                keyboard = self.keyboards.get_fabric_selection_keyboard()\n        # For tablecloth, show base price initially\n        elif category == 'tablecloth':\n            price = PRODUCT_PRICES[category]  # Show base price\n            text = (f\"📦 {product['name']}\\n\"\n                    f\"💰 قیمت: از {format_price(price)} تومان\\n\\n\"\n                    \"سایز مورد نظر را انتخاب کنید:\")\n            # Store category for size selection\n            self.user_sessions[user_id]['selected_category'] = category\n            keyboard = self.keyboards.get_size_selection_keyboard(category)\n        # For cushions, skip size selection and go directly to quantity\n        elif category == 'cushion':\n            price = get_product_price(product['id'], category)\n            # Store default size for cushions\n            self.user_sessions[user_id]['selected_size'] = 'استاندارد'\n            self.user_sessions[user_id]['selected_category'] = category\n\n            text = (f\"📦 {product['name']}\\n\"\n                    f\"💰 قیمت: {format_price(price)} تومان\\n\\n\"\n                    \"تعداد مورد نظر را انتخاب کنید:\")\n            keyboard = self.keyboards.get_quantity_keyboard()\n        else:\n            price = get_product_price(product['id'], category)\n            text = (f\"📦 {product['name']}\\n\"\n                    f\"💰 قیمت: {format_price(price)} تومان\\n\\n\"\n                    \"سایز مورد نظر را انتخاب کنید:\")\n            keyboard = self.keyboards.get_size_selection_keyboard(category)\n\n        await query.edit_message_text(text, reply_markup=keyboard)\n\n    async def _handle_size_selection_from_category(self, query, data):\n        \"\"\"Handle size selection directly from category\"\"\"\n        category = data.replace(\"size_selection_\", \"\")\n        user_id = query.from_user.id\n\n        # Store selected category in session\n        if user_id not in self.user_sessions:\n            self.user_sessions[user_id] = {}\n        self.user_sessions[user_id]['selected_category'] = category\n\n        category_info = get_category_info(category)\n        category_name = category_info.get('name', category)\n        price = category_info.get('price', 4780000)\n\n        if category == 'tablecloth':\n            text = (f\"{category_name}\\n\\n\"\n                    f\"💰 قیمت: از {format_price(price)} تومان\\n\\n\"\n                    \"چه انتخاب خوبی! حالا سایز تشک چقدر باشه؟\")\n        else:\n            text = (f\"{category_name}\\n\\n\"\n                    f\"💰 قیمت: {format_price(price)} تومان\\n\\n\"\n                    \"چه انتخاب خوبی! حالا سایز تشک چقدر باشه؟\")\n\n        # Use the keyboard's size selection method instead of hardcoded sizes\n        keyboard = self.keyboards.get_size_selection_keyboard(category)\n        await query.edit_message_text(text, reply_markup=keyboard)\n\n    async def _handle_size_selection(self, query, data):\n        \"\"\"Handle size selection\"\"\"\n        parts = data.split(\"_\")\n        if len(parts) >= 3:\n            size = \"_\".join(parts[1:-1])  # All parts except first and last\n            category = parts[-1]  # Last part is category\n        else:\n            size = data.replace(\"size_\", \"\")\n            category = self.user_sessions.get(query.from_user.id,\n                                              {}).get('selected_category',\n                                                      'baby')\n\n        user_id = query.from_user.id\n\n        # Store selected size and category in session\n        self.user_sessions[user_id]['selected_size'] = size\n        self.user_sessions[user_id]['selected_category'] = category\n\n        # Get category info for price\n        category_info = get_category_info(category)\n\n        # For tablecloth, get size-based price\n        if category == 'tablecloth':\n            price = get_product_price('', category, size)\n        else:\n            price = category_info.get('price', 4780000)\n\n        text = (f\"📏 سایز انتخابی: {size}\\n\"\n                f\"💰 قیمت: {format_price(price)} تومان\\n\\n\"\n                \"طرح قشنگی انتخاب کردی! حالا تعداد چقدر باشه؟\")\n        keyboard = self.keyboards.get_quantity_keyboard()\n\n        await query.edit_message_text(text, reply_markup=keyboard)\n\n    async def _handle_quantity_selection(self, query, data):\n        \"\"\"Handle quantity selection\"\"\"\n        quantity = int(data.replace(\"qty_\", \"\"))\n        user_id = query.from_user.id\n\n        # Get session data\n        session = self.user_sessions[user_id]\n        size = session.get('selected_size')\n        category = session.get('selected_category', 'baby')\n        fabric = session.get('selected_fabric')\n\n        # Check if we have a specific product or just category\n        if 'selected_product' in session:\n            # Product-based ordering\n            product = session['selected_product']\n            category = product.get('category_id', category)\n            product_name = product['name']\n            product_id = product['id']\n        else:\n            # Category-based ordering (for teen and adult)\n            category_info = get_category_info(category)\n            product_name = category_info.get('name', category)\n            product_id = f\"{category}_generic\"\n\n        # Get price based on product and fabric\n        if category == 'tablecloth':\n            price = get_product_price(product_id, category, size)\n        elif category == 'curtain_only' and fabric:\n            if fabric == 'special':  # For bedside curtain\n                price = get_product_price(product['id'], category)\n            else:\n                price = get_product_price(product_id, category, fabric=fabric)\n        else:\n            price = get_product_price(product['id'], category)\n\n        # Add fabric info to product name if applicable\n        if fabric and fabric != 'special':\n            fabric_name = \"حریر کتان\" if fabric == \"silk_cotton\" else \"مخمل\"\n            product_name = f\"{product_name} - {fabric_name}\"\n\n        # Add to cart\n        cart_item = {\n            'product_id': product_id,\n            'product_name': product_name,\n            'size': size,\n            'quantity': quantity,\n            'price': price\n        }\n\n        self.cart_manager.add_to_cart(user_id, cart_item)\n\n        total_price = price * quantity\n        text = (f\"✅ محصول به سبد خرید اضافه شد!\\n\\n\"\n                f\"📦 {product_name}\\n\"\n                f\"📏 سایز: {size}\\n\"\n                f\"📦 تعداد: {persian_numbers(str(quantity))}\\n\"\n                f\"💰 قیمت کل: {format_price(total_price)} تومان\\n\\n\"\n                \"می‌خواهید چه کار کنید؟\")\n\n        keyboard = self.keyboards.get_cart_management_keyboard()\n        await query.edit_message_text(text, reply_markup=keyboard)\n\n    async def _handle_payment_selection(self, query, data):\n        \"\"\"Handle payment selection\"\"\"\n        user_id = query.from_user.id\n\n        # Check authentication\n        if not self._is_authenticated(user_id):\n            await query.edit_message_text(\n                \"❌ ابتدا باید احراز هویت کنید.\",\n                reply_markup=self.keyboards.get_main_menu(authenticated=False))\n            return\n\n        cart_items = self.cart_manager.get_cart(user_id)\n        if not cart_items:\n            await query.edit_message_text(\n                \"❌ سبد خرید شما خالی است.\",\n                reply_markup=self.keyboards.get_main_menu(authenticated=True))\n            return\n\n        customer = self.user_sessions[user_id]['customer']\n\n        if data == \"payment_cash_card\":\n            await self._handle_card_to_card_payment(query, \"cash\", \"پرداخت نقدی\", 0.30)\n        elif data == \"payment_60day_card\":\n            await self._handle_card_to_card_payment(query, \"60day\", \"پرداخت ۶۰ روز\", 0.25)\n        elif data == \"payment_90day_card\":\n            await self._handle_card_to_card_payment(query, \"90day\", \"پرداخت ۹۰ روز\", 0.25)\n\n    async def _handle_zarinpal_payment(self, query, payment_type: str,\n                                       payment_method: str):\n        \"\"\"Handle ZarinPal payment\"\"\"\n        user_id = query.from_user.id\n        cart_items = self.cart_manager.get_cart(user_id)\n        customer = self.user_sessions[user_id]['customer']\n\n        if not cart_items:\n            await query.edit_message_text(\n                \"❌ سبد خرید شما خالی است.\",\n                reply_markup=self.keyboards.get_main_menu(authenticated=True))\n            return\n\n        # Calculate payment amount based on type\n        subtotal = self.pricing_manager.calculate_subtotal(cart_items)\n        discount_rate = self.pricing_manager.discount_rates.get(\n            payment_type, 0)\n        discount = self.pricing_manager.calculate_discount(\n            subtotal, discount_rate)\n\n        if payment_type == \"90day\":\n            # For 90-day payment, only 25% advance payment required\n            amount = int((subtotal - discount) * 0.25)  # 25% advance\n            description = f\"پیش‌پرداخت ۲۵٪ سفارش - {customer['name']}\"\n        else:\n            # For cash payment, full amount\n            amount = int(subtotal - discount)\n            description = f\"پرداخت نقدی سفارش - {customer['name']}\"\n\n        # Create payment request with proper callback URL\n        callback_url = \"https://www.zarinpal.com/pg/services/WebGate/wsdl\"  # Temporary callback\n\n        payment_result = self.zarinpal.create_payment_request(\n            amount=amount,\n            description=description,\n            callback_url=callback_url,\n            customer_mobile=customer.get('phone', ''),\n            customer_email=customer.get('email', ''))\n\n        if payment_result['success']:\n            # Store payment info in session\n            self.user_sessions[user_id]['payment_info'] = {\n                'authority': payment_result['authority'],\n                'amount': amount,\n                'payment_type': payment_type,\n                'payment_method': payment_method\n            }\n\n            text = (f\"💳 {payment_method}\\n\\n\"\n                    f\"💰 مبلغ قابل پرداخت: {format_price(amount)} تومان\\n\\n\"\n                    \"🔗 برای پرداخت روی دکمه زیر کلیک کنید:\")\n\n            keyboard = [[\n                InlineKeyboardButton(\"💳 پرداخت آنلاین\",\n                                     url=payment_result['payment_url'])\n            ],\n                        [\n                            InlineKeyboardButton(\n                                \"✅ پرداخت انجام شد\",\n                                callback_data=\"payment_completed\")\n                        ],\n                        [\n                            InlineKeyboardButton(\"🔙 بازگشت\",\n                                                 callback_data=\"view_invoice\")\n                        ],\n                        [\n                            InlineKeyboardButton(\"🏠 منوی اصلی\",\n                                                 callback_data=\"main_menu\")\n                        ]]\n\n            await query.edit_message_text(\n                text, reply_markup=InlineKeyboardMarkup(keyboard))\n        else:\n            text = (f\"❌ خطا در ایجاد درخواست پرداخت:\\n\"\n                    f\"{payment_result['error']}\\n\\n\"\n                    \"لطفاً دوباره تلاش کنید یا با پشتیبانی تماس بگیرید.\")\n\n            keyboard = [[\n                InlineKeyboardButton(\n                    \"🔄 تلاش مجدد\",\n                    callback_data=f\"payment_{payment_type}_zarinpal\")\n            ], [\n                InlineKeyboardButton(\"🏠 منوی اصلی\", callback_data=\"main_menu\")\n            ]]\n\n            await query.edit_message_text(\n                text, reply_markup=InlineKeyboardMarkup(keyboard))\n\n    async def _handle_card_to_card_payment(self, query, payment_type: str, payment_method: str, discount_rate: float):\n        \"\"\"Handle card-to-card payment\"\"\"\n        user_id = query.from_user.id\n        cart_items = self.cart_manager.get_cart(user_id)\n        customer = self.user_sessions[user_id]['customer']\n\n        if not cart_items:\n            await query.edit_message_text(\n                \"❌ سبد خرید شما خالی است.\",\n                reply_markup=self.keyboards.get_main_menu(authenticated=True))\n            return\n\n        # Calculate payment amount\n        subtotal = self.pricing_manager.calculate_subtotal(cart_items)\n        discount = self.pricing_manager.calculate_discount(subtotal, discount_rate)\n        final_amount = subtotal - discount\n\n        # Store payment info in session\n        self.user_sessions[user_id]['payment_info'] = {\n            'payment_type': payment_type,\n            'payment_method': payment_method,\n            'amount': final_amount if payment_type not in [\"90day\", \"60day\"] else int(final_amount * 0.25),\n            'discount_rate': discount_rate,\n            'awaiting_receipt': payment_type != \"60day\",  # 60-day doesn't need receipt\n            'full_amount': final_amount,\n            'subtotal': subtotal,\n            'discount': discount\n        }\n\n        # Generate payment details based on payment type\n        if payment_type == \"cash\":\n            payment_details = (\n                f\"💳 پرداخت نقدی (30% تخفیف)\\n\"\n                f\"از اعتماد شما ممنونیم\\n\\n\"\n                f\"💰 مبلغ کل: {format_price(subtotal)} تومان\\n\"\n                f\"🎁 تخفیف (30%): {format_price(discount)} تومان\\n\"\n                f\"💰 مبلغ نهایی پس از تخفیف: {format_price(final_amount)} تومان\\n\\n\"\n                f\"🏦 اطلاعات حساب:\\n\"\n                f\"💳 شماره کارت: 6219861915854102\\n\"\n                f\"🏦 شماره شبا: IR110560611828005185959401\\n\"\n                f\"👤 به نام:نیما کریمی\\n\\n\"\n                f\"📸 پس از واریز، لطفاً عکس فیش واریزی را ارسال کنید:\"\n            )\n            # Create keyboard for cash payment\n            keyboard = [[\n                InlineKeyboardButton(\"📸 ارسال فیش واریزی\", callback_data=\"upload_receipt\")\n            ], [\n                InlineKeyboardButton(\"🔙 بازگشت\", callback_data=\"view_invoice\")\n            ]]\n\n        elif payment_type == \"60day\":\n            payment_details = (\n                f\"💳 پرداخت 60 روزه (25% تخفیف)\\n\"\n                f\"از اعتماد شما ممنونیم\\n\\n\"\n                f\"💰 مبلغ کل: {format_price(subtotal)} تومان\\n\"\n                f\"🎁 تخفیف (25%): {format_price(discount)} تومان\\n\"\n                f\"💰 مبلغ نهایی: {format_price(final_amount)} تومان\\n\\n\"\n                f\"📅 مشتری در طول 60 روز آینده مبلغ را خورد خورد پرداخت خواهد کرد\\n\"\n                f\"⏰ یادآوری ماهانه برای پیگیری پرداخت فعال خواهد شد\\n\\n\"\n                f\"✅ برای تایید سفارش و فعال‌سازی یادآوری ماهانه دکمه زیر را بزنید:\"\n            )\n            # Create keyboard for 60-day payment\n            keyboard = [[\n                InlineKeyboardButton(\"✅ سفارشم را تایید می‌کنم و یادآوری ماهانه را تایید\",\n                                   callback_data=\"confirm_60day_order\")\n            ], [\n                InlineKeyboardButton(\"🔙 بازگشت\", callback_data=\"view_invoice\")\n            ]]\n\n        elif payment_type == \"90day\":\n            advance_payment = int(final_amount * 0.25)\n            payment_details = (\n                f\"💳 پرداخت 90 روزه (25% تخفیف + 25% پیش‌پرداخت)\\n\"\n                f\"از اعتماد شما ممنونیم\\n\\n\"\n                f\"💰 مبلغ کل: {format_price(subtotal)} تومان\\n\"\n                f\"🎁 مبلغ تخفیف (25%): {format_price(discount)} تومان\\n\"\n                f\"💰 مبلغ نهایی: {format_price(final_amount)} تومان\\n\"\n                f\"💳 پیش‌پرداخت (25%): {format_price(advance_payment)} تومان\\n\\n\"\n                f\"🏦 اطلاعات حساب:\\n\"\n                f\"💳 شماره کارت: 6219861915854102\\n\"\n                f\"🏦 شماره شبا: IR110560611828005185959401\\n\"\n                f\"👤 به نام: نیما کریمی\\n\\n\"\n                f\"📸 پس از واریز پیش‌پرداخت، لطفاً عکس فیش واریزی را ارسال کنید:\"\n            )\n            # Create keyboard for 90-day payment\n            keyboard = [[\n                InlineKeyboardButton(\"📸 ارسال فیش واریزی\", callback_data=\"upload_receipt\")\n            ], [\n                InlineKeyboardButton(\"🔙 بازگشت\", callback_data=\"view_invoice\")\n            ]]\n\n        await query.edit_message_text(\n            payment_details,\n            reply_markup=InlineKeyboardMarkup(keyboard)\n        )\n\n    async def _handle_payment_terms_confirmation(self, query):\n        \"\"\"Handle payment terms confirmation for 60-day and 90-day payments\"\"\"\n        user_id = query.from_user.id\n\n        if not self._is_authenticated(user_id):\n            await query.edit_message_text(\"❌ ابتدا باید احراز هویت کنید.\")\n            return\n\n        payment_info = self.user_sessions[user_id].get('payment_info')\n        if not payment_info:\n            await query.edit_message_text(\n                \"❌ اطلاعات پرداخت یافت نشد.\",\n                reply_markup=self.keyboards.get_main_menu(authenticated=True))\n            return\n\n        customer = self.user_sessions[user_id]['customer']\n        cart_items = self.cart_manager.get_cart(user_id)\n\n        # Send invoice to support group\n        invoice_text = self.pricing_manager.generate_final_invoice(\n            cart_items, customer, payment_info['payment_method'], payment_info['discount_rate'])\n\n        # ارسال به گروه پشتیبانی\n        if self.config.order_group_chat_id:\n            try:\n                group_message = (\n                    f\"📋 تایید پرداخت اقساطی\\n\"\n                    f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n                    f\"👤 نام مشتری: {customer['name']}\\n\"\n                    f\"🏙️ شهر: {customer['city']}\\n\"\n                    f\"🆔 کد نمایندگی: {customer['customer_id']}\\n\"\n                    f\"📱 شناسه کاربر: {user_id}\\n\"\n                    f\"💳 روش پرداخت: {payment_info['payment_method']}\\n\"\n                    f\"💰 پیش‌پرداخت: {format_price(payment_info['amount'])} تومان\\n\"\n                    f\"💰 مبلغ باقی‌مانده: {format_price(payment_info['full_amount'] - payment_info['amount'])} تومان\\n\"\n                    f\"⏰ زمان تایید: {persian_numbers(datetime.now().strftime('%Y/%m/%d - %H:%M'))}\\n\\n\"\n                    f\"📋 جزئیات سفارش:\\n\"\n                    f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n                    f\"{invoice_text}\"\n                )\n\n                await query.bot.send_message(\n                    chat_id=self.config.order_group_chat_id,\n                    text=group_message\n                )\n                logger.info(f\"✅ اطلاعات پرداخت اقساطی ارسال شد به گروه\")\n\n            except Exception as e:\n                logger.error(f\"❌ خطا در ارسال اطلاعات به گروه: {e}\")\n\n        # Schedule payment reminder for both 60-day and 90-day payments\n        if payment_info['payment_type'] in ['60day', '90day']:\n            total_amount = payment_info['full_amount']\n            advance_paid = payment_info['amount']\n            remaining_amount = total_amount - advance_paid\n\n            # Create order ID for tracking\n            order_id = f\"ORDER_{user_id}_{int(datetime.now().timestamp())}\"\n\n            if payment_info['payment_type'] == '60day':\n                # For 60-day payment: single reminder after 60 days\n                self.payment_scheduler.add_60day_payment_schedule(\n                    user_id=user_id,\n                    customer_info=customer,\n                    total_amount=total_amount,\n                    advance_paid=advance_paid,\n                    remaining_amount=remaining_amount,\n                    order_id=order_id\n                )\n                logger.info(f\"✅ برنامه پرداخت 60 روزه برای کاربر {user_id} تنظیم شد\")\n            else:\n                # For 90-day payment: monthly reminders\n                self.payment_scheduler.add_90day_payment_schedule(\n                    user_id=user_id,\n                    customer_info=customer,\n                    total_amount=total_amount,\n                    advance_paid=advance_paid,\n                    remaining_amount=remaining_amount,\n                    order_id=order_id\n                )\n                logger.info(f\"✅ برنامه پرداخت 90 روزه برای کاربر {user_id} تنظیم شد\")\n\n        # Show upload receipt interface\n        await query.edit_message_text(\n            f\"✅ شرایط پرداخت تایید شد!\\n\\n\"\n            f\"💰 مبلغ پیش‌پرداخت: {format_price(payment_info['amount'])} تومان\\n\"\n            f\"📅 یادآوری ماهانه برای مابقی پرداخت تنظیم شد\\n\\n\"\n            f\"📸 لطفاً عکس فیش واریز پیش‌پرداخت را ارسال کنید:\",\n            reply_markup=InlineKeyboardMarkup([[\n                InlineKeyboardButton(\"📸 ارسال فیش واریزی\", callback_data=\"upload_receipt\")\n            ], [\n                InlineKeyboardButton(\"🔙 بازگشت\", callback_data=\"view_invoice\")\n            ]]))\n\n\n        if payment_type in [\"60day\", \"90day\"]:\n            keyboard = [[\n                InlineKeyboardButton(button_text, callback_data=\"confirm_payment_terms\")\n            ], [\n                InlineKeyboardButton(\"🔙 بازگشت\", callback_data=\"view_invoice\")\n            ]]\n        else:\n            keyboard = [[\n                InlineKeyboardButton(\"📸 ارسال فیش واریزی\", callback_data=\"upload_receipt\")\n            ], [\n                InlineKeyboardButton(\"🔙 بازگشت\", callback_data=\"view_invoice\")\n            ]]\n\n        await query.edit_message_text(\n            bank_info,\n            reply_markup=InlineKeyboardMarkup(keyboard)\n        )\n\n    async def _handle_upload_receipt_request(self, query):\n        \"\"\"Handle receipt upload request\"\"\"\n        await query.edit_message_text(\n            \"📸 لطفاً عکس فیش واریزی خود را در این چت ارسال کنید.\\n\\n\"\n            \"⚠️ فقط تصاویر با فرمت JPG, PNG قابل قبول هستند.\\n\\n\"\n            \"پس از ارسال عکس، دکمه تایید نمایش داده خواهد شد.\",\n            reply_markup=InlineKeyboardMarkup([[\n                InlineKeyboardButton(\"🔙 بازگشت\", callback_data=\"view_invoice\")\n            ]]))\n\n    async def _handle_payment_receipt_confirmation(self, query):\n        \"\"\"Handle payment receipt confirmation\"\"\"\n        user_id = query.from_user.id\n\n        if not self._is_authenticated(user_id):\n            await query.edit_message_text(\"❌ ابتدا باید احراز هویت کنید.\")\n            return\n\n        # Check if user is authenticated\n        if not self._is_authenticated(user_id):\n            await query.edit_message_text(\n                \"❌ ابتدا باید احراز هویت کنید.\",\n                reply_markup=self.keyboards.get_main_menu(authenticated=False))\n            return\n\n        customer = self.user_sessions[user_id]['customer']\n        cart_items = self.cart_manager.get_cart(user_id)\n        payment_info = self.user_sessions[user_id].get('payment_info')\n\n        if not payment_info:\n            await query.edit_message_text(\n                \"❌ اطلاعات پرداخت یافت نشد.\",\n                reply_markup=self.keyboards.get_main_menu(authenticated=True))\n            return\n\n        if not cart_items:\n            await query.edit_message_text(\n                \"❌ سبد خرید شما خالی است.\",\n                reply_markup=self.keyboards.get_main_menu(authenticated=True))\n            return\n\n        try:\n            # Get receipt photo if available\n            receipt_photo_id = None\n            if 'receipt_photo' in self.user_sessions[user_id]:\n                receipt_photo_id = self.user_sessions[user_id]['receipt_photo']['file_id']\n\n            # Create order using order management server\n            order_id = await self.order_server.create_order(\n                user_id=user_id,\n                customer=customer,\n                cart_items=cart_items,\n                payment_method=payment_info['payment_method'],\n                discount_rate=payment_info['discount_rate'],\n                receipt_photo_id=receipt_photo_id\n            )\n\n            # Clear cart and payment info\n            self.cart_manager.clear_cart(user_id)\n            if 'payment_info' in self.user_sessions[user_id]:\n                del self.user_sessions[user_id]['payment_info']\n            if 'receipt_photo' in self.user_sessions[user_id]:\n                del self.user_sessions[user_id]['receipt_photo']\n\n            # Confirm to customer\n            await query.edit_message_text(\n                f\"✅ عالیه! سفارش شما با موفقیت ثبت شد!\\n\"\n                f\"📋 شماره سفارش: {order_id}\\n\"\n                f\"🔄 بعد از تایید تیم پشتیبانی دکوتین شما را در جریان سفارش قرار خواهیم داد.\\n\"\n                f\"🙏 از اعتماد شما ممنونیم.\",\n                reply_markup=self.keyboards.get_main_menu(authenticated=True))\n\n            logger.info(f\"✅ سفارش {order_id} با موفقیت ثبت شد برای کاربر {user_id}\")\n\n        except Exception as e:\n            logger.error(f\"Error in payment receipt confirmation: {e}\")\n            logger.error(f\"User ID: {user_id}, Customer: {customer if customer else 'None'}, Cart items: {len(cart_items) if cart_items else 0}\")\n\n            # More detailed error handling\n            try:\n                await query.edit_message_text(\n                    f\"❌ خطایی در ثبت سفارش رخ داد.\\n\"\n                    f\"لطفاً دوباره تلاش کنید یا با پشتیبانی تماس بگیرید.\\n\\n\"\n                    f\"کد خطا: {type(e).__name__}\",\n                    reply_markup=self.keyboards.get_main_menu(authenticated=True))\n            except Exception as edit_error:\n                logger.error(f\"Error editing message: {edit_error}\")\n                # Send new message if editing fails\n                try:\n                    await query.message.reply_text(\n                        f\"❌ خطایی در ثبت سفارش رخ داد.\\n\"\n                        f\"لطفاً دوباره تلاش کنید یا با پشتیبانی تماس بگیرید.\",\n                        reply_markup=self.keyboards.get_main_menu(authenticated=True))\n                except Exception as reply_error:\n                    logger.error(f\"Error sending reply: {reply_error}\")\n\n    async def _handle_group_payment(self, query, payment_type: str,\n                                    payment_method: str):\n        \"\"\"Handle group payment (installment)\"\"\"\n        user_id = query.from_user.id\n        cart_items = self.cart_manager.get_cart(user_id)\n        customer = self.user_sessions[user_id]['customer']\n\n        # Check if cart is not empty\n        if not cart_items:\n            await query.edit_message_text(\n                \"❌ سبد خرید شما خالی است.\",\n                reply_markup=self.keyboards.get_main_menu(authenticated=True))\n            return\n\n        # Check if group chat ID is configured\n        if not self.config.order_group_chat_id:\n            await query.edit_message_text(\n                \"❌ گروه پیگیری سفارش تنظیم نشده است. لطفاً با پشتیبانی تماس بگیرید.\",\n                reply_markup=self.keyboards.get_main_menu(authenticated=True))\n            return\n\n        try:\n            # Generate final invoice\n            discount_rate = self.pricing_manager.discount_rates.get(\n                payment_type, 0.25)\n            invoice_text = self.pricing_manager.generate_final_invoice(\n                cart_items, customer, payment_method, discount_rate)\n\n            # Send to customer with confirmation\n            confirmation_text = (\n                f\"{invoice_text}\\n\\n\"\n                \"✅ سفارش شما ثبت شد و به گروه پیگیری ارسال می‌شود.\\n\"\n                \"📞 کارشناسان ما به زودی با شما تماس خواهند گرفت.\")\n\n            keyboard = [[\n                InlineKeyboardButton(\"✅ تایید سفارش\",\n                                     callback_data=\"confirm_order\")\n            ], [\n                InlineKeyboardButton(\"🏠 منوی اصلی\", callback_data=\"main_menu\")\n            ]]\n\n            # Store order info for confirmation```python\n            self.user_sessions[user_id]['pending_order'] = {\n                'payment_method': payment_method,\n                'discount_rate': discount_rate,\n                'invoice_text': invoice_text\n            }\n\n            await query.edit_message_text(\n                confirmation_text, reply_markup=InlineKeyboardMarkup(keyboard))\n\n            logger.info(\n                \"Group payment processed successfully for user {user_id}\")\n\n        except Exception as e:\n            logger.error(f\"Error in group payment handling: {e}\")\n            await query.edit_message_text(\n                \"❌ خطایی در پردازش سفارش رخ داد. لطفاً دوباره تلاش کنید.\",\n                reply_markup=self.keyboards.get_main_menu(authenticated=True))\n\n    async def _handle_order_confirmation(self, query):\n        \"\"\"Handle order confirmation using order management server\"\"\"\n        user_id = query.from_user.id\n\n        # Check if user is authenticated\n        if not self._is_authenticated(user_id):\n            await query.edit_message_text(\n                \"❌ ابتدا باید احراز هویت کنید.\",\n                reply_markup=self.keyboards.get_main_menu(authenticated=False))\n            return\n\n        customer = self.user_sessions[user_id]['customer']\n        cart_items = self.cart_manager.get_cart(user_id)\n        pending_order = self.user_sessions[user_id].get('pending_order')\n\n        if not pending_order:\n            await query.edit_message_text(\n                \"❌ اطلاعات سفارش یافت نشد.\",\n                reply_markup=self.keyboards.get_main_menu(authenticated=True))\n            return\n\n        if not cart_items:\n            await query.edit_message_text(\n                \"❌ سبد خرید شما خالی است.\",\n                reply_markup=self.keyboards.get_main_menu(authenticated=True))\n            return\n\n        try:\n            # استفاده از سرور مدیریت سفارشات\n            order_id = await self.order_server.create_order(\n                user_id=user_id,\n                customer=customer,\n                cart_items=cart_items,\n                payment_method=pending_order['payment_method'],\n                discount_rate=pending_order['discount_rate']\n            )\n\n            # Clear cart and session\n            self.cart_manager.clear_cart(user_id)\n            if 'pending_order' in self.user_sessions[user_id]:\n                del self.user_sessions[user_id]['pending_order']\n\n            # Store order ID in session\n            self.user_sessions[user_id]['last_order_id'] = order_id\n\n            # Confirm to customer\n            await query.edit_message_text(\n                f\"✅ عالیه! سفارش شما با موفقیت ثبت شد!\\n\"\n                f\"📋 شماره سفارش: {order_id}\\n\"\n                f\"🔄 بعد از تایید تیم پشتیبانی دکوتین شما را در جریان سفارش قرار خواهیم داد.\\n\"\n                f\"🙏 از اعتماد شما ممنونیم.\",\n                reply_markup=self.keyboards.get_main_menu(authenticated=True))\n\n        except Exception as e:\n            logger.error(f\"Error in order confirmation: {e}\")\n            await query.edit_message_text(\n                \"❌ خطایی در ثبت سفارش رخ داد. لطفاً دوباره تلاش کنید.\",\n                reply_markup=self.keyboards.get_main_menu(authenticated=True))\n\n    async def _handle_payment_completed(self, query):\n        \"\"\"Handle payment completed confirmation\"\"\"\n        user_id = query.from_user.id\n\n        if not self._is_authenticated(user_id):\n            await query.edit_message_text(\"❌ ابتدا باید احراز هویت کنید.\")\n            return\n\n        payment_info = self.user_sessions[user_id].get('payment_info')\n        if not payment_info:\n            await query.edit_message_text(\n                \"❌ اطلاعات پرداخت یافت نشد.\\n\"\n                \"لطفاً مجدداً تلاش کنید.\",\n                reply_markup=self.keyboards.get_main_menu(authenticated=True))\n            return\n\n        customer = self.user_sessions[user_id]['customer']\n        cart_items = self.cart_manager.get_cart(user_id)\n\n        # Generate final invoice\n        discount_rate = self.pricing_manager.discount_rates.get(\n            payment_info['payment_type'], 0)\n        invoice_text = self.pricing_manager.generate_final_invoice(\n            cart_items, customer, payment_info['payment_method'],\n            discount_rate)\n\n        # Send to group if configured\n        if self.config.order_group_chat_id:\n            group_message = (\n                f\"💳 پرداخت آنلاین تکمیل شده\\n\"\n                f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n                f\"👤 نام مشتری: {customer['name']}\\n\"\n                f\"🏙️ شهر: {customer['city']}\\n\"\n                f\"🆔 کد نمایندگی: {customer['customer_id']}\\n\"\n                f\"📱 یوزرنیم تلگرام: @{query.from_user.username or 'ندارد'}\\n\"\n                f\"🆔 شناسه کاربر: {user_id}\\n\"\n                f\"💳 روش پرداخت: {payment_info['payment_method']}\\n\"\n                f\"💰 مبلغ پرداختی: {format_price(payment_info['amount'])} تومان\\n\"\n                f\"⏰ زمان پرداخت: {persian_numbers(datetime.now().strftime('%Y/%m/%d - %H:%M'))}\\n\\n\"\n                f\"📋 جزئیات سفارش:\\n\"\n                f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n                f\"{invoice_text}\\n\\n\"\n                f\"✅ پرداخت تایید شده - نیاز به پیگیری ارسال\")\n\n            # Create admin action buttons for paid orders\n            keyboard = [[\n                InlineKeyboardButton(\n                    \"✅ تماس گرفته شد\",\n                    callback_data=f\"order_contacted_{user_id}\"),\n                InlineKeyboardButton(\"📦 آماده ارسال\",\n                                     callback_data=f\"order_ready_{user_id}\")\n            ],\n                        [\n                            InlineKeyboardButton(\n                                \"🚚 ارسال شد\",\n                                callback_data=f\"order_shipped_{user_id}\"),\n                            InlineKeyboardButton(\n                                \"✅ تکمیل شد\",\n                                callback_data=f\"order_completed_{user_id}\")\n                        ]]\n\n            try:\n                sent_message = await query.bot.send_message(\n                    chat_id=self.config.order_group_chat_id,\n                    text=group_message,\n                    reply_markup=InlineKeyboardMarkup(keyboard))\n                logger.info(\n                    f\"✅ Payment info sent to group {self.config.order_group_chat_id}\"\n                )\n                logger.info(f\"Message ID: {sent_message.message_id}\")\n\n                # Store order info for tracking\n                order_info = {\n                    'user_id': user_id,\n                    'customer': customer,\n                    'message_id': sent_message.message_id,\n                    'status': 'paid',\n                    'created_at': datetime.now().isoformat()\n                }\n                self.user_sessions[user_id]['order_info'] = order_info\n\n            except Exception as e:\n                logger.error(\n                    f\"❌ Error sending payment info to group {self.config.order_group_chat_id}: {e}\"\n                )\n                logger.error(f\"Error type: {type(e).__name__}\")\n                # Send error info to customer for debugging\n                await query.bot.send_message(\n                    chat_id=user_id,\n                    text=\n                    f\"⚠️ پرداخت ثبت شد اما ارسال به گروه با خطا مواجه شد:\\n{str(e)[:200]}\"\n                )\n        else:\n            logger.warning(\n                \"❌ Order group chat ID is not configured for payment notification\"\n            )\n\n        # Clear cart and payment info\n        self.cart_manager.clear_cart(user_id)\n        if 'payment_info' in self.user_sessions[user_id]:\n            del self.user_sessions[user_id]['payment_info']\n\n        text = (\n            f\"✅ سفارش شما ثبت شد!\\n\\n\"\n            f\"💳 روش پرداخت: {payment_info['payment_method']}\\n\"\n            f\"💰 مبلغ: {format_price(payment_info['amount'])} تومان\\n\\n\"\n            f\"📞 سفارش شما به گروه پیگیری ارسال شد و به زودی با شما تماس خواهیم گرفت.\\n\"\n            f\"🙏 از اعتماد شما متشکریم.\")\n\n        await query.edit_message_text(\n            text,\n            reply_markup=self.keyboards.get_main_menu(authenticated=True))\n\n    async def _handle_payment_verification(self, query):\n        \"\"\"Handle payment verification\"\"\"\n        user_id = query.from_user.id\n        payment_info = self.user_sessions[user_id].get('payment_info')\n\n        if not payment_info:\n            await query.edit_message_text(\n                \"❌ اطلاعات پرداخت یافت نشد.\",\n                reply_markup=self.keyboards.get_main_menu(authenticated=True))\n            return\n\n        # Verify payment with ZarinPal\n        verify_result = self.zarinpal.verify_payment(\n            authority=payment_info['authority'], amount=payment_info['amount'])\n\n        if verify_result['success']:\n            # Payment successful\n            customer = self.user_sessions[user_id]['customer']\n            cart_items = self.cart_manager.get_cart(user_id)\n\n            # Generate final invoice\n            discount_rate = self.pricing_manager.discount_rates[\n                payment_info['payment_type']]\n            invoice_text = self.pricing_manager.generate_final_invoice(\n                cart_items, customer, payment_info['payment_method'],\n                discount_rate)\n\n            # Send to group if configured\n            if self.config.order_group_chat_id:\n                group_message = (\n                    f\"💳 پرداخت موفق - {payment_info['payment_method']}\\n\"\n                    f\"━━━━━━━━━━━━━━━━\\n\"\n                    f\"👤 مشتری: {customer['name']}\\n\"\n                    f\"🏙️ شهر: {customer['city']}\\n\"\n                    f\"🆔کد نمایندگی : {customer['customer_id']}\\n\"\n                    f\"📱 آیدی تلگرام: @{query.from_user.username or 'ندارد'}\\n\"\n                    f\"💳 شماره پیگیری: {verify_result['ref_id']}\\n\\n\"\n                    f\"{invoice_text}\")\n\n                try:\n                    await query.bot.send_message(\n                        chat_id=self.config.order_group_chat_id,\n                        text=group_message)\n                except Exception as e:\n                    logger.error(\n                        f\"Error sending payment confirmation to group: {e}\")\n\n            # Clear cart and payment info\n            self.cart_manager.clear_cart(user_id)\n            if 'payment_info' in self.user_sessions[user_id]:\n                del self.user_sessions[user_id]['payment_info']\n\n            text = (f\"✅ پرداخت با موفقیت انجام شد!\\n\\n\"\n                    f\"💳 شماره پیگیری: {verify_result['ref_id']}\\n\\n\"\n                    f\"📞 سفارش شما ثبت شد و به زودی با شما تماس خواهیم گرفت.\\n\"\n                    f\"🙏 از اعتماد شما متشکریم.\")\n\n            await query.edit_message_text(\n                text,\n                reply_markup=self.keyboards.get_main_menu(authenticated=True))\n        else:\n            # Payment failed\n            text = (f\"❌ پرداخت ناموفق بود:\\n\"\n                    f\"{verify_result['error']}\\n\\n\"\n                    \"می‌توانید دوباره تلاش کنید.\")\n\n            keyboard = [[\n                InlineKeyboardButton(\n                    \"🔄 تلاش مجدد\",\n                    callback_data=\n                    f\"payment_{payment_info['payment_type']}_zarinpal\")\n            ], [\n                InlineKeyboardButton(\"🏠 منوی اصلی\", callback_data=\"main_menu\")\n            ]]\n\n            await query.edit_message_text(\n                text, reply_markup=InlineKeyboardMarkup(keyboard))\n\n    async def _handle_cart_clear(self, query):\n        \"\"\"Handle cart clear\"\"\"\n        user_id = query.from_user.id\n        self.cart_manager.clear_cart(user_id)\n\n        text = \"🗑️ سبد خرید پاک شد.\"\n        keyboard = self.keyboards.get_main_menu(authenticated=True)\n\n        await query.edit_message_text(text, reply_markup=keyboard)\n\n    async def _handle_back_to_categories(self, query):\n        \"\"\"Handle back to categories\"\"\"\n        await self._handle_start_shopping(query)\n\n    async def _handle_back_to_alphabet(self, query):\n        \"\"\"Handle back to alphabet\"\"\"\n        user_id = query.from_user.id\n        category = self.user_sessions[user_id].get('selected_category', 'baby')\n\n        text = f\"🔤 جستجوی حروف الفبایی\\n\\nحرف اول نام محصول مورد نظر را انتخاب کنید:\"\n        keyboard = self.keyboards.get_alphabetical_keyboard(category)\n\n        await query.edit_message_text(text, reply_markup=keyboard)\n\n    async def _handle_back_to_curtain_subcategories(self, query):\n        \"\"\"Handle back to curtain subcategories\"\"\"\n        text = \"🏠 پرده و کوسن\\n\\nمحصول مورد نظر خود را انتخاب کنید:\"\n        keyboard = self.keyboards.get_curtain_subcategories()\n        await query.edit_message_text(text, reply_markup=keyboard)\n\n    async def _handle_back_to_products(self, query):\n        \"\"\"Handle back to products\"\"\"\n        user_id = query.from_user.id\n        session = self.user_sessions[user_id]\n\n        if 'selected_product' in session:\n            product = session['selected_product']\n\n            # Get price based on category\n            category = product.get('category_id', 'baby')\n            category_info = get_category_info(category)\n            price = category_info.get('price', 4780000)\n\n            text = (f\"📦 {product['name']}\\n\\n\"\n                    f\"💰 قیمت: {format_price(price)} تومان\\n\\n\"\n                    \"📏 سایز مورد نظر را انتخاب کنید:\")\n\n            keyboard = self.keyboards.get_size_selection_keyboard(category)\n            await query.edit_message_text(text, reply_markup=keyboard)\n\n    async def _handle_alphabet_search(self, query, data):\n        \"\"\"Handle alphabet search button\"\"\"\n        category = data.replace(\"alphabet_search_\", \"\")\n        user_id = query.from_user.id\n\n        # Store selected category in session\n        if user_id not in self.user_sessions:\n            self.user_sessions[user_id] = {}\n        self.user_sessions[user_id]['selected_category'] = category\n\n        category_info = get_category_info(category)\n        category_name = category_info.get('name', category)\n\n        text = f\"{category_name}\\n\\n🔤 جستجوی حروف الفبایی\\n\\nحرف اول نام محصول مورد نظر را انتخاب کنید:\"\n\n        keyboard = self.keyboards.get_alphabetical_keyboard(category)\n        await query.edit_message_text(text, reply_markup=keyboard)\n\n    async def _handle_icon_selection(self, query, data):\n        \"\"\"Handle icon-based product selection\"\"\"\n        parts = data.split(\"_\", 2)\n        if len(parts) < 3:\n            await query.edit_message_text(\"❌ خطا در انتخاب آیکون.\")\n            return\n\n        category = parts[1]\n        icon = parts[2]\n\n        # Search products by icon\n        products = search_products_by_icon(category, icon)\n\n        if not products:\n            await query.edit_message_text(\"❌ محصولی با این آیکون یافت نشد.\")\n            return\n\n        if len(products) == 1:\n            # Only one product found, select it directly\n            product = products[0]\n            await self._handle_direct_product_selection(query, product, category)\n        else:\n            # Multiple products found, show selection keyboard\n            keyboard = self.keyboards.get_products_keyboard(products, category)\n            await query.edit_message_text(\n                f\"محصولات مرتبط:\",\n                reply_markup=keyboard\n            )\n\n    async def _handle_payment_confirmed(self, query, data):\n        \"\"\"Handle payment confirmation from the group\"\"\"\n        # Extract user_id from callback data\n        user_id = int(data.split(\"_\")[2])\n\n        # Get customer info\n        customer = self.user_sessions[user_id]['customer']\n\n        # Send confirmation to customer\n        text = (f\"✅ پرداخت شما تایید شد!\\n\\n\"\n                f\"🙏 از اعتماد شما متشکریم.\")\n\n        await query.bot.send_message(\n            chat_id=user_id,\n            text=text,\n            reply_markup=self.keyboards.get_main_menu(authenticated=True))\n\n        # Edit message in group to confirm\n        await query.edit_message_text(\n            f\"✅ پرداخت مشتری {customer['name']} تایید شد.\")\n\n    async def _handle_contact_made(self, query, data):\n        \"\"\"Handle contact confirmation from the group\"\"\"\n        # Extract user_id from callback data\n        user_id = int(data.split(\"_\")[2])\n\n        # Get customer info\n        customer = self.user_sessions[user_id]['customer']\n\n        # Edit message in group to confirm\n        await query.edit_message_text(\n            f\"📞 تماس با مشتری {customer['name']} برقرار شد.\")\n\n    async def _handle_remind_tomorrow(self, query, data):\n        \"\"\"Handle remind tomorrow request from the group\"\"\"\n        # Extract user_id from callback data\n        user_id = int(data.split(\"_\")[2])\n\n        # Get customer info\n        customer = self.user_sessions[user_id]['customer']\n\n        # Schedule reminder\n        # self.payment_scheduler.schedule_reminder(user_id)\n\n        # Edit message in group to confirm\n        await query.edit_message_text(\n            f\"⏰ یادآوری برای مشتری {customer['name']} برای فردا تنظیم شد.\")\n\n    async def _handle_order_contacted(self, query, data):\n        \"\"\"Handle order contacted confirmation\"\"\"\n        user_id = int(data.split(\"_\")[2])\n        admin_name = query.from_user.first_name or \"ادمین\"\n\n        # Update message\n        updated_text = f\"📞 {admin_name} با مشتری تماس گرفت\\n\" + query.message.text\n\n        # Create updated keyboard with remaining options\n        keyboard = [[\n            InlineKeyboardButton(\"📦 آماده ارسال\",\n                                 callback_data=f\"order_ready_{user_id}\"),\n            InlineKeyboardButton(\"🚚 ارسال شد\",\n                                 callback_data=f\"order_shipped_{user_id}\")\n        ],\n                    [\n                        InlineKeyboardButton(\n                            \"✅ تکمیل شد\",\n                            callback_data=f\"order_completed_{user_id}\"),\n                        InlineKeyboardButton(\n                            \"❌ لغو سفارش\",\n                            callback_data=f\"order_cancelled_{user_id}\")\n                    ]]\n\n        await query.edit_message_text(\n            updated_text, reply_markup=InlineKeyboardMarkup(keyboard))\n\n        # Notify customer - improved error handling\n        try:\n            await query.bot.send_message(\n                chat_id=user_id,\n                text=\n                \"📞 کارشناس ما با شما تماس گرفت. سفارش شما در حال پردازش است.\")\n            logger.info(f\"Successfully notified customer {user_id}\")\n        except Exception as e:\n            logger.error(f\"Error notifying customer {user_id}: {e}\")\n            # Continue processing even if customer notification fails\n\n    async def _handle_order_ready(self, query, data):\n        \"\"\"Handle order ready for shipping\"\"\"\n        user_id = int(data.split(\"_\")[2])\n        admin_name = query.from_user.first_name or \"ادمین\"\n\n        updated_text = f\"📦 {admin_name}: سفارش آماده ارسال شد\\n\" + query.message.text\n\n        keyboard = [[\n            InlineKeyboardButton(\"🚚 ارسال شد\",\n                                 callback_data=f\"order_shipped_{user_id}\"),\n            InlineKeyboardButton(\"✅ تکمیل شد\",\n                                 callback_data=f\"order_completed_{user_id}\")\n        ]]\n\n        await query.edit_message_text(\n            updated_text, reply_markup=InlineKeyboardMarkup(keyboard))\n\n        # Notify customer - improved error handling\n        try:\n            await query.bot.send_message(\n                chat_id=user_id,\n                text=\"📦 سفارش شما آماده و به زودی ارسال خواهد شد!\")\n            logger.info(f\"Successfully notified customer {user_id}\")\n        except Exception as e:\n            logger.error(f\"Error notifying customer {user_id}: {e}\")\n            # Continue processing even if customer notification fails\n\n    async def _handle_order_shipped(self, query, data):\n        \"\"\"Handle order shipped\"\"\"\n        user_id = int(data.split(\"_\")[2])\n        admin_name = query.from_user.first_name or \"ادمین\"\n\n        updated_text = f\"🚚 {admin_name}: سفارش ارسال شد\\n\" + query.message.text\n\n        keyboard = [[\n            InlineKeyboardButton(\"✅ تکمیل شد\",\n                                 callback_data=f\"order_completed_{user_id}\")\n        ]]\n\n        await query.edit_message_text(\n            updated_text, reply_markup=InlineKeyboardMarkup(keyboard))\n\n        # Notify customer - improved error handling\n        try:\n            await query.bot.send_message(\n                chat_id=user_id,\n                text=\"🚚 سفارش شما ارسال شد! به زودی دریافت خواهید کرد.\")\n            logger.info(f\"Successfully notified customer {user_id}\")\n        except Exception as e:\n            logger.error(f\"Error notifying customer {user_id}: {e}\")\n            # Continue processing even if customer notification fails\n\n    async def _handle_order_completed(self, query, data):\n        \"\"\"Handle order completion\"\"\"\n        user_id = int(data.split(\"_\")[2])\n        admin_name = query.from_user.first_name or \"ادمین\"\n\n        updated_text = f\"✅ {admin_name}: سفارش تکمیل شد\\n\" + query.message.text\n\n        await query.edit_message_text(updated_text)\n\n        # Notify customer - improved error handling\n        try:\n            await query.bot.send_message(\n                chat_id=user_id,\n                text=\n                \"✅ سفارش شما با موفقیت تکمیل شد!\\n🙏 از اعتماد شما متشکریم. امیدواریم از خرید خود راضی باشید.\"\n            )\n            logger.info(f\"Successfully notified customer {user_id}\")\n        except Exception as e:\n            logger.error(f\"Error notifying customer {user_id}: {e}\")\n            # Continue processing even if customer notification fails\n\n    async def _handle_order_cancelled(self, query, data):\n        \"\"\"Handle order cancellation\"\"\"\n        user_id = int(data.split(\"_\")[2])\n        admin_name = query.from_user.first_name or \"ادمین\"\n\n        updated_text = f\"❌ {admin_name}: سفارش لغو شد\\n\" + query.message.text\n\n        await query.edit_message_text(updated_text)\n\n        # Notify customer - improved error handling\n        try:\n            await query.bot.send_message(\n                chat_id=user_id,\n                text=\n                \"❌ متأسفانه سفارش شما لغو شد.\\n📞 برای اطلاعات بیشتر با پشتیبانی تماس بگیرید.\"\n            )\n            logger.info(f\"Successfully notified customer {user_id}\")\n        except Exception as e:\n            logger.error(f\"Error notifying customer {user_id}: {e}\")\n            # Continue processing even if customer notification fails\n\n    async def _handle_order_reminder(self, query, data):\n        \"\"\"Handle order reminder for tomorrow\"\"\"\n        user_id = int(data.split(\"_\")[2])\n        admin_name = query.from_user.first_name or \"ادمین\"\n\n        updated_text = f\"⏰ {admin_name}: یادآوری فردا تنظیم شد\\n\" + query.message.text\n\n        # Keep all original buttons\n        keyboard = [[\n            InlineKeyboardButton(\"✅ تماس گرفته شد\",\n                                 callback_data=f\"order_contacted_{user_id}\"),\n            InlineKeyboardButton(\"📦 آماده ارسال\",\n                                 callback_data=f\"order_ready_{user_id}\")\n        ],\n                    [\n                        InlineKeyboardButton(\n                            \"🚚 ارسال شد\",\n                            callback_data=f\"order_shipped_{user_id}\"),\n                        InlineKeyboardButton(\n                            \"✅ تکمیل شد\",\n                            callback_data=f\"order_completed_{user_id}\")\n                    ],\n                    [\n                        InlineKeyboardButton(\n                            \"❌ لغو سفارش\",\n                            callback_data=f\"order_cancelled_{user_id}\")\n                    ]]\n\n        await query.edit_message_text(\n            updated_text, reply_markup=InlineKeyboardMarkup(keyboard))\n\n    async def _handle_order_status_update(self, query, data):\n        \"\"\"Handle order status update from admin\"\"\"\n        try:\n            logger.info(f\"🔄 شروع پردازش تغییر وضعیت: {data}\")\n            \n            # Parse callback data: order_status_ORDER_ID_STATUS\n            parts = data.split(\"_\")\n            if len(parts) < 4:\n                logger.error(f\"❌ فرمت داده نامعتبر: {data}\")\n                await query.answer(\"❌ داده نامعتبر\", show_alert=True)\n                return\n\n            order_id = parts[2]\n            new_status = parts[3]\n            admin_name = query.from_user.first_name or \"ادمین\"\n\n            logger.info(f\"📋 پردازش سفارش {order_id} به وضعیت {new_status} توسط {admin_name}\")\n\n            # ابتدا پاسخ سریع به کاربر بده\n            await query.answer(\"🔄 در حال پردازش...\")\n\n            # بررسی وجود سفارش\n            order_data = await self.order_server.get_order_details(order_id)\n            if not order_data:\n                logger.error(f\"❌ سفارش {order_id} یافت نشد\")\n                await query.answer(\"❌ سفارش یافت نشد\", show_alert=True)\n                return\n\n            # Update order status با ارسال اطلاع‌رسانی به مشتری\n            success = await self.order_server.update_order_status(\n                order_id=order_id,\n                new_status=new_status,\n                admin_name=admin_name\n            )\n\n            if success:\n                logger.info(f\"✅ وضعیت سفارش {order_id} با موفقیت تغییر کرد\")\n                status_text = self.order_server._get_status_text(new_status)\n                \n                # به‌روزرسانی پیام گروه\n                try:\n                    current_text = query.message.text or \"\"\n                    updated_text = f\"📝 {admin_name}: وضعیت به '{status_text}' تغییر کرد\\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n{current_text}\"\n\n                    # ایجاد کیبورد جدید\n                    keyboard = self.order_server._create_admin_buttons(order_id, order_data['user_id'])\n\n                    await query.edit_message_text(\n                        updated_text,\n                        reply_markup=InlineKeyboardMarkup(keyboard)\n                    )\n                    logger.info(f\"✅ پیام گروه به‌روزرسانی شد و اطلاع‌رسانی به مشتری ارسال شد\")\n                    \n                except Exception as edit_error:\n                    logger.error(f\"❌ خطا در به‌روزرسانی پیام گروه: {edit_error}\")\n                    # ارسال پیام جدید در صورت خطا در ویرایش\n                    try:\n                        confirmation_message = f\"✅ وضعیت سفارش {order_id} به '{status_text}' تغییر کرد توسط {admin_name}\"\n                        await query.message.reply_text(confirmation_message)\n                        logger.info(f\"✅ پیام جدید ارسال شد\")\n                    except Exception as reply_error:\n                        logger.error(f\"❌ خطا در ارسال پیام جدید: {reply_error}\")\n                        \n            else:\n                logger.error(f\"❌ خطا در به‌روزرسانی وضعیت سفارش {order_id}\")\n                await query.answer(\"❌ خطا در به‌روزرسانی وضعیت\", show_alert=True)\n\n        except Exception as e:\n            logger.error(f\"❌ خطای کلی در _handle_order_status_update: {e}\")\n            logger.error(f\"   Data: {data}\")\n            logger.error(f\"   User: {query.from_user.first_name if query.from_user else 'Unknown'}\")\n            \n            try:\n                await query.answer(f\"❌ خطا در پردازش: {str(e)[:30]}\", show_alert=True)\n            except Exception as msg_error:\n                logger.error(f\"❌ خطا در ارسال پیام خطا: {msg_error}\")\n\n    \n\n    async def _handle_order_details_request(self, query, data):\n        \"\"\"Handle request for order details\"\"\"\n        try:\n            order_id = data.replace(\"order_details_\", \"\")\n            order_data = await self.order_server.get_order_details(order_id)\n\n            if not order_data:\n                await query.answer(\"❌ سفارش یافت نشد\")\n                return\n\n            # Create detailed invoice message\n            customer = order_data.get('customer', {})\n            pricing = order_data.get('pricing', {})\n            cart_items = order_data.get('cart_items', [])\n            \n            invoice_text = (\n                f\"📋 فاکتور - {order_id}\\n\"\n                f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n                f\"👤 {customer.get('name', 'نامشخص')}\\n\"\n                f\"🏙️ {customer.get('city', 'نامشخص')}\\n\"\n                f\"🆔 کد نمایندگی: {customer.get('customer_id', 'نامشخص')}\\n\"\n                f\"📱 شناسه کاربر: {order_data.get('user_id', 'نامشخص')}\\n\"\n                f\"⏰ {persian_numbers(order_data.get('created_at', '')[:16].replace('T', ' - '))}\\n\\n\"\n                f\"📦 آیتم‌ها:\\n\"\n            )\n\n            # Add cart items\n            for i, item in enumerate(cart_items, 1):\n                item_total = item.get('price', 0) * item.get('quantity', 0)\n                invoice_text += (\n                    f\"{persian_numbers(str(i))}. {item.get('product_name', 'محصول')}\\n\"\n                    f\"   📏 {item.get('size', 'نامشخص')} | \"\n                    f\"📦 {persian_numbers(str(item.get('quantity', 0)))} عدد | \"\n                    f\"💰 {format_price(item_total)}\\n\"\n                )\n\n            # Add pricing\n            invoice_text += (\n                f\"\\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n                f\"💳 {order_data.get('payment_method', 'نقدی')}\\n\"\n                f\"💰 مبلغ کل: {format_price(pricing.get('total', 0))} تومان\\n\"\n                f\"📊 {self.order_server._get_status_text(order_data.get('status', 'pending'))}\"\n            )\n\n            # Create management keyboard\n            keyboard = self.order_server._create_admin_buttons(order_id, order_data['user_id'])\n            keyboard.append([InlineKeyboardButton(\"🔙 بازگشت به لیست\", callback_data=\"back_to_daily_orders\")])\n\n            await query.edit_message_text(\n                invoice_text,\n                reply_markup=InlineKeyboardMarkup(keyboard)\n            )\n\n        except Exception as e:\n            logger.error(f\"Error showing order details: {e}\")\n            await query.answer(\"❌ خطا در نمایش جزئیات\")\n\n    async def _handle_daily_stats_request(self, query):\n        \"\"\"Handle daily statistics request\"\"\"\n        try:\n            stats = await self.order_server.get_orders_statistics()\n            today_orders = await self.order_server.get_todays_orders()\n\n            stats_text = (\n                f\"📊 آمار امروز ({persian_numbers(datetime.now().strftime('%Y/%m/%d'))})\\n\"\n                f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n                f\"📦 سفارشات امروز: {persian_numbers(str(len(today_orders)))}\\n\"\n                f\"💰 درآمد امروز: {format_price(stats.get('today_revenue', 0))} تومان\\n\\n\"\n                f\"📈 آمار کلی:\\n\"\n                f\"📦 کل سفارشات: {persian_numbers(str(stats.get('total_orders', 0)))}\\n\"\n                f\"💳 کل درآمد: {format_price(stats.get('total_revenue', 0))} تومان\\n\"\n            )\n\n            keyboard = [[\n                InlineKeyboardButton(\"🔙 بازگشت\", callback_data=\"back_to_daily_orders\")\n            ]]\n\n            await query.edit_message_text(\n                stats_text,\n                reply_markup=InlineKeyboardMarkup(keyboard)\n            )\n\n        except Exception as e:\n            logger.error(f\"Error showing daily stats: {e}\")\n            await query.answer(\"❌ خطا در نمایش آمار\")\n\n    async def _handle_refresh_daily_orders(self, query):\n        \"\"\"Handle refresh daily orders request\"\"\"\n        await query.answer(\"🔄 در حال بروزرسانی...\")\n\n        # Create a fake update object to reuse the _show_daily_orders method\n        class FakeUpdate:\n            def __init__(self, message):\n                self.message = message\n\n        fake_update = FakeUpdate(query.message)\n        await self._show_daily_orders(fake_update)\n\n    async def _handle_back_to_daily_orders(self, query):\n        \"\"\"Handle back to daily orders list\"\"\"\n        # Create a fake update object to reuse the _show_daily_orders method\n        class FakeUpdate:\n            def __init__(self, message):\n                self.message = message\n\n        fake_update = FakeUpdate(query.message)\n        await self._show_daily_orders(fake_update)\n\n    async def _handle_contact_customer_request(self, query, data):\n        \"\"\"Handle request to contact customer\"\"\"\n        try:\n            user_id = int(data.replace(\"contact_customer_\", \"\"))\n\n            contact_message = (\n                f\"📞 درخواست تماس با مشتری\\n\"\n                f\"🆔 شناسه کاربر: {user_id}\\n\\n\"\n                f\"لطفاً از طریق تلفن یا پیام مستقیم با مشتری تماس بگیرید.\"\n            )\n\n            await query.answer(\"✅ اطلاعات تماس نمایش داده شد\")\n            await query.message.reply_text(contact_message)\n\n        except Exception as e:\n            logger.error(f\"Error handling contact request: {e}\")\n            await query.answer(\"❌ خطا در پردازش درخواست\")\n\n    async def _handle_check_order_status(self, query, data):\n        \"\"\"Handle customer's request to check order status\"\"\"\n        try:\n            order_id = data.replace(\"check_order_status_\", \"\")\n            order_data = await self.order_server.get_order_details(order_id)\n\n            if not order_data:\n                await query.edit_message_text(\n                    \"❌ سفارش یافت نشد.\",\n                    reply_markup=InlineKeyboardMarkup([[\n                        InlineKeyboardButton(\"🏠 منوی اصلی\", callback_data=\"main_menu\")\n                    ]]))\n                return\n\n            status_text = self.order_server._get_status_text(order_data[\"status\"])\n            last_update = datetime.fromisoformat(order_data[\"updated_at\"]).strftime(\"%Y/%m/%d - %H:%M\")\n\n            status_message = (\n                f\"📋 وضعیت سفارش شماره: {order_id}\\n\\n\"\n                f\"📊 وضعیت فعلی: {status_text}\\n\"\n                f\"⏰ آخرین به‌روزرسانی: {persian_numbers(last_update)}\\n\"\n                f\"💳 روش پرداخت: {order_data['payment_method']}\\n\"\n                f\"💰 مبلغ کل: {format_price(order_data['pricing']['total'])} تومان\"\n            )\n\n            keyboard = self.order_server._create_customer_support_buttons(order_id)\n\n            await query.edit_message_text(\n                status_message,\n                reply_markup=InlineKeyboardMarkup(keyboard)\n            )\n\n        except Exception as e:\n            logger.error(f\"Error checking order status: {e}\")\n            await query.edit_message_text(\"❌ خطا در بررسی وضعیت سفارش\")\n\n    async def _handle_payment_confirmation_from_group(self, query, data):\n        \"\"\"Handle payment confirmation from the payment reminder group\"\"\"\n        try:\n            # Extract schedule_id and payment_number from callback data\n            parts = data.split(\"_\")\n            schedule_id = parts[2]\n            payment_number = int(parts[3])\n\n            # Mark payment as made\n            success = self.payment_scheduler.mark_payment_made(schedule_id, payment_number)\n\n            if success:\n                await query.edit_message_text(\n                    query.message.text + \"\\n\\n✅ پرداخت تایید شد\"\n                )\n                await query.answer(\"✅ پرداخت با موفقیت ثبت شد!\")\n            else:\n                await query.answer(\"❌ خطا در ثبت پرداخت\")\n\n        except Exception as e:\n            logger.error(f\"Error handling payment confirmation: {e}\")\n            await query.answer(\"❌ خطا در پردازش درخواست\")\n\n    async def _handle_contact_made_from_group(self, query, data):\n        \"\"\"Handle contact made confirmation from the payment reminder group\"\"\"\n        try:\n            admin_name = query.from_user.first_name or \"ادمین\"\n\n            await query.edit_message_text(\n                query.message.text + f\"\\n\\n📞 {admin_name} با مشتری تماس گرفت\"\n            )\n            await query.answer(\"✅ تماس ثبت شد\")\n\n        except Exception as e:\n            logger.error(f\"Error handling contact confirmation: {e}\")\n            await query.answer(\"❌ خطا در پردازش درخواست\")\n\n    async def _handle_remind_tomorrow_from_group(self, query, data):\n        \"\"\"Handle remind tomorrow request from the payment reminder group\"\"\"\n        try:\n            admin_name = query.from_user.first_name or \"ادمین\"\n\n            await query.edit_message_text(\n                query.message.text + f\"\\n\\n⏰ {admin_name} یادآوری فردا تنظیم کرد\"\n            )\n            await query.answer(\"⏰ یادآوری برای فردا تنظیم شد\")\n\n        except Exception as e:\n            logger.error(f\"Error handling remind tomorrow: {e}\")\n            await query.answer(\"❌ خطا در پردازش درخواست\")\n\n    async def _handle_contact_support_request(self, query):\n        \"\"\"Handle customer's request to contact support\"\"\"\n        user_id = query.from_user.id\n        await self.order_server.send_support_contact_info(user_id)\n        await query.answer(\"📞 اطلاعات تماس ارسال شد\")\n\n    async def _handle_faq_request(self, query):\n        \"\"\"Handle customer's request for FAQ\"\"\"\n        user_id = query.from_user.id\n        await self.order_server.send_faq(user_id)\n        await query.answer(\"❓ سوالات متداول ارسال شد\")\n\n    async def _handle_fabric_selection(self, query, data):\n        \"\"\"Handle fabric selection for curtains\"\"\"\n        fabric = data.replace(\"fabric_\", \"\")\n        user_id = query.from_user.id\n\n        # Store selected fabric in session\n        self.user_sessions[user_id]['selected_fabric'] = fabric\n        category = 'curtain_only'\n        self.user_sessions[user_id]['selected_category'] = category\n\n        # Get price based on fabric\n        price = get_product_price('', category, fabric=fabric)\n\n        fabric_name = \"حریر کتان\" if fabric == \"silk_cotton\" else \"مخمل\"\n\n        text = (f\"✅ جنس انتخابی: {fabric_name}\\n\"\n                f\"💰 قیمت: {format_price(price)} تومان\\n\\n\"\n                \"عالیه! انتخابت. عرض پرده‌ها همیشه ثابت هست برای ایکون پرده سرتخت 135 هست و ارتفاع از 2 متر به بالا متغیر. پس ارتفاع مد نظرتو تایپ کن برام:\")\n\n        # Set flag for height input\n        self.user_sessions[user_id]['awaiting_curtain_height'] = True\n\n        keyboard = self.keyboards.get_height_input_keyboard()\n        await query.edit_message_text(text, reply_markup=keyboard)\n\n    async def _handle_curtain_height_input(self, update, height_text):\n        \"\"\"Handle curtain height input\"\"\"\n        user_id = update.effective_user.id\n\n        try:\n            # Parse height (should be a number)\n            height = float(height_text)\n            if height < 2:\n                await update.message.reply_text(\n                    \"❌ ارتفاع باید حداقل 2 متر باشد. لطفاً دوباره وارد کنید:\")\n                return\n\n            # Store height and clear input flag\n            self.user_sessions[user_id]['selected_height'] = height\n            self.user_sessions[user_id]['awaiting_curtain_height'] = False\n\n            # Create custom size string for curtains\n            size = f\"عرض: 135 - ارتفاع: {height}م\"\n            self.user_sessions[user_id]['selected_size'] = size\n\n            # Get price based on fabric\n            fabric = self.user_sessions[user_id]['selected_fabric']\n            category = self.user_sessions[user_id]['selected_category']\n\n            if fabric == 'special':  # For bedside curtain\n                product = self.user_sessions[user_id]['selected_product']\n                price = get_product_price(product['id'], category)\n            else:\n                price = get_product_price('', category, fabric=fabric)\n\n            text = (f\"✅ ارتفاع انتخابی: {height} متر\\n\"\n                    f\"💰 قیمت: {format_price(price)} تومان\\n\\n\"\n                    \"حالا پردت چند قواره باشه؟\")\n\n            keyboard = self.keyboards.get_quantity_keyboard()\n            await update.message.reply_text(text, reply_markup=keyboard)\n\n        except ValueError:\n            await update.message.reply_text(\n                \"❌ لطفاً ارتفاع را به صورت عدد وارد کنید (مثال: 2.5):\")\n\n    async def _handle_back_to_fabric_selection(self, query):\n        \"\"\"Handle back to fabric selection\"\"\"\n        user_id = query.from_user.id\n\n        # Clear height input flag\n        if 'awaiting_curtain_height' in self.user_sessions[user_id]:\n            del self.user_sessions[user_id]['awaiting_curtain_height']\n\n        product = self.user_sessions[user_id].get('selected_product')\n        if product:\n            text = (f\"📦 {product['name']}\\n\\n\"\n                    \"عالیه! مدل پرده‌ای که انتخاب کردی. حالا جنس پارچش چی باشه؟\")\n            keyboard = self.keyboards.get_fabric_selection_keyboard()\n            await query.edit_message_text(text, reply_markup=keyboard)\n\n    async def _handle_order_actions(self, query, data):\n        \"\"\"Optimized handler for all order-related actions\"\"\"\n        try:\n            if data.startswith(\"order_contacted_\"):\n                await self._handle_order_contacted(query, data)\n            elif data.startswith(\"order_ready_\"):\n                await self._handle_order_ready(query, data)\n            elif data.startswith(\"order_shipped_\"):\n                await self._handle_order_shipped(query, data)\n            elif data.startswith(\"order_completed_\"):\n                await self._handle_order_completed(query, data)\n            elif data.startswith(\"order_cancelled_\"):\n                await self._handle_order_cancelled(query, data)\n            elif data.startswith(\"order_remind_\"):\n                await self._handle_order_reminder(query, data)\n            else:\n                logger.warning(f\"Unhandled order action: {data}\")\n                await query.answer(\"درحال پردازش...\")\n        except Exception as e:\n            logger.error(f\"Order action error: {e}\")\n            try:\n                await query.answer(\"❌ خطا در پردازش سفارش.\")\n            except:\n                pass\n\n    def _is_authenticated(self, user_id: int) -> bool:\n        \"\"\"Check if user is authenticated\"\"\"\n        return (user_id in self.user_sessions\n                and self.user_sessions[user_id].get('authenticated', False))\n\n    async def test_group_connection(self, bot):\n        \"\"\"Test if bot can send messages to the configured group\"\"\"\n        logger.info(\"🔍 Testing group connection...\")\n\n        if not self.config.order_group_chat_id:\n            logger.warning(\"❌ Order group chat ID is not configured\")\n            return False\n\n        try:\n            # Try to get chat info\n            chat = await bot.get_chat(self.config.order_group_chat_id)\n            logger.info(f\"✅ Group connection successful!\")\n            logger.info(f\"   Title: {chat.title}\")\n            logger.info(f\"   Type: {chat.type}\")\n            logger.info(f\"   ID: {chat.id}\")\n\n            return True\n        except Exception as e:\n            logger.warning(f\"⚠️ Group connection test failed: {e}\")\n            logger.info(\"   Note: This is normal during startup - bot will work fine\")\n            return False\n\n    async def get_current_chat_info(self, bot, chat_id):\n        \"\"\"Get detailed info about current chat for debugging\"\"\"\n        try:\n            chat = await bot.get_chat(chat_id)\n            logger.info(f\"💬 Chat Info:\")\n            logger.info(f\"   ID: {chat.id}\")\n            logger.info(f\"   Title: {chat.title}\")\n            logger.info(f\"   Type: {chat.type}\")\n            logger.info(f\"   Description: {getattr(chat, 'description', 'N/A')}\")\n            return chat\n        except Exception as e:\n            logger.error(f\"Error getting chat info: {e}\")\n            return None\n\n\n    async def _send_invoice_to_group(self, invoice_text, user_id):\n        \"\"\"Send invoice to group after order completion\"\"\"\n        group_chat_id = self.config.order_group_chat_id\n        if not group_chat_id:\n            logger.error(\"Group chat ID not configured.\")\n            return\n\n        try:\n            # Note: self.bot is not available in handlers, we need to get it from context\n            logger.info(f\"Invoice sent to group {group_chat_id} for user {user_id}.\")\n        except Exception as e:\n            logger.error(f\"Failed to send invoice to group: {e}\")\n\n    async def _handle_60day_order_confirmation(self, query):\n        \"\"\"Handle confirmation for 60-day payment orders.\"\"\"\n        user_id = query.from_user.id\n\n        if not self._is_authenticated(user_id):\n            await query.edit_message_text(\"❌ ابتدا باید احراز هویت کنید.\")\n            return\n\n        payment_info = self.user_sessions[user_id].get('payment_info')\n        if not payment_info or payment_info['payment_type'] != '60day':\n            await query.edit_message_text(\n                \"❌ اطلاعات سفارش 60 روزه یافت نشد. لطفاً دوباره تلاش کنید.\",\n                reply_markup=self.keyboards.get_main_menu(authenticated=True))\n            return\n\n        customer = self.user_sessions[user_id]['customer']\n        cart_items = self.cart_manager.get_cart(user_id)\n\n        # Schedule the 60-day payment reminder\n        total_amount = payment_info['full_amount']\n        advance_paid = payment_info['amount']\n        remaining_amount = total_amount - advance_paid\n        order_id = f\"ORDER_{user_id}_{int(datetime.now().timestamp())}\"\n\n        self.payment_scheduler.add_60day_payment_schedule(\n            user_id=user_id,\n            customer_info=customer,\n            total_amount=total_amount,\n            advance_paid=advance_paid,\n            remaining_amount=remaining_amount,\n            order_id=order_id\n        )\n        logger.info(f\"✅ برنامه پرداخت 60 روزه برای کاربر {user_id} تنظیم شد\")\n\n        try:\n            # Create order using order management server\n            order_id = await self.order_server.create_order(\n                user_id=user_id,\n                customer=customer,\n                cart_items=cart_items,\n                payment_method=payment_info['payment_method'],\n                discount_rate=payment_info['discount_rate']\n            )\n\n            # Clear cart and payment info\n            self.cart_manager.clear_cart(user_id)\n            if 'payment_info' in self.user_sessions[user_id]:\n                del self.user_sessions[user_id]['payment_info']\n\n            # Confirm to customer\n            await query.edit_message_text(\n                f\"✅ سفارش شما با موفقیت ثبت شد!\\n\"\n                f\"📋 شماره سفارش: {order_id}\\n\"\n                f\"💳 روش پرداخت: {payment_info['payment_method']}\\n\"\n                f\"📅 یادآوری ماهانه برای پیگیری مابقی پرداخت فعال شد.\\n\"\n                f\"📞 کارشناسان ما به زودی با شما تماس خواهند گرفت.\\n\"\n                f\"🙏 از اعتماد شما ممنونیم.\",\n                reply_markup=self.keyboards.get_main_menu(authenticated=True))\n\n            logger.info(f\"✅ سفارش 60 روزه {order_id} با موفقیت ثبت شد برای کاربر {user_id}\")\n\n        except Exception as e:\n            logger.error(f\"Error in 60-day order confirmation: {e}\")\n            await query.edit_message_text(\n                \"❌ خطایی در ثبت سفارش رخ داد. لطفاً دوباره تلاش کنید.\",\n                reply_markup=self.keyboards.get_main_menu(authenticated=True))","size_bytes":125465},"payment_data/bot/hesabfa_integration.py":{"content":"\n#!/usr/bin/env python3\n\"\"\"\nHesabfa API Integration\nادغام با نرم‌افزار حسابفا برای ثبت خودکار پیش‌فاکتورها\n\"\"\"\n\nimport requests\nimport json\nfrom typing import Dict, List, Optional, Any\nfrom datetime import datetime\nfrom utils.logger import setup_logger\nfrom utils.persian_utils import format_price, persian_numbers\n\nlogger = setup_logger(__name__)\n\nclass HesabfaAPI:\n    \"\"\"کلاس ادغام با API حسابفا\"\"\"\n    \n    def __init__(self, api_key: str = \"WjJ88NUd9rjK6dIUKYilbtCoPFCUFHs8\"):\n        self.api_key = api_key\n        self.base_url = \"https://api.hesabfa.com/v1\"\n        self.headers = {\n            \"Content-Type\": \"application/json\",\n            \"apikey\": self.api_key\n        }\n    \n    async def create_invoice(self, order_data: Dict) -> Dict[str, Any]:\n        \"\"\"ایجاد پیش‌فاکتور در حسابفا\"\"\"\n        try:\n            logger.info(f\"🔄 شروع ثبت فاکتور در حسابفا برای سفارش {order_data.get('order_id')}\")\n            \n            # آماده‌سازی داده‌های فاکتور\n            invoice_data = self._prepare_invoice_data(order_data)\n            logger.info(f\"📋 داده‌های فاکتور آماده شد: {json.dumps(invoice_data, ensure_ascii=False, indent=2)}\")\n            \n            # ارسال درخواست به API حسابفا\n            url = f\"{self.base_url}/invoice\"\n            logger.info(f\"🌐 ارسال درخواست به: {url}\")\n            \n            response = requests.post(\n                url, \n                headers=self.headers, \n                json=invoice_data,\n                timeout=30  # افزودن timeout\n            )\n            \n            logger.info(f\"📡 پاسخ حسابفا: Status={response.status_code}\")\n            \n            if response.status_code == 200:\n                result = response.json()\n                logger.info(f\"📄 محتوای پاسخ: {json.dumps(result, ensure_ascii=False, indent=2)}\")\n                \n                if result.get(\"Success\"):\n                    invoice_result = result.get(\"Result\", {})\n                    logger.info(f\"✅ پیش‌فاکتور با موفقیت در حسابفا ثبت شد - ID: {invoice_result.get('Id')}\")\n                    return {\n                        \"success\": True,\n                        \"invoice_id\": invoice_result.get(\"Id\"),\n                        \"invoice_number\": invoice_result.get(\"Number\"),\n                        \"message\": \"پیش‌فاکتور با موفقیت در حسابفا ثبت شد\"\n                    }\n                else:\n                    error_msg = result.get(\"ErrorMessage\", \"خطای نامشخص\")\n                    logger.error(f\"❌ خطا در ثبت پیش‌فاکتور: {error_msg}\")\n                    return {\n                        \"success\": False,\n                        \"error\": error_msg\n                    }\n            else:\n                response_text = response.text[:500] if response.text else \"بدون محتوا\"\n                logger.error(f\"❌ خطا در ارتباط با حسابفا: HTTP {response.status_code}\")\n                logger.error(f\"   Response: {response_text}\")\n                return {\n                    \"success\": False,\n                    \"error\": f\"خطا در ارتباط با حسابفا: {response.status_code} - {response_text[:100]}\"\n                }\n                \n        except requests.exceptions.Timeout:\n            logger.error(\"❌ Timeout در ارتباط با حسابفا\")\n            return {\n                \"success\": False,\n                \"error\": \"زمان انتظار ارتباط با حسابفا به پایان رسید\"\n            }\n        except requests.exceptions.ConnectionError:\n            logger.error(\"❌ مشکل در اتصال به حسابفا\")\n            return {\n                \"success\": False,\n                \"error\": \"عدم دسترسی به سرور حسابفا\"\n            }\n        except Exception as e:\n            logger.error(f\"❌ خطا در ایجاد پیش‌فاکتور حسابفا: {e}\")\n            logger.error(f\"   نوع خطا: {type(e).__name__}\")\n            return {\n                \"success\": False,\n                \"error\": f\"خطای سیستمی: {str(e)}\"\n            }\n    \n    def _prepare_invoice_data(self, order_data: Dict) -> Dict:\n        \"\"\"آماده‌سازی داده‌های فاکتور برای حسابفا\"\"\"\n        customer = order_data.get(\"customer\", {})\n        cart_items = order_data.get(\"cart_items\", [])\n        pricing = order_data.get(\"pricing\", {})\n        \n        # آماده‌سازی اطلاعات مشتری\n        contact_data = {\n            \"Name\": customer.get(\"name\", \"مشتری\"),\n            \"Code\": customer.get(\"customer_id\", \"\"),\n            \"City\": customer.get(\"city\", \"\"),\n            \"ContactType\": 1  # 1 = مشتری\n        }\n        \n        # آماده‌سازی آیتم‌های فاکتور\n        invoice_items = []\n        for item in cart_items:\n            invoice_items.append({\n                \"ItemCode\": item.get(\"product_id\", \"\"),\n                \"ItemName\": item.get(\"product_name\", \"\"),\n                \"Description\": f\"سایز: {item.get('size', '')}\",\n                \"Quantity\": item.get(\"quantity\", 1),\n                \"UnitPrice\": item.get(\"price\", 0),\n                \"Tax\": 0,  # مالیات محاسبه شده جداگانه\n                \"Discount\": 0\n            })\n        \n        # داده‌های اصلی فاکتور\n        invoice_data = {\n            \"Contact\": contact_data,\n            \"InvoiceItems\": invoice_items,\n            \"Number\": order_data.get(\"order_id\", \"\"),\n            \"Date\": datetime.now().strftime(\"%Y/%m/%d\"),\n            \"DueDate\": datetime.now().strftime(\"%Y/%m/%d\"),\n            \"Status\": 0,  # 0 = پیش‌فاکتور\n            \"Reference\": f\"سفارش تلگرام - {order_data.get('order_id')}\",\n            \"Notes\": f\"روش پرداخت: {order_data.get('payment_method', '')}\\nکاربر تلگرام: {order_data.get('user_id', '')}\",\n            \"Tag\": \"تلگرام-بات\",\n            \"Project\": \"DecoTeen Bot Orders\",\n            \"SalesPerson\": \"ربات فروش\",\n            \"Currency\": \"IRR\"\n        }\n        \n        # اضافه کردن تخفیف در صورت وجود\n        if pricing.get(\"discount\", 0) > 0:\n            invoice_data[\"Discount\"] = pricing.get(\"discount\", 0)\n            invoice_data[\"DiscountType\"] = 1  # 1 = مقدار ثابت\n        \n        return invoice_data\n    \n    async def create_contact_if_not_exists(self, customer: Dict) -> Dict[str, Any]:\n        \"\"\"ایجاد مخاطب در حسابفا در صورت عدم وجود\"\"\"\n        try:\n            contact_data = {\n                \"Name\": customer.get(\"name\", \"مشتری\"),\n                \"Code\": customer.get(\"customer_id\", \"\"),\n                \"City\": customer.get(\"city\", \"\"),\n                \"ContactType\": 1,  # 1 = مشتری\n                \"Tag\": \"تلگرام-بات\",\n                \"Notes\": f\"مشتری ثبت شده از طریق ربات تلگرام\"\n            }\n            \n            url = f\"{self.base_url}/contact\"\n            response = requests.post(url, headers=self.headers, json=contact_data)\n            \n            if response.status_code == 200:\n                result = response.json()\n                if result.get(\"Success\"):\n                    logger.info(f\"✅ مخاطب جدید در حسابفا ثبت شد: {customer.get('name')}\")\n                    return {\n                        \"success\": True,\n                        \"contact_id\": result.get(\"Result\", {}).get(\"Id\")\n                    }\n                else:\n                    # اگر مخاطب از قبل وجود داشت، خطا نیست\n                    logger.info(f\"ℹ️ مخاطب قبلاً در حسابفا وجود داشت: {customer.get('name')}\")\n                    return {\"success\": True}\n            else:\n                logger.warning(f\"⚠️ مشکل در ایجاد مخاطب: HTTP {response.status_code}\")\n                return {\"success\": False}\n                \n        except Exception as e:\n            logger.error(f\"❌ خطا در ایجاد مخاطب: {e}\")\n            return {\"success\": False}\n    \n    async def get_invoice_status(self, invoice_id: str) -> Dict[str, Any]:\n        \"\"\"دریافت وضعیت فاکتور از حسابفا\"\"\"\n        try:\n            url = f\"{self.base_url}/invoice/{invoice_id}\"\n            response = requests.get(url, headers=self.headers)\n            \n            if response.status_code == 200:\n                result = response.json()\n                if result.get(\"Success\"):\n                    return {\n                        \"success\": True,\n                        \"invoice\": result.get(\"Result\")\n                    }\n            \n            return {\"success\": False}\n            \n        except Exception as e:\n            logger.error(f\"خطا در دریافت وضعیت فاکتور: {e}\")\n            return {\"success\": False}\n    \n    async def update_invoice_status(self, invoice_id: str, status: int) -> Dict[str, Any]:\n        \"\"\"به‌روزرسانی وضعیت فاکتور در حسابفا\"\"\"\n        try:\n            # 0 = پیش‌فاکتور، 1 = فاکتور، 2 = پرداخت شده\n            url = f\"{self.base_url}/invoice/{invoice_id}\"\n            data = {\"Status\": status}\n            \n            response = requests.put(url, headers=self.headers, json=data)\n            \n            if response.status_code == 200:\n                result = response.json()\n                if result.get(\"Success\"):\n                    logger.info(f\"✅ وضعیت فاکتور {invoice_id} به‌روزرسانی شد\")\n                    return {\"success\": True}\n            \n            return {\"success\": False}\n            \n        except Exception as e:\n            logger.error(f\"خطا در به‌روزرسانی وضعیت فاکتور: {e}\")\n            return {\"success\": False}\n","size_bytes":10137},"payment_data/bot/keyboards.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nBot Keyboards\nManages all inline keyboards for the Telegram bot.\n\"\"\"\n\nfrom telegram import InlineKeyboardButton, InlineKeyboardMarkup\nfrom typing import List, Dict, Any\nfrom data.product_data import PERSIAN_ALPHABET, get_category_product_icons, search_products_by_icon\n\n\nclass BotKeyboards:\n    \"\"\"Class to manage all bot keyboards\"\"\"\n\n    def get_main_menu(self,\n                      authenticated: bool = False) -> InlineKeyboardMarkup:\n        \"\"\"Get main menu keyboard\"\"\"\n        buttons = []\n\n        if authenticated:\n            buttons.extend([[\n                InlineKeyboardButton(\"🛒 شروع خرید\",\n                                     callback_data=\"start_shopping\")\n            ], [\n                InlineKeyboardButton(\"🛍️ سبد خرید\", callback_data=\"view_cart\")\n            ],\n                            [\n                                InlineKeyboardButton(\n                                    \"📋 مشاهده پیش فاکتور\",\n                                    callback_data=\"view_invoice\")\n                            ]])\n\n        return InlineKeyboardMarkup(buttons)\n\n    def get_categories_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get main product categories keyboard\"\"\"\n        buttons = [\n            [\n                InlineKeyboardButton(\" کالای خواب نوزاد\",\n                                     callback_data=\"category_baby\")\n            ],\n            [\n                InlineKeyboardButton(\" کالای خواب نوجوان\",\n                                     callback_data=\"category_teen\")\n            ],\n            [\n                InlineKeyboardButton(\"کالای خواب بزرگسال\",\n                                     callback_data=\"category_adult\")\n            ],\n            [\n                InlineKeyboardButton(\" پرده\",\n                                     callback_data=\"category_curtain_only\")\n            ],\n            [\n                InlineKeyboardButton(\" کوسن و عروسک\",\n                                     callback_data=\"category_cushion\")\n            ],\n            [\n                InlineKeyboardButton(\"🧸 فرشینه\",\n                                     callback_data=\"category_tablecloth\")\n            ],\n            [InlineKeyboardButton(\"🏠 منوی اصلی\", callback_data=\"main_menu\")]\n        ]\n        return InlineKeyboardMarkup(buttons)\n\n\n\n    def get_curtain_subcategories(self) -> InlineKeyboardMarkup:\n        \"\"\"Get curtain subcategories keyboard with icon navigation\"\"\"\n        buttons = []\n\n        # Get product icons for curtain_only category\n        product_icons = get_category_product_icons('curtain_only')\n\n        # Create buttons for each unique icon - 2 buttons per row\n        row = []\n        for i, (icon, description, product_id) in enumerate(product_icons):\n            button_text = description\n            callback_data = f\"product_{product_id}\"\n            row.append(\n                InlineKeyboardButton(button_text, callback_data=callback_data))\n\n            # Create rows of 2 buttons each\n            if (i + 1) % 2 == 0:\n                buttons.append(row)\n                row = []\n\n        # Add remaining button if any\n        if row:\n            buttons.append(row)\n\n        # Add alphabet search button\n        buttons.append([\n            InlineKeyboardButton(\"🔤 جستجوی حروف الفبایی\",\n                                 callback_data=\"alphabet_search_curtain_only\")\n        ])\n\n        # Add back button\n        buttons.append([\n            InlineKeyboardButton(\"🔙 بازگشت\",\n                                 callback_data=\"back_to_categories\")\n        ])\n\n        return InlineKeyboardMarkup(buttons)\n\n    def get_curtain_only_subcategories(self) -> InlineKeyboardMarkup:\n        \"\"\"Get curtain only subcategories keyboard with icon navigation\"\"\"\n        buttons = []\n\n        # Get product icons for curtain_only category\n        product_icons = get_category_product_icons('curtain_only')\n\n        # Create buttons for each unique icon - 2 buttons per row\n        row = []\n        for i, (icon, description, product_id) in enumerate(product_icons):\n            button_text = description\n            callback_data = f\"product_{product_id}\"\n            row.append(\n                InlineKeyboardButton(button_text, callback_data=callback_data))\n\n            # Create rows of 2 buttons each\n            if (i + 1) % 2 == 0:\n                buttons.append(row)\n                row = []\n\n        # Add remaining button if any\n        if row:\n            buttons.append(row)\n\n        # Add alphabet search button\n        buttons.append([\n            InlineKeyboardButton(\"🔤 جستجوی حروف الفبایی\",\n                                 callback_data=\"alphabet_search_curtain_only\")\n        ])\n\n        # Add back button\n        buttons.append([\n            InlineKeyboardButton(\"🔙 بازگشت\",\n                                 callback_data=\"back_to_curtain_subcategories\")\n        ])\n\n        return InlineKeyboardMarkup(buttons)\n\n    def get_cushion_subcategories(self) -> InlineKeyboardMarkup:\n        \"\"\"Get cushion subcategories keyboard with icon navigation\"\"\"\n        buttons = []\n\n        # Get product icons for cushion category\n        product_icons = get_category_product_icons('cushion')\n\n        # Create buttons for each unique icon - 2 buttons per row\n        row = []\n        for i, (icon, description, product_id) in enumerate(product_icons):\n            button_text = description\n            callback_data = f\"icon_cushion_{icon}\"\n            row.append(\n                InlineKeyboardButton(button_text, callback_data=callback_data))\n\n            # Create rows of 2 buttons each\n            if (i + 1) % 2 == 0:\n                buttons.append(row)\n                row = []\n\n        # Add remaining button if any\n        if row:\n            buttons.append(row)\n\n        # Add alphabet search button\n        buttons.append([\n            InlineKeyboardButton(\"🔤 جستجوی حروف الفبایی\",\n                                 callback_data=\"alphabet_search_cushion\")\n        ])\n\n        # Add back button\n        buttons.append([\n            InlineKeyboardButton(\"🔙 بازگشت\",\n                                 callback_data=\"back_to_curtain_subcategories\")\n        ])\n\n        return InlineKeyboardMarkup(buttons)\n\n    def get_baby_subcategories(self) -> InlineKeyboardMarkup:\n        \"\"\"Get baby subcategories keyboard with icon navigation\"\"\"\n        buttons = []\n\n        # Get product icons for baby category\n        product_icons = get_category_product_icons('baby')\n\n        # Create buttons for each unique icon - 2 buttons per row\n        row = []\n        for i, (icon, description, product_id) in enumerate(product_icons):\n            button_text = description\n            callback_data = f\"icon_baby_{icon}\"\n            row.append(\n                InlineKeyboardButton(button_text, callback_data=callback_data))\n\n            # Create rows of 2 buttons each\n            if (i + 1) % 2 == 0:\n                buttons.append(row)\n                row = []\n\n        # Add remaining button if any\n        if row:\n            buttons.append(row)\n\n        # Add alphabet search button\n        buttons.append([\n            InlineKeyboardButton(\"🔤 جستجوی حروف الفبایی\",\n                                 callback_data=\"alphabet_search_baby\")\n        ])\n\n        # Add back button\n        buttons.append([\n            InlineKeyboardButton(\"🔙 بازگشت\",\n                                 callback_data=\"back_to_categories\")\n        ])\n\n        return InlineKeyboardMarkup(buttons)\n\n    def get_teen_subcategories(self) -> InlineKeyboardMarkup:\n        \"\"\"Get teen subcategories keyboard with size selection\"\"\"\n        buttons = [[\n            InlineKeyboardButton(\"📏 انتخاب سایز\",\n                                 callback_data=\"size_selection_teen\")\n        ],\n                   [\n                       InlineKeyboardButton(\"🔙 بازگشت\",\n                                            callback_data=\"back_to_categories\")\n                   ]]\n        return InlineKeyboardMarkup(buttons)\n\n    def get_adult_subcategories(self) -> InlineKeyboardMarkup:\n        \"\"\"Get adult subcategories keyboard with size selection\"\"\"\n        buttons = [[\n            InlineKeyboardButton(\"📏 انتخاب سایز\",\n                                 callback_data=\"size_selection_adult\")\n        ],\n                   [\n                       InlineKeyboardButton(\"🔙 بازگشت\",\n                                            callback_data=\"back_to_categories\")\n                   ]]\n        return InlineKeyboardMarkup(buttons)\n\n    def get_tablecloth_subcategories(self) -> InlineKeyboardMarkup:\n        \"\"\"Get tablecloth subcategories keyboard with icon navigation\"\"\"\n        buttons = []\n\n        # Get product icons for tablecloth category\n        product_icons = get_category_product_icons('tablecloth')\n\n        # Create buttons for each unique icon - 2 buttons per row\n        row = []\n        for i, (icon, description, product_id) in enumerate(product_icons):\n            button_text = description  # Remove icon from button text\n            callback_data = f\"product_{product_id}\"\n            row.append(\n                InlineKeyboardButton(button_text, callback_data=callback_data))\n\n            # Create rows of 2 buttons each\n            if (i + 1) % 2 == 0:\n                buttons.append(row)\n                row = []\n\n        # Add remaining button if any\n        if row:\n            buttons.append(row)\n\n        # Add alphabet search button\n        buttons.append([\n            InlineKeyboardButton(\"🔤 جستجوی حروف الفبایی\",\n                                 callback_data=\"alphabet_search_tablecloth\")\n        ])\n\n        # Add back button\n        buttons.append([\n            InlineKeyboardButton(\"🔙 بازگشت\",\n                                 callback_data=\"back_to_categories\")\n        ])\n\n        return InlineKeyboardMarkup(buttons)\n\n    def get_alphabetical_keyboard(self, category: str) -> InlineKeyboardMarkup:\n        \"\"\"Get alphabetical search keyboard\"\"\"\n        buttons = []\n        row = []\n\n        for i, letter in enumerate(PERSIAN_ALPHABET):\n            # Create consistent callback data format\n            callback_data = f\"alpha_{category}_{letter}\"\n            row.append(\n                InlineKeyboardButton(letter, callback_data=callback_data))\n\n            # Create rows of 4 buttons each\n            if (i + 1) % 4 == 0:\n                buttons.append(row)\n                row = []\n\n        # Add remaining buttons if any\n        if row:\n            buttons.append(row)\n\n        # Add back button\n        buttons.append([\n            InlineKeyboardButton(\"🔙 بازگشت\",\n                                 callback_data=\"back_to_categories\")\n        ])\n\n        return InlineKeyboardMarkup(buttons)\n\n    def get_products_keyboard(self, products: List[Dict],\n                              category: str) -> InlineKeyboardMarkup:\n        \"\"\"Get products list keyboard\"\"\"\n        buttons = []\n\n        for product in products:\n            button_text = product['name']\n            callback_data = f\"product_{product['id']}\"\n            buttons.append([\n                InlineKeyboardButton(button_text, callback_data=callback_data)\n            ])\n\n        # Add navigation buttons\n        buttons.append(\n            [InlineKeyboardButton(\"🏠 منوی اصلی\", callback_data=\"main_menu\")])\n\n        return InlineKeyboardMarkup(buttons)\n\n    def get_category_products_keyboard(self,\n                                       category: str) -> InlineKeyboardMarkup:\n        \"\"\"Get category products keyboard with icons\"\"\"\n        buttons = []\n\n        # Get product icons for this category\n        product_icons = get_category_product_icons(category)\n\n        # Create buttons for each unique icon - 2 buttons per row\n        row = []\n        for i, (icon, description, product_id) in enumerate(product_icons):\n            button_text = description\n            callback_data = f\"product_{product_id}\"\n            row.append(\n                InlineKeyboardButton(button_text, callback_data=callback_data))\n\n            # Create rows of 2 buttons each\n            if (i + 1) % 2 == 0:\n                buttons.append(row)\n                row = []\n\n        # Add remaining button if any\n        if row:\n            buttons.append(row)\n\n        # Add alphabet search button\n        buttons.append([\n            InlineKeyboardButton(\"🔤 جستجوی حروف الفبایی\",\n                                 callback_data=f\"alphabet_search_{category}\")\n        ])\n\n        # Add back button\n        buttons.append([\n            InlineKeyboardButton(\"🔙 بازگشت\",\n                                 callback_data=\"back_to_categories\")\n        ])\n\n        return InlineKeyboardMarkup(buttons)\n\n    def get_size_selection_keyboard(self,\n                                    category: str) -> InlineKeyboardMarkup:\n        \"\"\"Get size selection keyboard based on category\"\"\"\n        if category == 'baby':\n            # Baby category: only 75×160\n            sizes = [\"75×160\"]\n        elif category in ['teen', 'adult']:\n            # Teen and adult: specific sizes as requested\n            if category == 'teen':\n                sizes = [\n                    \"90×200\",\n                    \"100×200\",\n                    \"120×200\",\n                ]\n            else:  # category == 'adult'\n                sizes = [\n                    \"140×200\",\n                    \"160×200\",\n                    \"180×200\",\n                ]\n        elif category == 'tablecloth':\n            # Tablecloth category: custom sizes with different prices\n            sizes = [\n                \"120×80\",\n                \"100×100\", \n                \"100×150\",\n                \"120×180\"\n            ]\n        else:\n            # Default sizes for other categories\n            sizes = [\n                \"140×200\",\n                \"160×200\",\n                \"180×200\",\n            ]\n\n        buttons = []\n        row = []\n\n        for i, size in enumerate(sizes):\n            row.append(\n                InlineKeyboardButton(size,\n                                     callback_data=f\"size_{size}_{category}\"))\n\n            # Create rows of 3 buttons each for better layout with more sizes\n            if (i + 1) % 3 == 0:\n                buttons.append(row)\n                row = []\n\n        # Add remaining buttons if any\n        if row:\n            buttons.append(row)\n\n        # Add back button\n        buttons.append([\n            InlineKeyboardButton(\"🔙 بازگشت\",\n                                 callback_data=\"back_to_categories\")\n        ])\n\n        return InlineKeyboardMarkup(buttons)\n\n    def get_fabric_selection_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get fabric selection keyboard for curtains\"\"\"\n        buttons = [\n            [\n                InlineKeyboardButton(\"حریر کتان\", callback_data=\"fabric_silk_cotton\"),\n                InlineKeyboardButton(\"مخمل\", callback_data=\"fabric_velvet\")\n            ],\n            [\n                InlineKeyboardButton(\"🔙 بازگشت\", callback_data=\"back_to_categories\")\n            ]\n        ]\n        return InlineKeyboardMarkup(buttons)\n\n    def get_height_input_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get height input keyboard for curtains\"\"\"\n        buttons = [\n            [\n                InlineKeyboardButton(\"🔙 بازگشت\", callback_data=\"back_to_fabric_selection\")\n            ]\n        ]\n        return InlineKeyboardMarkup(buttons)\n\n    def get_quantity_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get quantity selection keyboard\"\"\"\n        buttons = []\n        row = []\n\n        # Quantities 1-10\n        for i in range(1, 11):\n            row.append(InlineKeyboardButton(str(i), callback_data=f\"qty_{i}\"))\n\n            # Create rows of 5 buttons each\n            if i % 5 == 0:\n                buttons.append(row)\n                row = []\n\n        # Add navigation buttons\n        buttons.append([\n            InlineKeyboardButton(\"🔙 بازگشت\", callback_data=\"back_to_products\")\n        ])\n\n        return InlineKeyboardMarkup(buttons)\n\n    def get_payment_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get payment options keyboard\"\"\"\n        buttons = [[\n            InlineKeyboardButton(\"💰 پرداخت نقدی (۳۰٪ تخفیف)\",\n                                 callback_data=\"payment_cash_card\")\n        ],\n                   [\n                       InlineKeyboardButton(\"📅 پرداخت ۶۰ روز (۲۵٪ تخفیف)\",\n                                            callback_data=\"payment_60day_card\")\n                   ],\n                   [\n                       InlineKeyboardButton(\n                           \"💳 پرداخت ۹۰ روز (۲۵٪ تخفیف + ۲۵٪ پیش‌پرداخت)\",\n                           callback_data=\"payment_90day_card\")\n                   ],\n                   [\n                       InlineKeyboardButton(\"🔙 بازگشت به سبد خرید\",\n                                            callback_data=\"view_cart\")\n                   ],\n                   [\n                       InlineKeyboardButton(\"🏠 منوی اصلی\",\n                                            callback_data=\"main_menu\")\n                   ]]\n        return InlineKeyboardMarkup(buttons)\n\n    def get_cart_management_keyboard(self) -> InlineKeyboardMarkup:\n        \"\"\"Get cart management keyboard\"\"\"\n        buttons = [[\n            InlineKeyboardButton(\"📋 مشاهده پیش فاکتور\",\n                                 callback_data=\"view_invoice\")\n        ],\n                   [\n                       InlineKeyboardButton(\"🛒 ادامه خرید\",\n                                            callback_data=\"start_shopping\")\n                   ],\n                   [\n                       InlineKeyboardButton(\"🗑️ پاک کردن سبد\",\n                                            callback_data=\"cart_clear\")\n                   ],\n                   [\n                       InlineKeyboardButton(\"🏠 منوی اصلی\",\n                                            callback_data=\"main_menu\")\n                   ]]\n        return InlineKeyboardMarkup(buttons)","size_bytes":18436},"payment_data/bot/order_server.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nOrder Management Server\nسرور مدیریت و پیگیری سفارشات\n\"\"\"\n\nimport json\nimport os\nfrom datetime import datetime\nfrom typing import Dict, List, Optional, Any\nfrom telegram import Bot, InlineKeyboardButton, InlineKeyboardMarkup\nfrom bot.config import Config\nfrom bot.pricing import PricingManager\nfrom bot.hesabfa_integration import HesabfaAPI\nfrom utils.logger import setup_logger\nfrom utils.persian_utils import format_price, persian_numbers\n\nlogger = setup_logger(__name__)\n\nclass OrderStatus:\n    \"\"\"وضعیت‌های مختلف سفارش\"\"\"\n    PENDING = \"pending\"           # در انتظار\n    CONTACTED = \"contacted\"       # تماس گرفته شد\n    CONFIRMED = \"confirmed\"       # تایید شد\n    PREPARING = \"preparing\"       # در حال آماده‌سازی\n    READY = \"ready\"              # آماده ارسال\n    SHIPPED = \"shipped\"          # ارسال شد\n    DELIVERED = \"delivered\"      # تحویل داده شد\n    COMPLETED = \"completed\"      # تکمیل شد\n    CANCELLED = \"cancelled\"      # لغو شد\n\nclass OrderManagementServer:\n    \"\"\"سرور مدیریت سفارشات\"\"\"\n\n    def __init__(self):\n        self.config = Config()\n        self.pricing_manager = PricingManager()\n        self.hesabfa_api = HesabfaAPI()\n        self.orders_dir = \"order_data\"\n        self.bot = None\n\n        # ایجاد دایرکتوری سفارشات\n        os.makedirs(self.orders_dir, exist_ok=True)\n\n        # پیام‌های وضعیت برای مشتری\n        self.status_messages = {\n            OrderStatus.PENDING: \"📋 سفارش شما ثبت شد و در حال بررسی است.\",\n            OrderStatus.CONTACTED: \"🔄 سفارش شما توسط تیم پشتیبانی دکوتین درحال آماده سازی است.\",\n            OrderStatus.CONFIRMED: \"✅ عالیه! سفارش شما توسط تیم پشتیبانی دکوتین تایید شد.\\n🏦 پیش‌فاکتور شما در سیستم حسابداری ثبت شد.\\n📞 به زودی برای هماهنگی ارسال با شما تماس خواهیم گرفت.\",\n            OrderStatus.PREPARING: \"🔧 سفارش شما در حال آماده‌سازی است.\",\n            OrderStatus.READY: \"📦 سفارش شما آماده ارسال شد!\",\n            OrderStatus.SHIPPED: \"🚚 از انتخاب شما برای خرید از مجموعه دکوتین ممنونیم و سفارش شما ارسال شد.\",\n            OrderStatus.DELIVERED: \"✅ سفارش شما تحویل داده شد.\",\n            OrderStatus.COMPLETED: \"🎉 کاربر گرامی سفارش شما تکمیل شده و در صف ارسال میباشد.\",\n            OrderStatus.CANCELLED: \"\"  # پیام خاص در متد جداگانه\n        }\n\n    def set_bot(self, bot: Bot):\n        \"\"\"تنظیم bot instance\"\"\"\n        self.bot = bot\n\n    def _get_order_file_path(self, order_id: str) -> str:\n        \"\"\"مسیر فایل سفارش\"\"\"\n        return os.path.join(self.orders_dir, f\"order_{order_id}.json\")\n\n    def _generate_order_id(self, user_id: int) -> str:\n        \"\"\"ایجاد شناسه یکتای سفارش\"\"\"\n        # ایجاد شماره سفارش ساده\n        counter_file = os.path.join(self.orders_dir, \"order_counter.txt\")\n\n        try:\n            # خواندن شماره فعلی\n            if os.path.exists(counter_file):\n                with open(counter_file, 'r') as f:\n                    counter = int(f.read().strip())\n            else:\n                counter = 0\n\n            # افزایش شماره\n            counter += 1\n\n            # ذخیره شماره جدید\n            with open(counter_file, 'w') as f:\n                f.write(str(counter))\n\n            return f\"{counter:05d}\"  # شماره 5 رقمی: 00001, 00002, ...\n\n        except Exception as e:\n            logger.error(f\"خطا در ایجاد شماره سفارش: {e}\")\n            # fallback to timestamp\n            timestamp = datetime.now().strftime(\"%H%M%S\")\n            return f\"ORD{timestamp}\"\n\n    async def create_order(self, user_id: int, customer: Dict, cart_items: List[Dict], \n                          payment_method: str, discount_rate: float = 0, receipt_photo_id: str = None) -> str:\n        \"\"\"ایجاد سفارش جدید\"\"\"\n        try:\n            order_id = self._generate_order_id(user_id)\n\n            # محاسبه قیمت‌ها\n            subtotal = self.pricing_manager.calculate_subtotal(cart_items)\n            discount = self.pricing_manager.calculate_discount(subtotal, discount_rate)\n            tax = self.pricing_manager.calculate_tax(subtotal - discount)\n            total = subtotal - discount + tax\n\n            # ایجاد سفارش\n            order_data = {\n                \"order_id\": order_id,\n                \"user_id\": user_id,\n                \"customer\": customer,\n                \"cart_items\": cart_items,\n                \"payment_method\": payment_method,\n                \"pricing\": {\n                    \"subtotal\": subtotal,\n                    \"discount_rate\": discount_rate,\n                    \"discount\": discount,\n                    \"tax\": tax,\n                    \"total\": total\n                },\n                \"status\": OrderStatus.PENDING,\n                \"created_at\": datetime.now().isoformat(),\n                \"updated_at\": datetime.now().isoformat(),\n                \"status_history\": [\n                    {\n                        \"status\": OrderStatus.PENDING,\n                        \"timestamp\": datetime.now().isoformat(),\n                        \"note\": \"سفارش ایجاد شد\"\n                    }\n                ]\n            }\n\n            # ذخیره سفارش\n            await self._save_order(order_data)\n\n            # ارسال پیش‌فاکتور به گروه پشتیبانی\n            await self._send_invoice_to_support_group(order_data, receipt_photo_id)\n\n            # اطلاع‌رسانی به مشتری\n            await self._notify_customer(user_id, OrderStatus.PENDING, order_id)\n\n            logger.info(f\"سفارش جدید ایجاد شد: {order_id}\")\n            return order_id\n\n        except Exception as e:\n            logger.error(f\"خطا در ایجاد سفارش: {e}\")\n            raise\n\n    async def _save_order(self, order_data: Dict):\n        \"\"\"ذخیره سفارش در فایل\"\"\"\n        order_file = self._get_order_file_path(order_data[\"order_id\"])\n\n        try:\n            with open(order_file, 'w', encoding='utf-8') as f:\n                json.dump(order_data, f, ensure_ascii=False, indent=2)\n        except Exception as e:\n            logger.error(f\"خطا در ذخیره سفارش: {e}\")\n            raise\n\n    async def _send_invoice_to_support_group(self, order_data: Dict, receipt_photo_id: str = None):\n        \"\"\"ارسال پیش‌فاکتور به گروه پشتیبانی\"\"\"\n        if not self.bot:\n            logger.warning(\"❌ Bot instance تنظیم نشده است\")\n            return\n\n        if not self.config.order_group_chat_id:\n            logger.warning(\"❌ گروه پشتیبانی تنظیم نشده است\")\n            return\n\n        try:\n            # بررسی دسترسی به گروه\n            try:\n                chat_info = await self.bot.get_chat(self.config.order_group_chat_id)\n                logger.info(f\"✅ دسترسی به گروه تایید شد: {chat_info.title}\")\n            except Exception as chat_error:\n                logger.error(f\"❌ عدم دسترسی به گروه {self.config.order_group_chat_id}: {chat_error}\")\n                return\n\n            # ایجاد پیش‌فاکتور\n            invoice_text = self._generate_invoice_text(order_data)\n\n            # دکمه‌های مدیریت سفارش\n            keyboard = self._create_admin_buttons(order_data[\"order_id\"], order_data[\"user_id\"])\n\n            # اگر عکس فیش وجود دارد، ابتدا آن را ارسال کن\n            if receipt_photo_id:\n                try:\n                    photo_message = await self.bot.send_photo(\n                        chat_id=self.config.order_group_chat_id,\n                        photo=receipt_photo_id,\n                        caption=\"📸 فیش واریزی مشتری\"\n                    )\n                    logger.info(f\"✅ عکس فیش ارسال شد - Message ID: {photo_message.message_id}\")\n                except Exception as photo_error:\n                    logger.error(f\"❌ خطا در ارسال عکس فیش: {photo_error}\")\n                    # ادامه دادن حتی اگر عکس ارسال نشود\n\n            # ارسال فاکتور به گروه\n            sent_message = await self.bot.send_message(\n                chat_id=self.config.order_group_chat_id,\n                text=invoice_text,\n                reply_markup=InlineKeyboardMarkup(keyboard)\n            )\n\n            logger.info(f\"✅ پیش‌فاکتور سفارش {order_data['order_id']} به گروه ارسال شد\")\n            logger.info(f\"   Group ID: {self.config.order_group_chat_id}\")\n            logger.info(f\"   Message ID: {sent_message.message_id}\")\n\n        except Exception as e:\n            logger.error(f\"❌ خطا در ارسال پیش‌فاکتور به گروه: {e}\")\n            logger.error(f\"   Order ID: {order_data.get('order_id', 'Unknown')}\")\n            logger.error(f\"   Group ID: {self.config.order_group_chat_id}\")\n            logger.error(f\"   Error type: {type(e).__name__}\")\n\n            # ارسال اطلاعات بیشتر برای دیباگ\n            if hasattr(e, 'message'):\n                logger.error(f\"   Error message: {e.message}\")\n\n            # حتی اگر ارسال به گروه ناموفق باشد، ادامه پردازش\n\n    def _generate_invoice_text(self, order_data: Dict) -> str:\n        \"\"\"تولید متن پیش‌فاکتور\"\"\"\n        customer = order_data[\"customer\"]\n        cart_items = order_data[\"cart_items\"]\n        pricing = order_data[\"pricing\"]\n\n        invoice_text = (\n            f\"🆕 سفارش جدید - شماره: {order_data['order_id']}\\n\"\n            f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n            f\"👤 نام مشتری: {customer['name']}\\n\"\n            f\"🏙️ شهر: {customer['city']}\\n\"\n            f\"🆔 کد نمایندگی: {customer['customer_id']}\\n\"\n            f\"📱 شناسه کاربر: {order_data['user_id']}\\n\"\n            f\"💳 روش پرداخت: {order_data['payment_method']}\\n\"\n            f\"⏰ زمان ثبت: {persian_numbers('1404/05/14')} - {persian_numbers(datetime.fromisoformat(order_data['created_at']).strftime('%H:%M'))}\\n\\n\"\n            f\"📋 جزئیات سفارش:\\n\"\n            f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n        )\n\n        # آیتم‌های سفارش\n        for i, item in enumerate(cart_items, 1):\n            item_total = item['price'] * item['quantity']\n            invoice_text += (\n                f\"{persian_numbers(str(i))}. {item['product_name']}\\n\"\n                f\"   📏 سایز: {item['size']}\\n\"\n                f\"   📦 تعداد: {persian_numbers(str(item['quantity']))}\\n\"\n                f\"   💰 قیمت: {format_price(item_total)} تومان\\n\\n\"\n            )\n\n        # جمع‌بندی قیمت\n        invoice_text += (\n            f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n            f\"💰 جمع کل: {format_price(pricing['subtotal'])} تومان\\n\"\n        )\n\n        if pricing['discount'] > 0:\n            invoice_text += f\"🎁 تخفیف ({persian_numbers(str(int(pricing['discount_rate'] * 100)))}٪): {format_price(pricing['discount'])} تومان\\n\"\n\n        invoice_text += (\n            f\"📊 مالیات (۹٪): {format_price(pricing['tax'])} تومان\\n\"\n            f\"💳 مبلغ نهایی: {format_price(pricing['total'])} تومان\\n\\n\"\n            f\"📌 وضعیت: {self._get_status_text(order_data['status'])}\"\n        )\n        \n        # اضافه کردن اطلاعات حسابفا در صورت وجود\n        if order_data.get(\"hesabfa_invoice_id\"):\n            invoice_text += (\n                f\"\\n\\n🏦 اطلاعات حسابفا:\\n\"\n                f\"📋 شماره فاکتور: {order_data.get('hesabfa_invoice_number', 'نامشخص')}\\n\"\n                f\"🆔 شناسه فاکتور: {order_data.get('hesabfa_invoice_id')}\"\n            )\n\n        return invoice_text\n\n    def _create_admin_buttons(self, order_id: str, user_id: int) -> List[List[InlineKeyboardButton]]:\n        \"\"\"ایجاد دکمه‌های مدیریت برای ادمین (ساده شده)\"\"\"\n        return [\n            [\n                InlineKeyboardButton(\"✅ تایید سفارش\", callback_data=f\"order_status_{order_id}_confirmed\"),\n                InlineKeyboardButton(\"🔄 در حال پیگیری\", callback_data=f\"order_status_{order_id}_contacted\")\n            ],\n            [\n                InlineKeyboardButton(\"🚚 سفارش ارسال شد\", callback_data=f\"order_status_{order_id}_shipped\"),\n                InlineKeyboardButton(\"🎉 سفارش تکمیل شد\", callback_data=f\"order_status_{order_id}_completed\")\n            ],\n            [\n                InlineKeyboardButton(\"❌ لغو سفارش\", callback_data=f\"order_status_{order_id}_cancelled\")\n            ]\n        ]\n\n    async def update_order_status(self, order_id: str, new_status: str, admin_name: str = \"ادمین\", note: str = \"\") -> bool:\n        \"\"\"به‌روزرسانی وضعیت سفارش\"\"\"\n        try:\n            logger.info(f\"🔄 شروع به‌روزرسانی وضعیت سفارش {order_id} به {new_status}\")\n            \n            # بارگیری سفارش\n            order_data = await self._load_order(order_id)\n            if not order_data:\n                logger.error(f\"❌ سفارش یافت نشد: {order_id}\")\n                return False\n\n            # به‌روزرسانی وضعیت\n            old_status = order_data[\"status\"]\n            order_data[\"status\"] = new_status\n            order_data[\"updated_at\"] = datetime.now().isoformat()\n\n            # اضافه کردن به تاریخچه\n            status_entry = {\n                \"status\": new_status,\n                \"timestamp\": datetime.now().isoformat(),\n                \"admin\": admin_name,\n                \"note\": note or f\"وضعیت از {self._get_status_text(old_status)} به {self._get_status_text(new_status)} تغییر کرد\"\n            }\n            order_data[\"status_history\"].append(status_entry)\n\n            # ابتدا وضعیت را ذخیره کن تا در صورت خطای حسابفا، کار ادامه یابد\n            await self._save_order(order_data)\n            logger.info(f\"✅ وضعیت سفارش {order_id} ذخیره شد\")\n\n            # ثبت پیش‌فاکتور در حسابفا هنگام تایید سفارش (به صورت غیرهمزمان)\n            if new_status == OrderStatus.CONFIRMED and not order_data.get(\"hesabfa_invoice_id\"):\n                logger.info(f\"🔄 شروع ثبت پیش‌فاکتور در حسابفا برای سفارش {order_id}\")\n                \n                # اجرای غیرهمزمان حسابفا برای جلوگیری از blocking\n                import asyncio\n                asyncio.create_task(self._process_hesabfa_invoice(order_id, order_data))\n\n            # اطلاع‌رسانی مستقیم به مشتری\n            user_id = order_data[\"user_id\"]\n            if user_id and self.bot:\n                try:\n                    await self._notify_customer(user_id, new_status, order_id, admin_name)\n                    logger.info(f\"✅ اطلاع‌رسانی به مشتری {user_id} ارسال شد\")\n                except Exception as notify_error:\n                    logger.error(f\"❌ خطا در اطلاع‌رسانی به مشتری: {notify_error}\")\n                    # اجرای غیرهمزمان در صورت خطا\n                    import asyncio\n                    asyncio.create_task(self._notify_customer_async(user_id, new_status, order_id, admin_name))\n\n            logger.info(f\"✅ وضعیت سفارش {order_id} به {new_status} تغییر کرد\")\n            return True\n\n        except Exception as e:\n            logger.error(f\"❌ خطا در به‌روزرسانی وضعیت سفارش {order_id}: {e}\")\n            logger.error(f\"   خطا: {str(e)}\")\n            return False\n\n    async def _load_order(self, order_id: str) -> Optional[Dict]:\n        \"\"\"بارگیری سفارش از فایل\"\"\"\n        order_file = self._get_order_file_path(order_id)\n\n        try:\n            if os.path.exists(order_file):\n                with open(order_file, 'r', encoding='utf-8') as f:\n                    return json.load(f)\n            return None\n        except Exception as e:\n            logger.error(f\"خطا در بارگیری سفارش {order_id}: {e}\")\n            return None\n\n    async def _process_hesabfa_invoice(self, order_id: str, order_data: Dict):\n        \"\"\"پردازش فاکتور حسابفا به صورت غیرهمزمان\"\"\"\n        try:\n            logger.info(f\"🔄 شروع پردازش فاکتور حسابفا برای سفارش {order_id}\")\n            \n            # ابتدا مخاطب را ایجاد کن (در صورت عدم وجود)\n            contact_result = await self.hesabfa_api.create_contact_if_not_exists(order_data[\"customer\"])\n            logger.info(f\"📞 نتیجه ایجاد مخاطب: {contact_result.get('success', False)}\")\n            \n            # ایجاد پیش‌فاکتور در حسابفا با timeout کوتاه‌تر\n            hesabfa_result = await self.hesabfa_api.create_invoice(order_data)\n            logger.info(f\"🏦 نتیجه ثبت فاکتور: {hesabfa_result}\")\n            \n            # بارگیری مجدد سفارش برای به‌روزرسانی\n            current_order = await self._load_order(order_id)\n            if not current_order:\n                logger.error(f\"❌ خطا در بارگیری مجدد سفارش {order_id}\")\n                return\n                \n            if hesabfa_result.get(\"success\"):\n                # ذخیره شناسه فاکتور حسابفا در سفارش\n                current_order[\"hesabfa_invoice_id\"] = hesabfa_result.get(\"invoice_id\")\n                current_order[\"hesabfa_invoice_number\"] = hesabfa_result.get(\"invoice_number\")\n                \n                # اضافه کردن به تاریخچه\n                hesabfa_entry = {\n                    \"status\": \"hesabfa_created\",\n                    \"timestamp\": datetime.now().isoformat(),\n                    \"admin\": \"سیستم\",\n                    \"note\": f\"پیش‌فاکتور در حسابفا ثبت شد - شماره: {hesabfa_result.get('invoice_number')}\"\n                }\n                current_order[\"status_history\"].append(hesabfa_entry)\n                \n                # ذخیره تغییرات\n                await self._save_order(current_order)\n                \n                logger.info(f\"✅ پیش‌فاکتور سفارش {order_id} در حسابفا ثبت شد\")\n                logger.info(f\"   📋 شماره فاکتور: {hesabfa_result.get('invoice_number')}\")\n                logger.info(f\"   🆔 شناسه حسابفا: {hesabfa_result.get('invoice_id')}\")\n                logger.info(f\"   👤 مشتری: {order_data['customer']['name']}\")\n            else:\n                error_message = hesabfa_result.get('error', 'خطای نامشخص')\n                logger.error(f\"❌ خطا در ثبت پیش‌فاکتور حسابفا: {error_message}\")\n                \n                # ثبت خطا در تاریخچه\n                error_entry = {\n                    \"status\": \"hesabfa_error\",\n                    \"timestamp\": datetime.now().isoformat(),\n                    \"admin\": \"سیستم\",\n                    \"note\": f\"خطا در ثبت پیش‌فاکتور حسابفا: {error_message}\"\n                }\n                current_order[\"status_history\"].append(error_entry)\n                await self._save_order(current_order)\n                \n        except Exception as hesabfa_exception:\n            logger.error(f\"❌ خطای غیرمنتظره در ثبت حسابفا: {hesabfa_exception}\")\n            \n            # بارگیری مجدد و ثبت خطا\n            try:\n                current_order = await self._load_order(order_id)\n                if current_order:\n                    error_entry = {\n                        \"status\": \"hesabfa_error\",\n                        \"timestamp\": datetime.now().isoformat(),\n                        \"admin\": \"سیستم\",\n                        \"note\": f\"خطای سیستمی در ثبت پیش‌فاکتور: {str(hesabfa_exception)[:100]}\"\n                    }\n                    current_order[\"status_history\"].append(error_entry)\n                    await self._save_order(current_order)\n            except Exception as save_error:\n                logger.error(f\"❌ خطا در ذخیره خطای حسابفا: {save_error}\")\n\n    async def _notify_customer_async(self, user_id: int, status: str, order_id: str, admin_name: str = \"\"):\n        \"\"\"اطلاع‌رسانی غیرهمزمان به مشتری\"\"\"\n        try:\n            await self._notify_customer(user_id, status, order_id, admin_name)\n        except Exception as e:\n            logger.error(f\"❌ خطا در اطلاع‌رسانی غیرهمزمان: {e}\")\n\n    async def _notify_customer(self, user_id: int, status: str, order_id: str, admin_name: str = \"\"):\n        \"\"\"اطلاع‌رسانی به مشتری\"\"\"\n        if not self.bot:\n            logger.warning(\"Bot instance تنظیم نشده است\")\n            return\n\n        try:\n            logger.info(f\"🔔 شروع اطلاع‌رسانی به مشتری {user_id} برای سفارش {order_id}\")\n            \n            # بررسی لغو سفارش برای پیام خاص\n            if status == OrderStatus.CANCELLED:\n                # دریافت اطلاعات مشتری\n                order_data = await self._load_order(order_id)\n                customer_name = \"مشتری گرامی\"\n\n                if order_data and order_data.get('customer'):\n                    customer_name = order_data['customer'].get('name', 'مشتری گرامی')\n\n                full_message = (\n                    f\"📋 سفارش شماره: {order_id}\\n\\n\"\n                    f\"از انتخاب شما برای خرید از شرکت دکوتین ممنونیم {customer_name} عزیز\\n\\n\"\n                    f\"سقف اعتبار خرید شما به علت مانده حساب مسدود شده است\\n\\n\"\n                    f\"لطفا مانده حساب خود را واریز نمایید و با ارسال فیش ادامه خرید خود را انجام دهید\\n\\n\"\n                    f\"با تشکر\\n\"\n                    f\"مجموعه دکوتین 🌟\"\n                )\n            else:\n                message = self.status_messages.get(status, f\"وضعیت سفارش شما به {status} تغییر کرد.\")\n\n                # افزودن شماره سفارش\n                full_message = (\n                    f\"📋 سفارش شماره: {order_id}\\n\"\n                    f\"{message}\\n\"\n                )\n\n                if admin_name and status != OrderStatus.PENDING:\n                    full_message += f\"\\n👤 توسط: {admin_name}\"\n\n            # دکمه‌های کمکی برای ارتباط با پشتیبانی\n            keyboard = self._create_customer_support_buttons(order_id)\n\n            # ارسال پیام با retry\n            max_retries = 3\n            for attempt in range(max_retries):\n                try:\n                    await self.bot.send_message(\n                        chat_id=user_id,\n                        text=full_message,\n                        reply_markup=InlineKeyboardMarkup(keyboard)\n                    )\n                    logger.info(f\"✅ اطلاع‌رسانی وضعیت {status} به مشتری {user_id} ارسال شد\")\n                    return\n                except Exception as send_error:\n                    logger.warning(f\"⚠️ تلاش {attempt + 1} ناموفق: {send_error}\")\n                    if attempt == max_retries - 1:\n                        # آخرین تلاش با پیام ساده\n                        simple_message = f\"📋 سفارش {order_id} به‌روزرسانی شد.\"\n                        await self.bot.send_message(\n                            chat_id=user_id,\n                            text=simple_message\n                        )\n                        logger.info(f\"✅ پیام ساده به مشتری {user_id} ارسال شد\")\n\n        except Exception as e:\n            logger.error(f\"❌ خطا در اطلاع‌رسانی به مشتری {user_id}: {e}\")\n            logger.error(f\"   سفارش: {order_id}, وضعیت: {status}\")\n            logger.error(f\"   خطای کامل: {str(e)}\")\n            \n            # تلاش نهایی برای ارسال پیام بسیار ساده\n            try:\n                await self.bot.send_message(\n                    chat_id=user_id,\n                    text=f\"سفارش {order_id} به‌روزرسانی شد.\"\n                )\n                logger.info(f\"✅ پیام اضطراری به مشتری {user_id} ارسال شد\")\n            except:\n                logger.error(f\"❌ حتی پیام اضطراری نیز ارسال نشد\")\n\n    def _create_customer_support_buttons(self, order_id: str) -> List[List[InlineKeyboardButton]]:\n        \"\"\"Create customer support buttons for order status\"\"\"\n        return [\n            [\n                InlineKeyboardButton(\"📋 وضعیت سفارش\", callback_data=f\"check_order_status_{order_id}\"),\n                InlineKeyboardButton(\"📞 تماس با پشتیبانی\", callback_data=\"contact_support\")\n            ],\n            [\n                InlineKeyboardButton(\"❓ سوالات متداول\", callback_data=\"faq\")\n            ]\n        ]\n\n    def _get_status_text(self, status: str) -> str:\n        \"\"\"متن فارسی وضعیت\"\"\"\n        status_texts = {\n            OrderStatus.PENDING: \"در انتظار\",\n            OrderStatus.CONTACTED: \"در حال پیگیری\",\n            OrderStatus.CONFIRMED: \"تایید شد\",\n            OrderStatus.PREPARING: \"در حال آماده‌سازی\",\n            OrderStatus.READY: \"آماده ارسال\",\n            OrderStatus.SHIPPED: \"ارسال شد\",\n            OrderStatus.DELIVERED: \"تحویل داده شد\",\n            OrderStatus.COMPLETED: \"تکمیل شد\",\n            OrderStatus.CANCELLED: \"لغو شد\"\n        }\n        return status_texts.get(status, status)\n\n    async def get_order_details(self, order_id: str) -> Optional[Dict]:\n        \"\"\"دریافت جزئیات سفارش\"\"\"\n        return await self._load_order(order_id)\n\n    async def get_customer_orders(self, user_id: int) -> List[Dict]:\n        \"\"\"دریافت تمام سفارشات یک مشتری\"\"\"\n        orders = []\n\n        try:\n            for filename in os.listdir(self.orders_dir):\n                if filename.startswith(f\"order_{user_id}_\") and filename.endswith(\".json\"):\n                    order_id = filename.replace(\"order_\", \"\").replace(\".json\", \"\")\n                    order_data = await self._load_order(order_id)\n                    if order_data:\n                        orders.append(order_data)\n\n            # مرتب‌سازی بر اساس تاریخ ایجاد (جدیدترین اول)\n            orders.sort(key=lambda x: x[\"created_at\"], reverse=True)\n            return orders\n\n        except Exception as e:\n            logger.error(f\"خطا در دریافت سفارشات مشتری {user_id}: {e}\")\n            return []\n\n    async def get_all_orders(self, status_filter: str = None) -> List[Dict]:\n        \"\"\"دریافت تمام سفارشات (برای ادمین)\"\"\"\n        orders = []\n\n        try:\n            for filename in os.listdir(self.orders_dir):\n                if filename.startswith(\"order_\") and filename.endswith(\".json\"):\n                    order_id = filename.replace(\"order_\", \"\").replace(\".json\", \"\")\n                    order_data = await self._load_order(order_id)\n                    if order_data:\n                        if status_filter is None or order_data[\"status\"] == status_filter:\n                            orders.append(order_data)\n\n            # مرتب‌سازی بر اساس تاریخ ایجاد (جدیدترین اول)\n            orders.sort(key=lambda x: x[\"created_at\"], reverse=True)\n            return orders\n\n        except Exception as e:\n            logger.error(f\"خطا در دریافت تمام سفارشات: {e}\")\n            return []\n\n    async def send_support_contact_info(self, user_id: int):\n        \"\"\"ارسال اطلاعات تماس پشتیبانی\"\"\"\n        if not self.bot:\n            return\n\n        try:\n            contact_message = (\n                \"📞 اطلاعات تماس پشتیبانی\\n\\n\"\n                \"🕐 ساعات کاری: شنبه تا پنج‌شنبه - ۹ صبح تا ۶ عصر\\n\"\n                \"📞 تلفن: ۰۲۱-۱۲۳۴۵۶۷۸\\n\"\n                \"📱 واتساپ: ۰۹۱۲۳۴۵۶۷۸۹\\n\"\n                \"✉️ ایمیل: support@example.com\\n\\n\"\n                \"⚡ پاسخگویی سریع در ساعات کاری\"\n            )\n\n            keyboard = [[\n                InlineKeyboardButton(\"🏠 منوی اصلی\", callback_data=\"main_menu\")\n            ]]\n\n            await self.bot.send_message(\n                chat_id=user_id,\n                text=contact_message,\n                reply_markup=InlineKeyboardMarkup(keyboard)\n            )\n\n        except Exception as e:\n            logger.error(f\"خطا در ارسال اطلاعات تماس: {e}\")\n\n    async def send_faq(self, user_id: int):\n        \"\"\"ارسال سوالات متداول\"\"\"\n        if not self.bot:\n            return\n\n        try:\n            faq_message = (\n                \"❓ سوالات متداول\\n\\n\"\n                \"🔸 چقدر طول می‌کشد تا سفارش آماده شود؟\\n\"\n                \"معمولاً ۳ تا ۵ روز کاری\\n\\n\"\n                \"🔸 هزینه ارسال چقدر است؟\\n\"\n                \"برای سفارشات بالای ۵ میلیون تومان رایگان\\n\\n\"\n                \"🔸 آیا امکان تغییر یا لغو سفارش وجود دارد؟\\n\"\n                \"تا قبل از آماده‌سازی امکان‌پذیر است\\n\\n\"\n                \"🔸 چگونه می‌توانم وضعیت سفارش را پیگیری کنم؟\\n\"\n                \"از طریق همین ربات یا تماس با پشتیبانی\"\n            )\n\n            keyboard = [\n                [InlineKeyboardButton(\"📞 تماس با پشتیبانی\", callback_data=\"contact_support\")],\n                [InlineKeyboardButton(\"🏠 منوی اصلی\", callback_data=\"main_menu\")]\n            ]\n\n            await self.bot.send_message(\n                chat_id=user_id,\n                text=faq_message,\n                reply_markup=InlineKeyboardMarkup(keyboard)\n            )\n\n        except Exception as e:\n            logger.error(f\"خطا در ارسال سوالات متداول: {e}\")\n\n    async def get_todays_orders(self) -> List[Dict]:\n        \"\"\"دریافت سفارشات امروز\"\"\"\n        today_orders = []\n        today_date = datetime.now().strftime(\"%Y-%m-%d\")\n\n        try:\n            for filename in os.listdir(self.orders_dir):\n                if filename.startswith(\"order_\") and filename.endswith(\".json\"):\n                    order_id = filename.replace(\"order_\", \"\").replace(\".json\", \"\")\n                    order_data = await self._load_order(order_id)\n\n                    if order_data:\n                        # بررسی تاریخ ایجاد سفارش\n                        order_date = order_data.get('created_at', '')[:10]\n                        if order_date == today_date:\n                            today_orders.append(order_data)\n\n            # مرتب‌سازی بر اساس زمان ایجاد (جدیدترین اول)\n            today_orders.sort(key=lambda x: x.get('created_at', ''), reverse=True)\n            return today_orders\n\n        except Exception as e:\n            logger.error(f\"خطا در دریافت سفارشات امروز: {e}\")\n            return []\n\n    async def get_orders_by_date(self, target_date: str) -> List[Dict]:\n        \"\"\"دریافت سفارشات بر اساس تاریخ (فرمت: YYYY-MM-DD)\"\"\"\n        date_orders = []\n\n        try:\n            for filename in os.listdir(self.orders_dir):\n                if filename.startswith(\"order_\") and filename.endswith(\".json\"):\n                    order_id = filename.replace(\"order_\", \"\").replace(\".json\", \"\")\n                    order_data = await self._load_order(order_id)\n\n                    if order_data:\n                        order_date = order_data.get('created_at', '')[:10]\n                        if order_date == target_date:\n                            date_orders.append(order_data)\n\n            # مرتب‌سازی بر اساس زمان ایجاد\n            date_orders.sort(key=lambda x: x.get('created_at', ''))\n            return date_orders\n\n        except Exception as e:\n            logger.error(f\"خطا در دریافت سفارشات تاریخ {target_date}: {e}\")\n            return []\n\n    async def get_orders_statistics(self) -> Dict:\n        \"\"\"دریافت آمار کلی سفارشات\"\"\"\n        try:\n            all_orders = await self.get_all_orders()\n            today_orders = await self.get_todays_orders()\n\n            # آمار کلی\n            total_orders = len(all_orders)\n            today_count = len(today_orders)\n\n            # آمار وضعیت\n            status_stats = {}\n            total_revenue = 0\n            today_revenue = 0\n\n            for order in all_orders:\n                status = order.get('status', 'pending')\n                status_text = self._get_status_text(status)\n                status_stats[status_text] = status_stats.get(status_text, 0) + 1\n                total_revenue += order.get('pricing', {}).get('total', 0)\n\n            for order in today_orders:\n                today_revenue += order.get('pricing', {}).get('total', 0)\n\n            return {\n                'total_orders': total_orders,\n                'today_orders': today_count,\n                'total_revenue': total_revenue,\n                'today_revenue': today_revenue,\n                'status_distribution': status_stats\n            }\n\n        except Exception as e:\n            logger.error(f\"خطا در محاسبه آمار: {e}\")\n            return {}","size_bytes":35248},"payment_data/bot/payment_reminder.py":{"content":"\n#!/usr/bin/env python3\n\"\"\"\nPayment Reminder System\nAutomated system to send monthly payment reminders for 90-day payment plans.\n\"\"\"\n\nimport asyncio\nfrom datetime import datetime\nfrom telegram import Bot, InlineKeyboardButton, InlineKeyboardMarkup\nfrom bot.payment_scheduler import PaymentScheduler\nfrom bot.config import Config\nfrom utils.logger import setup_logger\n\nlogger = setup_logger(__name__)\n\nclass PaymentReminderBot:\n    \"\"\"Automated payment reminder system\"\"\"\n    \n    def __init__(self, config: Config):\n        self.config = config\n        self.bot = Bot(token=config.bot_token)\n        self.payment_scheduler = PaymentScheduler()\n    \n    async def send_daily_reminders(self):\n        \"\"\"Check and send daily payment reminders\"\"\"\n        try:\n            pending_reminders = self.payment_scheduler.get_pending_reminders()\n            \n            if not pending_reminders:\n                logger.info(\"No payment reminders due today\")\n                return\n            \n            logger.info(f\"Found {len(pending_reminders)} payment reminders to send\")\n            \n            for reminder in pending_reminders:\n                await self._send_reminder_to_group(reminder)\n                \n        except Exception as e:\n            logger.error(f\"Error sending daily reminders: {e}\")\n    \n    async def _send_reminder_to_group(self, reminder_info):\n        \"\"\"Send payment reminder to order group\"\"\"\n        try:\n            message = self.payment_scheduler.generate_reminder_message(reminder_info)\n            \n            # Create keyboard for payment confirmation\n            keyboard = [\n                [\n                    InlineKeyboardButton(\n                        \"✅ پرداخت انجام شد\",\n                        callback_data=f\"payment_confirmed_{reminder_info['schedule_id']}_{reminder_info['payment_number']}\"\n                    )\n                ],\n                [\n                    InlineKeyboardButton(\n                        \"📞 تماس گرفته شد\",\n                        callback_data=f\"contact_made_{reminder_info['schedule_id']}_{reminder_info['payment_number']}\"\n                    )\n                ],\n                [\n                    InlineKeyboardButton(\n                        \"⏰ یادآوری فردا\",\n                        callback_data=f\"remind_tomorrow_{reminder_info['schedule_id']}_{reminder_info['payment_number']}\"\n                    )\n                ]\n            ]\n            \n            await self.bot.send_message(\n                chat_id=self.config.order_group_chat_id,\n                text=message,\n                reply_markup=InlineKeyboardMarkup(keyboard)\n            )\n            \n            logger.info(f\"Sent payment reminder for user {reminder_info['user_id']}\")\n            \n        except Exception as e:\n            logger.error(f\"Error sending reminder to group: {e}\")\n    \n    async def handle_payment_confirmation(self, schedule_id: str, payment_number: int):\n        \"\"\"Handle payment confirmation from group admin\"\"\"\n        try:\n            success = self.payment_scheduler.mark_payment_made(schedule_id, payment_number)\n            \n            if success:\n                logger.info(f\"Payment {payment_number} confirmed for schedule {schedule_id}\")\n                return \"✅ پرداخت با موفقیت ثبت شد!\"\n            else:\n                logger.error(f\"Failed to confirm payment {payment_number} for schedule {schedule_id}\")\n                return \"❌ خطا در ثبت پرداخت\"\n                \n        except Exception as e:\n            logger.error(f\"Error handling payment confirmation: {e}\")\n            return \"❌ خطا در ثبت پرداخت\"\n\nasync def run_daily_reminder_check():\n    \"\"\"Function to run daily reminder check\"\"\"\n    config = Config()\n    reminder_bot = PaymentReminderBot(config)\n    await reminder_bot.send_daily_reminders()\n\nif __name__ == \"__main__\":\n    # Run daily reminder check\n    asyncio.run(run_daily_reminder_check())\n","size_bytes":4009},"payment_data/bot/payment_scheduler.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nPayment Scheduler for 90-day Payment Plans\nManages monthly reminders for remaining payments.\n\"\"\"\n\nimport json\nimport os\nfrom datetime import datetime, timedelta\nfrom typing import Dict, List, Any, Optional\nfrom utils.logger import setup_logger\nfrom utils.persian_utils import format_price, persian_numbers\n\nlogger = setup_logger(__name__)\n\nclass PaymentScheduler:\n    \"\"\"Manages payment schedules and monthly reminders\"\"\"\n\n    def __init__(self, data_dir: str = \"payment_data\"):\n        self.data_dir = data_dir\n        os.makedirs(self.data_dir, exist_ok=True)\n        self.payment_file = os.path.join(self.data_dir, \"payment_schedules.json\")\n\n    def _load_payment_schedules(self) -> Dict[str, Any]:\n        \"\"\"Load payment schedules from file\"\"\"\n        try:\n            if os.path.exists(self.payment_file):\n                with open(self.payment_file, 'r', encoding='utf-8') as f:\n                    return json.load(f)\n            return {}\n        except Exception as e:\n            logger.error(f\"Error loading payment schedules: {e}\")\n            return {}\n\n    def _save_payment_schedules(self, schedules: Dict[str, Any]) -> bool:\n        \"\"\"Save payment schedules to file\"\"\"\n        try:\n            with open(self.payment_file, 'w', encoding='utf-8') as f:\n                json.dump(schedules, f, ensure_ascii=False, indent=2, default=str)\n            return True\n        except Exception as e:\n            logger.error(f\"Error saving payment schedules: {e}\")\n            return False\n\n    def add_60day_payment_schedule(self, user_id: int, customer_info: Dict[str, Any], \n                                 total_amount: float, advance_paid: float, \n                                 remaining_amount: float, order_id: str) -> bool:\n        \"\"\"Add a new 60-day payment schedule\"\"\"\n        schedules = self._load_payment_schedules()\n\n        # Calculate payment date (60 days from now)\n        today = datetime.now()\n        payment_date = (today + timedelta(days=60)).strftime(\"%Y-%m-%d\")\n\n        schedule_id = f\"{user_id}_{order_id}_{int(today.timestamp())}\"\n\n        payment_schedule = {\n            'user_id': user_id,\n            'customer_info': customer_info,\n            'order_id': order_id,\n            'total_amount': total_amount,\n            'advance_paid': advance_paid,\n            'remaining_amount': remaining_amount,\n            'payment_date': payment_date,\n            'payment_type': '60day',\n            'payments_made': [],\n            'created_date': today.strftime(\"%Y-%m-%d\"),\n            'status': 'active'\n        }\n\n        schedules[schedule_id] = payment_schedule\n\n        if self._save_payment_schedules(schedules):\n            logger.info(f\"Added 60-day payment schedule for user {user_id}, order {order_id}\")\n            return True\n        return False\n\n    def add_90day_payment_schedule(self, user_id: int, customer_info: Dict[str, Any], \n                                 total_amount: float, advance_paid: float, \n                                 remaining_amount: float, order_id: str) -> bool:\n        \"\"\"Add a new 90-day payment schedule\"\"\"\n        schedules = self._load_payment_schedules()\n\n        # Calculate monthly payments (remaining amount / 3 months)\n        monthly_amount = remaining_amount / 3\n\n        # Calculate payment dates\n        today = datetime.now()\n        payment_dates = [\n            (today + timedelta(days=30)).strftime(\"%Y-%m-%d\"),\n            (today + timedelta(days=60)).strftime(\"%Y-%m-%d\"),\n            (today + timedelta(days=90)).strftime(\"%Y-%m-%d\")\n        ]\n\n        schedule_id = f\"{user_id}_{order_id}_{int(today.timestamp())}\"\n\n        payment_schedule = {\n            'user_id': user_id,\n            'customer_info': customer_info,\n            'order_id': order_id,\n            'total_amount': total_amount,\n            'advance_paid': advance_paid,\n            'remaining_amount': remaining_amount,\n            'monthly_amount': monthly_amount,\n            'payment_dates': payment_dates,\n            'payments_made': [],\n            'created_date': today.strftime(\"%Y-%m-%d\"),\n            'status': 'active'\n        }\n\n        schedules[schedule_id] = payment_schedule\n\n        if self._save_payment_schedules(schedules):\n            logger.info(f\"Added 90-day payment schedule for user {user_id}, order {order_id}\")\n            return True\n        return False\n\n    def get_pending_reminders(self) -> List[Dict[str, Any]]:\n        \"\"\"Get list of users who need payment reminders today\"\"\"\n        schedules = self._load_payment_schedules()\n        today = datetime.now().strftime(\"%Y-%m-%d\")\n        pending_reminders = []\n\n        for schedule_id, schedule in schedules.items():\n            if schedule['status'] != 'active':\n                continue\n\n            payment_type = schedule.get('payment_type', '90day')\n            \n            if payment_type == '60day':\n                # For 60-day payments: single payment date\n                payment_date = schedule['payment_date']\n                if payment_date == today and not schedule['payments_made']:\n                    reminder_info = {\n                        'schedule_id': schedule_id,\n                        'user_id': schedule['user_id'],\n                        'customer_info': schedule['customer_info'],\n                        'payment_number': 1,\n                        'payment_amount': schedule['remaining_amount'],\n                        'payment_type': '60day',\n                        'payment_date': payment_date\n                    }\n                    pending_reminders.append(reminder_info)\n            else:\n                # For 90-day payments: multiple payment dates\n                for i, payment_date in enumerate(schedule['payment_dates']):\n                    if payment_date == today:\n                        # Check if this payment hasn't been made yet\n                        if i not in schedule['payments_made']:\n                            reminder_info = {\n                                'schedule_id': schedule_id,\n                                'user_id': schedule['user_id'],\n                                'customer_info': schedule['customer_info'],\n                                'payment_number': i + 1,\n                                'monthly_amount': schedule['monthly_amount'],\n                                'remaining_payments': 3 - len(schedule['payments_made']),\n                                'payment_type': '90day',\n                                'payment_date': payment_date\n                            }\n                            pending_reminders.append(reminder_info)\n\n        return pending_reminders\n\n    def mark_payment_made(self, schedule_id: str, payment_number: int) -> bool:\n        \"\"\"Mark a payment as completed\"\"\"\n        schedules = self._load_payment_schedules()\n\n        if schedule_id not in schedules:\n            logger.error(f\"Schedule {schedule_id} not found\")\n            return False\n\n        schedule = schedules[schedule_id]\n        payment_type = schedule.get('payment_type', '90day')\n\n        if payment_type == '60day':\n            # For 60-day payments: mark as completed immediately\n            schedule['payments_made'] = [0]  # Single payment made\n            schedule['status'] = 'completed'\n        else:\n            # For 90-day payments: add payment to made payments list\n            if payment_number - 1 not in schedule['payments_made']:\n                schedule['payments_made'].append(payment_number - 1)\n                schedule['payments_made'].sort()\n\n            # Check if all payments are completed\n            if len(schedule['payments_made']) >= 3:\n                schedule['status'] = 'completed'\n\n        if self._save_payment_schedules(schedules):\n            logger.info(f\"Marked payment {payment_number} as completed for schedule {schedule_id}\")\n            return True\n        return False\n\n    def get_user_payment_schedules(self, user_id: int) -> List[Dict[str, Any]]:\n        \"\"\"Get all payment schedules for a specific user\"\"\"\n        schedules = self._load_payment_schedules()\n        user_schedules = []\n\n        for schedule_id, schedule in schedules.items():\n            if schedule['user_id'] == user_id:\n                user_schedules.append({\n                    'schedule_id': schedule_id,\n                    **schedule\n                })\n\n        return user_schedules\n\n    def generate_reminder_message(self, reminder_info: Dict[str, Any]) -> str:\n        \"\"\"Generate reminder message for payment\"\"\"\n        customer = reminder_info['customer_info']\n        payment_type = reminder_info.get('payment_type', '90day')\n        \n        if payment_type == '60day':\n            amount = reminder_info['payment_amount']\n            message = [\n                \"🔔 یادآوری پرداخت 60 روزه\",\n                \"=\" * 30,\n                \"\",\n                f\"👤 مشتری: {customer['name']}\",\n                f\"🏙️ شهر: {customer['city']}\",\n                f\"🆔 کد مشتری: {customer['customer_id']}\",\n                \"\",\n                f\"💰 مبلغ باقی‌مانده: {format_price(amount)} تومان\",\n                f\"📅 سررسید پرداخت: امروز\",\n                \"\",\n                \"📞 لطفاً با مشتری تماس بگیرید تا پرداخت کامل را انجام دهد.\",\n                \"\",\n                \"برای ثبت پرداخت از دکمه‌های زیر استفاده کنید:\"\n            ]\n        else:\n            payment_num = reminder_info['payment_number']\n            amount = reminder_info['monthly_amount']\n            remaining = reminder_info['remaining_payments']\n            \n            message = [\n                \"🔔 یادآوری پرداخت قسط ماهانه\",\n                \"=\" * 30,\n                \"\",\n                f\"👤 مشتری: {customer['name']}\",\n                f\"🏙️ شهر: {customer['city']}\",\n                f\"🆔 کد مشتری: {customer['customer_id']}\",\n                \"\",\n                f\"📅 قسط شماره: {persian_numbers(str(payment_num))} از ۳\",\n                f\"💰 مبلغ قسط: {format_price(amount)} تومان\",\n                f\"📊 اقساط باقی‌مانده: {persian_numbers(str(remaining - 1))}\",\n                \"\",\n                \"📞 لطفاً با مشتری تماس بگیرید تا پرداخت را انجام دهد.\",\n                \"\",\n                \"برای ثبت پرداخت از دکمه‌های زیر استفاده کنید:\"\n            ]\n\n        return \"\\n\".join(message)\n\n    def cancel_payment_schedule(self, schedule_id: str) -> bool:\n        \"\"\"Cancel a payment schedule\"\"\"\n        schedules = self._load_payment_schedules()\n\n        if schedule_id not in schedules:\n            logger.error(f\"Schedule {schedule_id} not found\")\n            return False\n\n        schedules[schedule_id]['status'] = 'cancelled'\n\n        if self._save_payment_schedules(schedules):\n            logger.info(f\"Cancelled payment schedule {schedule_id}\")\n            return True\n        return False\n\n    def schedule_payment_reminder(self, user_id: int, customer_name: str, amount: int, due_days: int, order_data: Dict):\n        \"\"\"Schedule a payment reminder\"\"\"\n        try:\n            # Load existing schedules\n            schedules = self._load_payment_schedules()\n\n            # Calculate due date\n            due_date = (datetime.now() + timedelta(days=due_days)).isoformat()\n\n            # Create schedule entry\n            schedule_id = f\"{user_id}_{int(datetime.now().timestamp())}\"\n            schedules[schedule_id] = {\n                'user_id': user_id,\n                'customer_name': customer_name,\n                'amount': amount,\n                'due_date': due_date,\n                'due_days': due_days,\n                'status': 'pending',\n                'created_at': datetime.now().isoformat(),\n                'order_data': order_data\n            }\n\n            # Save schedules\n            if self._save_payment_schedules(schedules):\n                logger.info(f\"Payment reminder scheduled for user {user_id}, due in {due_days} days\")\n                return schedule_id\n            else:\n                return None\n\n\n        except Exception as e:\n            logger.error(f\"Error scheduling payment reminder: {e}\")\n            return None","size_bytes":12386},"payment_data/bot/pricing.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nPricing and Invoice Management\nHandles price calculations and invoice generation.\n\"\"\"\n\nfrom typing import List, Dict, Any\nfrom utils.persian_utils import format_price, persian_numbers\nfrom datetime import datetime\n\n\nclass PricingManager:\n    \"\"\"Manages pricing and invoice generation\"\"\"\n\n    def __init__(self):\n        # نرخ‌های تخفیف به‌روزرسانی شده\n        self.discount_rates = {\n            'cash': 0.30,  # تخفیف ۳۰٪ نقدی\n            'installment': 0.25,  # تخفیف ۲۵٪ اقساطی\n            '60day': 0.25,  # تخفیف ۲۵٪ برای ۶۰ روزه\n            '90day': 0.25  # تخفیف ۲۵٪ برای ۹۰ روزه\n        }\n\n        # اطلاعات حساب بانکی\n        self.bank_info = {\n            'card_number': '6219861915854102',\n            'sheba_number': '110560611828005185959401',\n            'account_holder': 'نیما کریمی'\n        }\n\n    def calculate_subtotal(self, cart_items: List[Dict[str, Any]]) -> float:\n        \"\"\"Calculate subtotal from cart items\"\"\"\n        return sum(item['price'] * item['quantity'] for item in cart_items)\n\n    def calculate_discount(self, subtotal: int, discount_rate: float) -> int:\n        \"\"\"محاسبه تخفیف\"\"\"\n        return int(subtotal * discount_rate)\n\n    def calculate_tax(self, amount: int) -> int:\n        \"\"\"محاسبه مالیات (۹٪)\"\"\"\n        return int(amount * 0.09)\n\n    def calculate_total(self, subtotal: float, discount: float = 0) -> float:\n        \"\"\"Calculate final total\"\"\"\n        return subtotal - discount\n\n    def generate_invoice(self, cart_items: List[Dict[str, Any]],\n                         customer: Dict[str, Any]) -> str:\n        \"\"\"Generate invoice with all payment options displayed\"\"\"\n        if not cart_items:\n            return \"❌ سبد خرید خالی است.\"\n\n        # Calculate amounts\n        subtotal = self.calculate_subtotal(cart_items)\n\n        # Calculate discounts for each option\n        cash_discount = self.calculate_discount(subtotal, 0.30)\n        installment_discount = self.calculate_discount(subtotal, 0.25)\n\n        cash_total = subtotal - cash_discount\n        installment_total = subtotal - installment_discount\n        advance_payment_90 = installment_total * 0.25\n\n        # Generate invoice text\n        invoice_lines = [\n            \"📋 پیش‌فاکتور سفارش\", \"=\" * 30, \"\", f\"👤 مشتری: {customer['name']}\",\n            f\"🏙️ شهر: {customer['city']}\",\n            f\"🆔 کد مشتری: {customer['customer_id']}\",\n            f\"📅 تاریخ: {self._get_persian_date()}\", \"\", \"📦 اقلام سفارش:\",\n            \"-\" * 20\n        ]\n\n        # Add cart items\n        for i, item in enumerate(cart_items, 1):\n            item_total = item['price'] * item['quantity']\n            invoice_lines.extend([\n                f\"{persian_numbers(str(i))}. {item['product_name']}\",\n                f\"   📏 سایز: {item['size']}\",\n                f\"   📦 تعداد: {persian_numbers(str(item['quantity']))}\",\n                f\"   💰 قیمت واحد: {format_price(item['price'])} تومان\",\n                f\"   💰 قیمت کل: {format_price(item_total)} تومان\", \"\"\n            ])\n\n        # Add total amount\n        invoice_lines.extend([\n            \"-\" * 20, f\"💰 مبلغ کل: {format_price(subtotal)} تومان\",\n            \"\",\n            \"💳 برای انتخاب روش پرداخت، یکی از گزینه‌های زیر را انتخاب کنید:\"\n        ])\n\n        return \"\\n\".join(invoice_lines)\n\n    def generate_final_invoice(self, cart_items: List[Dict[str, Any]],\n                               customer: Dict[str, Any], payment_method: str,\n                               discount_rate: float) -> str:\n        \"\"\"Generate final invoice with payment method and discounts\"\"\"\n        if not cart_items:\n            return \"❌ سبد خرید خالی است.\"\n\n        # Calculate amounts\n        subtotal = self.calculate_subtotal(cart_items)\n        discount = self.calculate_discount(subtotal, discount_rate)\n        total = subtotal - discount\n\n        # Generate invoice text\n        invoice_lines = [\n            \"📋 فاکتور نهایی\", \"=\" * 30, \"\", f\"👤 مشتری: {customer['name']}\",\n            f\"🏙️ شهر: {customer['city']}\",\n            f\"🆔 کد مشتری: {customer['customer_id']}\",\n            f\"📅 تاریخ: {self._get_persian_date()}\",\n            f\"💳 روش پرداخت: {payment_method}\", \"\", \"📦 اقلام سفارش:\", \"-\" * 20\n        ]\n\n        # Add cart items\n        for i, item in enumerate(cart_items, 1):\n            item_total = item['price'] * item['quantity']\n            invoice_lines.extend([\n                f\"{persian_numbers(str(i))}. {item['product_name']}\",\n                f\"   📏 سایز: {item['size']}\",\n                f\"   📦 تعداد: {persian_numbers(str(item['quantity']))}\",\n                f\"   💰 قیمت واحد: {format_price(item['price'])} تومان\",\n                f\"   💰 قیمت کل: {format_price(item_total)} تومان\", \"\"\n            ])\n\n        # Add calculations\n        invoice_lines.extend([\n            \"-\" * 20, f\"💰 مجموع: {format_price(subtotal)} تومان\",\n            f\"🎁 تخفیف ({persian_numbers(str(int(discount_rate * 100)))}٪): {format_price(discount)} تومان\",\n            f\"💰 مبلغ قابل پرداخت: {format_price(total)} تومان\"\n        ])\n\n        # Add special details for installment payment\n        if payment_method == \"پرداخت اقساطی\":\n            invoice_lines.extend([\n                \"\", \"💳 جزئیات پرداخت اقساطی:\",\n                f\"🎁 تخفیف ویژه: {persian_numbers(str(int(discount_rate * 100)))}٪\",\n                \"📞 جزئیات اقساط با تماس کارشناس اعلام خواهد شد\"\n            ])\n\n        invoice_lines.extend(\n            [\"\", \"✅ سفارش شما ثبت شد و به زودی با شما تماس خواهیم گرفت.\"])\n\n        return \"\\n\".join(invoice_lines)\n\n    def generate_invoice_text(self, order_data: Dict) -> str:\n        \"\"\"تولید متن پیش‌فاکتور\"\"\"\n        customer = order_data[\"customer\"]\n        cart_items = order_data[\"items\"]\n\n        subtotal = sum(item['price'] * item['quantity'] for item in cart_items)\n        discount_rate = 0.25\n        discount = subtotal * discount_rate\n        total = subtotal - discount\n        advance_payment = total * 0.25\n\n        invoice_text = (\n            f\"🆕 سفارش جدید - شماره: {order_data['order_id']}\\n\"\n            f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n            f\"👤 نام مشتری: {customer['name']}\\n\"\n            f\"🏙️ شهر: {customer['city']}\\n\"\n            f\"💰 قیمت کل: {format_price(subtotal)} تومان\\n\"\n            f\"🎁 تخفیف (25٪): {format_price(discount)} تومان\\n\"\n            f\"💰 مبلغ قابل پرداخت: {format_price(total)} تومان\\n\"\n            f\"💳 پیش‌پرداخت (25٪): {format_price(advance_payment)} تومان\\n\"\n            f\"📅 تاریخ: ۱۴۰۴/۰۵/۱۴\\n\"\n            f\"📋 جزئیات سفارش:\\n\"\n            f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\")\n        for i, item in enumerate(cart_items, 1):\n            item_total = item['price'] * item['quantity']\n            invoice_text += (\n                f\"{persian_numbers(str(i))}. {item['product_name']}\\n\"\n                f\"   📏 سایز: {item['size']}\\n\"\n                f\"   📦 تعداد: {persian_numbers(str(item['quantity']))}\\n\"\n                f\"   💰 قیمت: {format_price(item_total)} تومان\\n\\n\")\n        return invoice_text\n\n    def generate_cash_payment_invoice(self, order_data: Dict) -> str:\n        \"\"\"تولید فاکتور پرداخت نقدی با تخفیف 30%\"\"\"\n        customer = order_data[\"customer\"]\n        cart_items = order_data[\"items\"]\n\n        subtotal = sum(item['price'] * item['quantity'] for item in cart_items)\n        discount_rate = 0.30  # 30% discount for cash payment\n        discount = subtotal * discount_rate\n        total = subtotal - discount\n\n        invoice_text = (f\"💳 پرداخت نقدی (30% تخفیف)\\n\"\n                        f\"شماره سفارش: {order_data['order_id']}\\n\"\n                        f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n                        f\"👤 نام مشتری: {customer['name']}\\n\"\n                        f\"🏙️ شهر: {customer['city']}\\n\"\n                        f\"📅 تاریخ: {self._get_persian_date()}\\n\\n\"\n                        f\"📋 جزئیات سفارش:\\n\"\n                        f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\")\n\n        # Add cart items\n        for i, item in enumerate(cart_items, 1):\n            item_total = item['price'] * item['quantity']\n            invoice_text += (\n                f\"{persian_numbers(str(i))}. {item['product_name']}\\n\"\n                f\"   📏 سایز: {item['size']}\\n\"\n                f\"   📦 تعداد: {persian_numbers(str(item['quantity']))}\\n\"\n                f\"   💰 قیمت: {format_price(item_total)} تومان\\n\\n\")\n\n        # Add totals\n        invoice_text += (\n            f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n            f\"💰 مبلغ کل: {format_price(subtotal)} تومان\\n\"\n            f\"🎁 مبلغ تخفیف ({persian_numbers('30')}٪): {format_price(discount)} تومان\\n\\n\"\n            f\"💳 اطلاعات پرداخت:\\n\"\n            f\"🏪 نام صاحب حساب: {self.bank_info['account_holder']}\\n\"\n            f\"💳 شماره کارت: {self.bank_info['card_number']}\\n\"\n            f\"🏦 شماره شبا: IR{self.bank_info['sheba_number']}\\n\\n\"\n            f\"✅ پس از واریز، لطفاً فیش واریزی را ارسال کنید.\")\n\n        return invoice_text\n\n    def generate_installment_payment_invoice(self, order_data: Dict) -> str:\n        \"\"\"تولید فاکتور پرداخت اقساطی با تخفیف 25%\"\"\"\n        customer = order_data[\"customer\"]\n        cart_items = order_data[\"items\"]\n\n        subtotal = sum(item['price'] * item['quantity'] for item in cart_items)\n        discount_rate = 0.25  # 25% discount for installment payment\n        discount = subtotal * discount_rate\n        total = subtotal - discount\n\n        invoice_text = (f\"📅 پرداخت اقساطی (25% تخفیف)\\n\"\n                        f\"شماره سفارش: {order_data['order_id']}\\n\"\n                        f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n                        f\"👤 نام مشتری: {customer['name']}\\n\"\n                        f\"🏙️ شهر: {customer['city']}\\n\"\n                        f\"📅 تاریخ: {self._get_persian_date()}\\n\\n\"\n                        f\"📋 جزئیات سفارش:\\n\"\n                        f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\")\n\n        # Add cart items\n        for i, item in enumerate(cart_items, 1):\n            item_total = item['price'] * item['quantity']\n            invoice_text += (\n                f\"{persian_numbers(str(i))}. {item['product_name']}\\n\"\n                f\"   📏 سایز: {item['size']}\\n\"\n                f\"   📦 تعداد: {persian_numbers(str(item['quantity']))}\\n\"\n                f\"   💰 قیمت: {format_price(item_total)} تومان\\n\\n\")\n\n        # Add totals\n        invoice_text += (\n            f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n            f\"💰 مبلغ کل: {format_price(subtotal)} تومان\\n\"\n            f\"🎁 مبلغ تخفیف ({persian_numbers('25')}٪): {format_price(discount)} تومان\\n\"\n            f\"💰 مبلغ نهایی: {format_price(total)} تومان\")\n\n        return invoice_text\n\n    def generate_60day_payment_invoice(self, order_data: Dict) -> str:\n        \"\"\"تولید فاکتور پرداخت 60 روزه با تخفیف 25% + پیش پرداخت 25%\"\"\"\n        customer = order_data[\"customer\"]\n        cart_items = order_data[\"items\"]\n\n        subtotal = sum(item['price'] * item['quantity'] for item in cart_items)\n        discount_rate = 0.25  # 25% discount\n        discount = subtotal * discount_rate\n        total = subtotal - discount\n        advance_payment = total * 0.25  # 25% advance payment from final amount\n\n        invoice_text = (f\"🕐 پرداخت 60 روزه (25% تخفیف)\\n\"\n                        f\"شماره سفارش: {order_data['order_id']}\\n\"\n                        f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n                        f\"👤 نام مشتری: {customer['name']}\\n\"\n                        f\"🏙️ شهر: {customer['city']}\\n\"\n                        f\"📅 تاریخ: {self._get_persian_date()}\\n\\n\"\n                        f\"📋 جزئیات سفارش:\\n\"\n                        f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\")\n\n        # Add cart items\n        for i, item in enumerate(cart_items, 1):\n            item_total = item['price'] * item['quantity']\n            invoice_text += (\n                f\"{persian_numbers(str(i))}. {item['product_name']}\\n\"\n                f\"   📏 سایز: {item['size']}\\n\"\n                f\"   📦 تعداد: {persian_numbers(str(item['quantity']))}\\n\"\n                f\"   💰 قیمت: {format_price(item_total)} تومان\\n\\n\")\n\n        # Add totals and payment terms\n        invoice_text += (\n            f\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n            f\"💰 مبلغ کل: {format_price(subtotal)} تومان\\n\"\n            f\"🎁 مبلغ تخفیف ({persian_numbers('25')}٪): {format_price(discount)} تومان\\n\"\n            f\"💰 مبلغ نهایی: {format_price(total)} تومان\\n\"\n            f\"💳 مبلغ پیش‌پرداخت ({persian_numbers('25')}٪): {format_price(advance_payment)} تومان\\n\\n\"\n            f\"💳 اطلاعات پرداخت پیش‌پرداخت:\\n\"\n            f\"🏪 نام صاحب حساب: {self.bank_info['account_holder']}\\n\"\n            f\"💳 شماره کارت: {self.bank_info['card_number']}\\n\"\n            f\"🏦 شماره شبا: IR{self.bank_info['sheba_number']}\\n\\n\"\n            f\"📅 شرایط پرداخت:\\n\"\n            f\"• پیش‌پرداخت 25٪ از مبلغ نهایی\\n\"\n            f\"• مابقی 60 روز پس از تحویل\\n\"\n            f\"• تخفیف ویژه 25٪ اعمال شده\\n\\n\"\n            f\"✅ پس از واریز پیش‌پرداخت، فیش واریزی را ارسال کنید.\")\n\n        return invoice_text\n\n    def _get_persian_date(self) -> str:\n        \"\"\"Get current date in Persian format\"\"\"\n        # Return current Persian date: 1404/5/14\n        return persian_numbers(\"14 مرداد 1404\")\n","size_bytes":15354},"payment_data/bot/zarinpal.py":{"content":"\n#!/usr/bin/env python3\n\"\"\"\nZarinPal Payment Integration\nHandles payment processing through ZarinPal gateway.\n\"\"\"\n\nimport requests\nimport json\nfrom typing import Dict, Any, Optional\nfrom utils.logger import setup_logger\n\nlogger = setup_logger(__name__)\n\nclass ZarinPalGateway:\n    \"\"\"ZarinPal payment gateway integration\"\"\"\n\n    def __init__(self, merchant_id: str, sandbox: bool = True):\n        self.merchant_id = merchant_id\n        self.sandbox = sandbox\n\n        if sandbox:\n            self.request_url = \"https://sandbox.zarinpal.com/pg/rest/WebGate/PaymentRequest.json\"\n            self.verify_url = \"https://sandbox.zarinpal.com/pg/rest/WebGate/PaymentVerification.json\"\n            self.gateway_url = \"https://sandbox.zarinpal.com/pg/StartPay/\"\n        else:\n            self.request_url = \"https://www.zarinpal.com/pg/rest/WebGate/PaymentRequest.json\"\n            self.verify_url = \"https://www.zarinpal.com/pg/rest/WebGate/PaymentVerification.json\"\n            self.gateway_url = \"https://www.zarinpal.com/pg/StartPay/\"\n\n    def create_payment_request(self, amount: int, description: str, \n                             callback_url: str, customer_email: str = \"\",\n                             customer_mobile: str = \"\") -> Dict[str, Any]:\n        \"\"\"Create payment request\"\"\"\n        try:\n            data = {\n                \"MerchantID\": self.merchant_id,\n                \"Amount\": amount,\n                \"Description\": description,\n                \"CallbackURL\": callback_url,\n                \"Email\": customer_email,\n                \"Mobile\": customer_mobile\n            }\n\n            response = requests.post(self.request_url, json=data, timeout=10)\n            result = response.json()\n\n            if result[\"Status\"] == 100:\n                authority = result[\"Authority\"]\n                payment_url = f\"{self.gateway_url}{authority}\"\n\n                logger.info(f\"Payment request created successfully. Authority: {authority}\")\n                return {\n                    \"success\": True,\n                    \"authority\": authority,\n                    \"payment_url\": payment_url\n                }\n            else:\n                error_msg = self._get_error_message(result[\"Status\"])\n                logger.error(f\"ZarinPal payment request failed: {error_msg}\")\n                return {\n                    \"success\": False,\n                    \"error\": error_msg\n                }\n\n        except requests.exceptions.RequestException as e:\n            logger.error(f\"Request error: {e}\")\n            return {\n                \"success\": False,\n                \"error\": \"خطا در ارتباط با درگاه پرداخت\"\n            }\n        except Exception as e:\n            logger.error(f\"Unexpected error: {e}\")\n            return {\n                \"success\": False,\n                \"error\": \"خطای غیرمنتظره در ایجاد درخواست پرداخت\"\n            }\n\n    def verify_payment(self, authority: str, amount: int) -> Dict[str, Any]:\n        \"\"\"Verify payment\"\"\"\n        try:\n            data = {\n                \"MerchantID\": self.merchant_id,\n                \"Authority\": authority,\n                \"Amount\": amount\n            }\n\n            response = requests.post(self.verify_url, json=data, timeout=10)\n            result = response.json()\n\n            if result[\"Status\"] == 100:\n                ref_id = result[\"RefID\"]\n                logger.info(f\"Payment verified successfully. RefID: {ref_id}\")\n                return {\n                    \"success\": True,\n                    \"ref_id\": ref_id,\n                    \"status\": \"verified\"\n                }\n            else:\n                error_msg = self._get_error_message(result[\"Status\"])\n                logger.error(f\"Payment verification failed: {error_msg}\")\n                return {\n                    \"success\": False,\n                    \"error\": error_msg\n                }\n\n        except requests.exceptions.RequestException as e:\n            logger.error(f\"Request error during verification: {e}\")\n            return {\n                \"success\": False,\n                \"error\": \"خطا در تأیید پرداخت\"\n            }\n        except Exception as e:\n            logger.error(f\"Unexpected error during verification: {e}\")\n            return {\n                \"success\": False,\n                \"error\": \"خطای غیرمنتظره در تأیید پرداخت\"\n            }\n\n    def _get_error_message(self, status_code: int) -> str:\n        \"\"\"Get Persian error message for status code\"\"\"\n        error_messages = {\n            -1: \"اطلاعات ارسال شده ناقص است\",\n            -2: \"IP یا مرچنت کد پذیرنده صحیح نیست\",\n            -3: \"با توجه به محدودیت‌های شاپرک امکان پردازش وجود ندارد\",\n            -4: \"سطح تأیید پذیرنده پایین‌تر از سطح نقره‌ای است\",\n            -11: \"درخواست مورد نظر یافت نشد\",\n            -12: \"امکان ویرایش درخواست میسر نمی‌باشد\",\n            -21: \"هیچ نوع عملیات مالی برای این تراکنش یافت نشد\",\n            -22: \"تراکنش ناموفق می‌باشد\",\n            -33: \"رقم تراکنش با رقم پرداخت شده مطابقت ندارد\",\n            -34: \"سقف تقسیم تراکنش از لحاظ تعداد یا رقم عبور نموده است\",\n            -40: \"اجازه دسترسی به متد مربوطه وجود ندارد\",\n            -41: \"اطلاعات ارسال شده مربوط به AdditionalData غیر معتبر می‌باشد\",\n            -42: \"مدت زمان معتبر طول عمر شناسه پرداخت باید بین ۳۰ دقیقه تا ۴۵ روز باشد\",\n            -54: \"درخواست مورد نظر آرشیو شده است\",\n            101: \"عملیات پرداخت موفق بوده و قبلاً PaymentVerification تراکنش انجام شده است\"\n        }\n        \n        return error_messages.get(status_code, f\"خطای نامشخص با کد {status_code}\")\n","size_bytes":6136},"payment_data/bot/zarinpal_test.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nZarinPal Payment Integration - Fixed Version\nHandles payment processing through ZarinPal gateway.\n\"\"\"\n\nimport requests\nimport json\nfrom typing import Dict, Any, Optional\nfrom utils.logger import setup_logger\n\nlogger = setup_logger(__name__)\n\n\nclass ZarinPalGateway:\n    \"\"\"ZarinPal payment gateway integration\"\"\"\n\n    def __init__(self, merchant_id: str, sandbox: bool = True):\n        self.merchant_id = merchant_id\n        self.sandbox = sandbox\n\n        if sandbox:\n            # Sandbox URLs\n            self.request_url = \"https://sandbox.zarinpal.com/pg/rest/WebGate/PaymentRequest.json\"\n            self.verify_url = \"https://sandbox.zarinpal.com/pg/rest/WebGate/PaymentVerification.json\"\n            self.gateway_url = \"https://sandbox.zarinpal.com/pg/StartPay/\"\n        else:\n            # Production URLs - API v4\n            self.request_url = \"https://api.zarinpal.com/pg/v4/payment/request/\"\n            self.verify_url = \"https://api.zarinpal.com/pg/v4/payment/verify/\"\n            self.gateway_url = \"https://www.zarinpal.com/pg/StartPay/\"\n\n    def create_payment_request(self,\n                               amount: int,\n                               description: str,\n                               callback_url: str,\n                               customer_email: str = \"\",\n                               customer_mobile: str = \"\") -> Dict[str, Any]:\n        \"\"\"Create payment request\"\"\"\n        try:\n            if self.sandbox:\n                # Sandbox API (v3 format)\n                data = {\n                    \"MerchantID\": self.merchant_id,\n                    \"Amount\": amount,\n                    \"Description\": description,\n                    \"CallbackURL\": callback_url,\n                    \"Email\": customer_email,\n                    \"Mobile\": customer_mobile\n                }\n                headers = {'Content-Type': 'application/json'}\n            else:\n                # Production API (v4 format)\n                data = {\n                    \"merchant_id\": self.merchant_id,\n                    \"amount\": amount,\n                    \"description\": description,\n                    \"callback_url\": callback_url,\n                    \"metadata\": {\n                        \"email\": customer_email,\n                        \"mobile\": customer_mobile\n                    }\n                }\n                headers = {\n                    'Content-Type': 'application/json',\n                    'Accept': 'application/json'\n                }\n\n            logger.info(f\"Sending payment request to: {self.request_url}\")\n            logger.info(\n                f\"Request data: {json.dumps(data, ensure_ascii=False)}\")\n\n            response = requests.post(self.request_url,\n                                     json=data,\n                                     headers=headers,\n                                     timeout=15)\n\n            logger.info(f\"Response status: {response.status_code}\")\n            logger.info(f\"Response headers: {dict(response.headers)}\")\n            logger.info(f\"Response text: {response.text}\")\n\n            if response.status_code != 200:\n                return {\n                    \"success\": False,\n                    \"error\":\n                    f\"HTTP Error {response.status_code}: {response.text}\"\n                }\n\n            result = response.json()\n\n            if self.sandbox:\n                # Sandbox response format\n                if result.get(\"Status\") == 100:\n                    authority = result.get(\"Authority\")\n                    payment_url = f\"{self.gateway_url}{authority}\"\n\n                    logger.info(\n                        f\"Payment request created successfully. Authority: {authority}\"\n                    )\n                    return {\n                        \"success\": True,\n                        \"authority\": authority,\n                        \"payment_url\": payment_url\n                    }\n                else:\n                    error_msg = self._get_error_message(\n                        result.get(\"Status\", -999))\n                    logger.error(\n                        f\"ZarinPal payment request failed: {error_msg}\")\n                    return {\"success\": False, \"error\": error_msg}\n            else:\n                # Production response format\n                if result.get(\"data\") and result[\"data\"].get(\"code\") == 100:\n                    authority = result[\"data\"].get(\"authority\")\n                    payment_url = f\"{self.gateway_url}{authority}\"\n\n                    logger.info(\n                        f\"Payment request created successfully. Authority: {authority}\"\n                    )\n                    return {\n                        \"success\": True,\n                        \"authority\": authority,\n                        \"payment_url\": payment_url\n                    }\n                else:\n                    error_msg = result.get(\"errors\",\n                                           {}).get(\"message\", \"خطای نامشخص\")\n                    logger.error(\n                        f\"ZarinPal payment request failed: {error_msg}\")\n                    return {\"success\": False, \"error\": error_msg}\n\n        except requests.exceptions.Timeout:\n            logger.error(\"Request timeout\")\n            return {\n                \"success\": False,\n                \"error\": \"زمان درخواست به پایان رسید. لطفاً دوباره تلاش کنید.\"\n            }\n        except requests.exceptions.ConnectionError:\n            logger.error(\"Connection error\")\n            return {\n                \"success\":\n                False,\n                \"error\":\n                \"خطا در اتصال به درگاه پرداخت. اتصال اینترنت خود را بررسی کنید.\"\n            }\n        except requests.exceptions.RequestException as e:\n            logger.error(f\"Request error: {e}\")\n            return {\"success\": False, \"error\": \"خطا در ارتباط با درگاه پرداخت\"}\n        except json.JSONDecodeError as e:\n            logger.error(f\"JSON decode error: {e}\")\n            return {\"success\": False, \"error\": \"پاسخ نامعتبر از درگاه پرداخت\"}\n        except Exception as e:\n            logger.error(f\"Unexpected error: {e}\")\n            return {\n                \"success\": False,\n                \"error\": \"خطای غیرمنتظره در ایجاد درخواست پرداخت\"\n            }\n\n    def verify_payment(self, authority: str, amount: int) -> Dict[str, Any]:\n        \"\"\"Verify payment\"\"\"\n        try:\n            if self.sandbox:\n                # Sandbox API (v3 format)\n                data = {\n                    \"MerchantID\": self.merchant_id,\n                    \"Authority\": authority,\n                    \"Amount\": amount\n                }\n                headers = {'Content-Type': 'application/json'}\n            else:\n                # Production API (v4 format)\n                data = {\n                    \"merchant_id\": self.merchant_id,\n                    \"authority\": authority,\n                    \"amount\": amount\n                }\n                headers = {\n                    'Content-Type': 'application/json',\n                    'Accept': 'application/json'\n                }\n\n            logger.info(f\"Verifying payment with authority: {authority}\")\n\n            response = requests.post(self.verify_url,\n                                     json=data,\n                                     headers=headers,\n                                     timeout=15)\n\n            logger.info(\n                f\"Verification response status: {response.status_code}\")\n            logger.info(f\"Verification response: {response.text}\")\n\n            if response.status_code != 200:\n                return {\n                    \"success\": False,\n                    \"error\":\n                    f\"HTTP Error {response.status_code}: {response.text}\"\n                }\n\n            result = response.json()\n\n            if self.sandbox:\n                # Sandbox response format\n                if result.get(\"Status\") == 100:\n                    ref_id = result.get(\"RefID\")\n                    logger.info(\n                        f\"Payment verified successfully. RefID: {ref_id}\")\n                    return {\n                        \"success\": True,\n                        \"ref_id\": ref_id,\n                        \"status\": \"verified\"\n                    }\n                else:\n                    error_msg = self._get_error_message(\n                        result.get(\"Status\", -999))\n                    logger.error(f\"Payment verification failed: {error_msg}\")\n                    return {\"success\": False, \"error\": error_msg}\n            else:\n                # Production response format\n                if result.get(\"data\") and result[\"data\"].get(\"code\") == 100:\n                    ref_id = result[\"data\"].get(\"ref_id\")\n                    logger.info(\n                        f\"Payment verified successfully. RefID: {ref_id}\")\n                    return {\n                        \"success\": True,\n                        \"ref_id\": ref_id,\n                        \"status\": \"verified\"\n                    }\n                else:\n                    error_msg = result.get(\"errors\",\n                                           {}).get(\"message\", \"خطای نامشخص\")\n                    logger.error(f\"Payment verification failed: {error_msg}\")\n                    return {\"success\": False, \"error\": error_msg}\n\n        except requests.exceptions.Timeout:\n            logger.error(\"Verification request timeout\")\n            return {\n                \"success\": False,\n                \"error\": \"زمان تأیید پرداخت به پایان رسید\"\n            }\n        except requests.exceptions.ConnectionError:\n            logger.error(\"Verification connection error\")\n            return {\n                \"success\": False,\n                \"error\": \"خطا در اتصال برای تأیید پرداخت\"\n            }\n        except requests.exceptions.RequestException as e:\n            logger.error(f\"Verification request error: {e}\")\n            return {\"success\": False, \"error\": \"خطا در تأیید پرداخت\"}\n        except json.JSONDecodeError as e:\n            logger.error(f\"Verification JSON decode error: {e}\")\n            return {\"success\": False, \"error\": \"پاسخ نامعتبر در تأیید پرداخت\"}\n        except Exception as e:\n            logger.error(f\"Unexpected verification error: {e}\")\n            return {\n                \"success\": False,\n                \"error\": \"خطای غیرمنتظره در تأیید پرداخت\"\n            }\n\n    def _get_error_message(self, status_code: int) -> str:\n        \"\"\"Get Persian error message for status code\"\"\"\n        error_messages = {\n            -1: \"اطلاعات ارسال شده ناقص است\",\n            -2: \"IP یا مرچنت کد پذیرنده صحیح نیست\",\n            -3: \"با توجه به محدودیت‌های شاپرک امکان پردازش وجود ندارد\",\n            -4: \"سطح تأیید پذیرنده پایین‌تر از سطح نقره‌ای است\",\n            -11: \"درخواست مورد نظر یافت نشد\",\n            -12: \"امکان ویرایش درخواست میسر نمی‌باشد\",\n            -21: \"هیچ نوع عملیات مالی برای این تراکنش یافت نشد\",\n            -22: \"تراکنش ناموفق می‌باشد\",\n            -33: \"رقم تراکنش با رقم پرداخت شده مطابقت ندارد\",\n            -34: \"سقف تقسیم تراکنش از لحاظ تعداد یا رقم عبور نموده است\",\n            -40: \"اجازه دسترسی به متد مربوطه وجود ندارد\",\n            -41: \"اطلاعات ارسال شده مربوط به AdditionalData غیر معتبر می‌باشد\",\n            -42:\n            \"مدت زمان معتبر طول عمر شناسه پرداخت باید بین ۳۰ دقیقه تا ۴۵ روز باشد\",\n            -54: \"درخواست مورد نظر آرشیو شده است\",\n            101:\n            \"عملیات پرداخت موفق بوده و قبلاً PaymentVerification تراکنش انجام شده است\",\n            -999: \"خطای نامشخص - پاسخ از سرور دریافت نشد\"\n        }\n\n        return error_messages.get(status_code,\n                                  f\"خطای نامشخص با کد {status_code}\")\n","size_bytes":12534},"README.md":{"content":"# decoteen\n\n","size_bytes":12},"retry_hesabfa_invoice.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nتلاش مجدد برای ثبت فاکتور حسابفا برای سفارش موجود\n\"\"\"\n\nimport asyncio\nimport json\nfrom bot.hesabfa_integration import HesabfaAPI\nfrom bot.order_server import OrderManagementServer\n\nasync def retry_hesabfa_for_order():\n    \"\"\"تلاش مجدد برای ثبت فاکتور حسابفا\"\"\"\n    \n    # بارگذاری سفارش آخرین\n    order_server = OrderManagementServer()\n    order_id = \"00027\"  # آخرین سفارش\n    \n    order_data = await order_server._load_order(order_id)\n    if not order_data:\n        print(f\"❌ سفارش {order_id} یافت نشد\")\n        return\n    \n    print(f\"📋 بارگذاری سفارش {order_id}\")\n    print(f\"👤 مشتری: {order_data['customer']['name']}\")\n    print(f\"💰 مبلغ کل: {order_data['pricing']['total']:,} تومان\")\n    \n    # تلاش برای ثبت در حسابفا\n    hesabfa_api = HesabfaAPI()\n    \n    print(\"\\n🔄 تلاش مجدد برای ثبت فاکتور در حسابفا...\")\n    \n    # ابتدا ایجاد مخاطب\n    print(\"👤 ایجاد مخاطب...\")\n    contact_result = await hesabfa_api.create_contact_if_not_exists(order_data[\"customer\"])\n    print(f\"   نتیجه: {contact_result}\")\n    \n    # سپس ایجاد فاکتور\n    print(\"🧾 ایجاد فاکتور...\")\n    invoice_result = await hesabfa_api.create_invoice(order_data)\n    print(f\"   نتیجه: {invoice_result}\")\n    \n    if invoice_result.get(\"success\"):\n        # به‌روزرسانی سفارش با اطلاعات حسابفا\n        order_data[\"hesabfa_invoice_id\"] = invoice_result.get(\"invoice_id\")\n        order_data[\"hesabfa_invoice_number\"] = invoice_result.get(\"invoice_number\")\n        \n        # اضافه کردن به تاریخچه\n        from datetime import datetime\n        hesabfa_entry = {\n            \"status\": \"hesabfa_created\",\n            \"timestamp\": datetime.now().isoformat(),\n            \"admin\": \"دستی\",\n            \"note\": f\"پیش‌فاکتور در حسابفا ثبت شد - شماره: {invoice_result.get('invoice_number')}\"\n        }\n        order_data[\"status_history\"].append(hesabfa_entry)\n        \n        # ذخیره تغییرات\n        await order_server._save_order(order_id, order_data)\n        \n        print(f\"✅ فاکتور در حسابفا ثبت شد!\")\n        print(f\"   شماره فاکتور: {invoice_result.get('invoice_number')}\")\n        print(f\"   شناسه: {invoice_result.get('invoice_id')}\")\n    else:\n        print(f\"❌ خطا: {invoice_result.get('error')}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(retry_hesabfa_for_order())","size_bytes":2669},"test_hesabfa.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nتست اتصال به حسابفا\n\"\"\"\n\nimport os\nimport requests\nimport json\nfrom bot.hesabfa_integration import HesabfaAPI\n\ndef test_hesabfa_connection():\n    \"\"\"تست اتصال به حسابفا\"\"\"\n    \n    # دریافت اطلاعات احراز هویت\n    api_key = os.getenv(\"HESABFA_API_KEY\")\n    login_token = os.getenv(\"HESABFA_LOGIN_TOKEN\")\n    \n    print(f\"API Key: {api_key[:10]}...\" if api_key else \"API Key: ❌ Not Found\")\n    print(f\"Login Token: {login_token[:10]}...\" if login_token else \"Login Token: ❌ Not Found\")\n    \n    if not api_key or not login_token:\n        print(\"❌ اطلاعات احراز هویت حسابفا یافت نشد\")\n        return False\n    \n    # تست endpoint های مختلف\n    endpoints_to_test = [\n        \"/Setting\",\n        \"/contact\", \n        \"/invoice\",\n        \"/item\"\n    ]\n    \n    base_url = \"https://api.hesabfa.com/v1\"\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"apikey\": api_key,\n        \"logintoken\": login_token\n    }\n    \n    print(\"\\n🔍 تست endpoint های مختلف:\")\n    \n    for endpoint in endpoints_to_test:\n        try:\n            url = f\"{base_url}{endpoint}\"\n            print(f\"\\n📡 تست {endpoint}...\")\n            \n            response = requests.get(\n                url,\n                headers=headers,\n                timeout=30\n            )\n            \n            print(f\"   Status: {response.status_code}\")\n            \n            if response.status_code == 200:\n                try:\n                    result = response.json()\n                    print(f\"   Response: {json.dumps(result, ensure_ascii=False, indent=2)[:200]}...\")\n                except:\n                    print(f\"   Response: {response.text[:200]}...\")\n            else:\n                print(f\"   Error: {response.text[:200]}\")\n                \n        except requests.exceptions.Timeout:\n            print(f\"   ❌ Timeout - {endpoint}\")\n        except requests.exceptions.ConnectionError:\n            print(f\"   ❌ Connection Error - {endpoint}\")\n        except Exception as e:\n            print(f\"   ❌ Error: {e}\")\n    \n    print(\"\\n🧪 تست ایجاد فاکتور نمونه:\")\n    \n    # تست ایجاد فاکتور با داده‌های نمونه\n    try:\n        hesabfa_api = HesabfaAPI()\n        \n        sample_order = {\n            \"order_id\": \"TEST001\",\n            \"customer\": {\n                \"name\": \"مشتری تست\",\n                \"customer_id\": \"TEST001\",\n                \"city\": \"تهران\"\n            },\n            \"cart_items\": [{\n                \"product_id\": \"TEST_PRODUCT\",\n                \"product_name\": \"محصول تست\",\n                \"size\": \"استاندارد\",\n                \"quantity\": 1,\n                \"price\": 100000\n            }],\n            \"pricing\": {\n                \"subtotal\": 100000,\n                \"discount\": 10000,\n                \"tax\": 9000,\n                \"total\": 99000\n            },\n            \"payment_method\": \"نقدی\",\n            \"user_id\": \"TEST_USER\"\n        }\n        \n        print(\"📋 داده‌های نمونه آماده شد...\")\n        \n        # اول تست ایجاد مخاطب\n        print(\"👤 تست ایجاد مخاطب...\")\n        contact_result = await hesabfa_api.create_contact_if_not_exists(sample_order[\"customer\"])\n        print(f\"   نتیجه مخاطب: {contact_result}\")\n        \n        # بعد تست ایجاد فاکتور  \n        print(\"🧾 تست ایجاد فاکتور...\")\n        invoice_result = await hesabfa_api.create_invoice(sample_order)\n        print(f\"   نتیجه فاکتور: {invoice_result}\")\n        \n        return invoice_result.get(\"success\", False)\n        \n    except Exception as e:\n        print(f\"❌ خطا در تست فاکتور: {e}\")\n        return False\n\nif __name__ == \"__main__\":\n    import asyncio\n    result = asyncio.run(test_hesabfa_connection())\n    if result:\n        print(\"\\n✅ تست حسابفا موفق بود!\")\n    else:\n        print(\"\\n❌ تست حسابفا ناموفق بود!\")","size_bytes":4113}}}